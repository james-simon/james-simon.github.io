---
layout: default
permalink: /t-sne/
---

<script src="{{site.baseurl}}/js/tsne.js"></script>

<style>
  #tsne-container {
    width: 100%;
    height: 80vh;
    border: 1px solid #ddd;
    margin: 20px 0;
    position: relative;
    background-color: #fafafa;
  }

  #similarity-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  .post-point {
    position: absolute;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.15s;
    transform: translate(-50%, -50%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
  }

  .post-point:hover {
    width: 34px;
    height: 34px;
    z-index: 100;
    box-shadow: 0 0 8px rgba(0,0,0,0.3);
  }

  /* COMMENTED OUT - labels next to dots version
  .post-label {
    position: absolute;
    font-size: 11px;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
    transform: translateY(-50%);
    margin-left: 10px;
  }

  .post-label.visible {
    opacity: 1;
  }

  .post-label.highlighted {
    background-color: white;
    padding: 4px 8px;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    z-index: 1000;
    font-weight: 500;
  }
  */

  .post-tooltip {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 14px;
    pointer-events: none;
    z-index: 1000;
    white-space: nowrap;
    display: none;
    transform: translateY(-100%) translateY(-10px);
  }

  #controls {
    margin: 20px 0;
  }

  #status {
    font-size: 14px;
    color: #666;
  }

  .legend {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin: 10px 0;
    font-size: 14px;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .legend-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
  }
</style>

<div class="container">
  <h1>A t-SNE viz of my blog</h1>
  <p>Calculated from embeddings generated by OpenAI's <code>text-embedding-3-small</code>.</p>

  <div id="controls">
    <span id="status">Loading embeddings...</span>
  </div>

  <div class="legend" id="legend"></div>

  <div id="tsne-container">
    <canvas id="similarity-canvas"></canvas>
    <div class="post-tooltip" id="tooltip"></div>
  </div>
</div>

<script>
(function() {
  const container = document.getElementById('tsne-container');
  const tooltip = document.getElementById('tooltip');
  const statusEl = document.getElementById('status');
  const legendEl = document.getElementById('legend');
  const canvas = document.getElementById('similarity-canvas');
  const ctx = canvas.getContext('2d');

  let posts = [];
  let tsne = null;
  let animationFrame = null;
  let currentIteration = 0;
  const maxIterations = 350;
  let embeddings = [];
  let similarities = [];

  // Simple seeded random number generator for deterministic initialization
  function seededRandom(seed) {
    let state = seed;
    return function() {
      state = (state * 1664525 + 1013904223) % 4294967296;
      return state / 4294967296;
    };
  }

  // Category colors
  const categoryColors = {
    'essays': '#e63946',
    'kernels': '#457b9d',
    'dl-science': '#1d3557',
    'mathematics': '#2a9d8f',
    'physics': '#e76f51',
    'biology': '#f4a261',
    'chemistry': '#e9c46a',
    'art': '#a8dadc',
    'adventures': '#8b7355',
    'poetry': '#d8b4fe',
    'society': '#fbbf24'
  };

  function getColorForCategory(category) {
    if (!category) return '#888';
    const cat = category.split(',')[0].trim();
    return categoryColors[cat] || '#888';
  }

  function createLegend() {
    const categories = Object.keys(categoryColors);
    categories.forEach(cat => {
      const item = document.createElement('div');
      item.className = 'legend-item';

      const color = document.createElement('div');
      color.className = 'legend-color';
      color.style.backgroundColor = categoryColors[cat];

      const label = document.createElement('span');
      label.textContent = cat;

      item.appendChild(color);
      item.appendChild(label);
      legendEl.appendChild(item);
    });
  }

  async function loadEmbeddings() {
    try {
      const response = await fetch('{{site.baseurl}}/blogpost_embs/blog_embeddings.json');
      const data = await response.json();
      posts = data;
      statusEl.textContent = `Loaded ${posts.length} posts. Running t-SNE...`;
      initTSNE();
    } catch (error) {
      statusEl.textContent = 'Error loading embeddings. Run generate_embeddings.py first!';
      console.error('Error loading embeddings:', error);
    }
  }

  function cosineSimilarity(a, b) {
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normA += a[i] * a[i];
      normB += b[i] * b[i];
    }
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  function computeSimilarities() {
    const n = embeddings.length;
    similarities = Array(n).fill(0).map(() => Array(n).fill(0));

    let maxSim = -Infinity;
    let minSim = Infinity;
    let maxPair = [0, 0];
    let minPair = [0, 0];

    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const sim = cosineSimilarity(embeddings[i], embeddings[j]);

        // Track extremes
        if (sim > maxSim) {
          maxSim = sim;
          maxPair = [i, j];
        }
        if (sim < minSim) {
          minSim = sim;
          minPair = [i, j];
        }

        // Convert from [-1, 1] to [0, 1]
        const normalizedSim = (sim + 1) / 2;
        similarities[i][j] = normalizedSim;
        similarities[j][i] = normalizedSim;
      }
    }

    // Print extremes
    console.log('=== SIMILARITY EXTREMES ===');
    console.log(`Highest similarity: ${maxSim.toFixed(4)}`);
    console.log(`  "${posts[maxPair[0]].title}" <-> "${posts[maxPair[1]].title}"`);
    console.log(`\nLowest similarity: ${minSim.toFixed(4)}`);
    console.log(`  "${posts[minPair[0]].title}" <-> "${posts[minPair[1]].title}"`);
  }

  function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
  }

  function drawSimilarityLines(solution) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const n = solution.length;

    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        const alpha = similarities[i][j];

        // Only draw if similarity is above threshold
        if (alpha > 0.67) {
          const x1 = solution[i].x * canvas.width;
          const y1 = solution[i].y * canvas.height;
          const x2 = solution[j].x * canvas.width;
          const y2 = solution[j].y * canvas.height;

          // Map alpha: 0.67 -> 0, 1.0 -> 1
          const mappedAlpha = (alpha - 0.67) / 0.33;

          ctx.strokeStyle = `rgba(0, 0, 0, ${mappedAlpha * 0.3})`;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
    }
  }

  function initTSNE() {
    // Extract embeddings
    embeddings = posts.map(p => p.embedding);

    // Compute pairwise similarities
    computeSimilarities();

    // Resize canvas
    resizeCanvas();

    // Initialize t-SNE with seeded random
    const rng = seededRandom(12345); // Fixed seed for deterministic results
    tsne = new tsnejs.tSNE({
      dim: 2,
      perplexity: Math.min(30, Math.floor(posts.length / 3)),
      earlyExaggeration: 4.0,
      learningRate: 100.0,
      nIter: maxIterations,
      metric: 'euclidean'
    });

    // Override Math.random temporarily for deterministic initialization
    const originalRandom = Math.random;
    Math.random = rng;
    tsne.initDataRaw(embeddings);
    Math.random = originalRandom;

    // Create point elements
    posts.forEach((post, i) => {
      const point = document.createElement('div');
      point.className = 'post-point';
      point.style.backgroundColor = getColorForCategory(post.category);
      point.dataset.index = i;
      point.innerHTML = post.emoji || '';

      // Add hover interactions
      point.addEventListener('mouseenter', (e) => {
        tooltip.innerHTML = post.title;
        tooltip.style.display = 'block';
        const x = parseFloat(point.style.left);
        const y = parseFloat(point.style.top);
        tooltip.style.left = x + '%';
        tooltip.style.top = y + '%';
      });

      point.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
      });

      point.addEventListener('click', () => {
        window.location.href = '{{site.baseurl}}' + post.url;
      });

      container.appendChild(point);
    });

    currentIteration = 0;
    animate();
  }

  function animate() {
    if (currentIteration >= maxIterations) {
      statusEl.textContent = `Converged! (${posts.length} posts)`;
      return;
    }

    // Run one t-SNE iteration with seeded random
    const rng = seededRandom(12345 + currentIteration);
    const originalRandom = Math.random;
    Math.random = rng;
    tsne.step();
    Math.random = originalRandom;
    currentIteration++;

    // Update point positions
    const solution = tsne.getSolution();
    const points = container.querySelectorAll('.post-point');

    // Find min/max for normalization
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    solution.forEach(pos => {
      minX = Math.min(minX, pos[0]);
      maxX = Math.max(maxX, pos[0]);
      minY = Math.min(minY, pos[1]);
      maxY = Math.max(maxY, pos[1]);
    });

    // Add padding
    const padding = 0.05;
    const rangeX = maxX - minX;
    const rangeY = maxY - minY;

    // Store normalized positions for drawing
    const normalizedPositions = solution.map((pos, i) => {
      const x = (pos[0] - minX) / rangeX;
      const y = (pos[1] - minY) / rangeY;

      const normalizedX = padding + x * (1 - 2 * padding);
      const normalizedY = padding + y * (1 - 2 * padding);

      points[i].style.left = (normalizedX * 100) + '%';
      points[i].style.top = (normalizedY * 100) + '%';

      return { x: normalizedX, y: normalizedY };
    });

    // Draw similarity lines
    drawSimilarityLines(normalizedPositions);

    statusEl.textContent = `Running t-SNE... ${currentIteration}/${maxIterations}`;

    // Continue animation
    animationFrame = requestAnimationFrame(animate);
  }

  createLegend();
  loadEmbeddings();
})();
</script>
