<script>
  // ============================================================================
  // GRAVITY MODE
  // ============================================================================

  function enterGravityMode() {
    if (gravityActive) return;
    gravityActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "GRAVITY ON" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'GRAVITY ON';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00bfff';
    flashMessage.style.textShadow = '0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00bfff';
    flashMessage.style.boxShadow = '0 0 20px #00bfff, inset 0 0 20px rgba(0, 191, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startGravityAnimation(particles);
  }

  function startGravityAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 150; // Falloff distance for exponential potential

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 5000;
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>
