<!DOCTYPE html>
<html>

  <head>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: { autoNumber: "AMS" },
        tagSide: "right"
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      }
    });
    MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function () {
      MathJax.InputJax.TeX.Stack.Item.AMSarray.Augment({
        clearTag() {
          if (!this.global.notags) {
            this.super(arguments).clearTag.call(this);
          }
        }
      });
    });
  </script>
  <script type="text/javascript" charset="utf-8"
    src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML">
  </script>


  <!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Jamie Simon</title>
  <meta name="description" content="">

  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">

  <!-- <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">
  <script src="/boostrap/js/bootstrap.js"></script> -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">

  <link rel="canonical" href="http://james-simon.github.io/research/">
  <link rel="alternate" type="application/rss+xml" title="Jamie Simon" href="http://james-simon.github.io/feed.xml">

  <style>
    body {
      font-family: "et-book", "ETBookOT", "ET Book", Georgia, "Times New Roman", serif !important;
    }

    a:link {
      color: #1a4d8f;
      text-decoration: none;
    }

    a:visited {
      color: #6b2d8f;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>

  

</head>


  <body style="display: flex; flex-direction: column; min-height: 100vh; margin: 0;">

    <!-- <header class="site-header"> -->
    <!-- <a class="site-title" href="/">Jamie Simon</a> -->
<!-- </header> -->

    <style>
      .nav-link {
        transition: all 0.2s ease;
        border-radius: 4px;
        padding: 8px 16px !important;
      }

      .nav-link:hover {
        background-color: #333 !important;
        color: white !important;
      }

      .nav-link:hover i {
        color: white !important;
      }

      /* Hide text on narrow screens, show only icons */
      @media (max-width: 767px) {
        .nav-link .nav-text {
          display: none;
        }
        .nav-link {
          padding: 8px 12px !important;
        }
      }
    </style>

    <nav class="navbar navbar-expand navbar-light" style="background-color: #e8e8e8;">
      <div class = "container">
        <a class="navbar-brand" href="/">Jamie Simon</a></span> </a>
        <div class="navbar-collapse">
          <ul class="nav navbar-nav ml-auto" style="flex-wrap: nowrap;">
            <li class = "nav-item active"><a class="nav-link" href="/research/"><i class="fas fa-cogs"></i><span class="nav-text"> Research</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/blog/"><i class="fas fa-seedling"></i><span class="nav-text"> Blog</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/puzzles/"><i class="fab fa-laravel"></i><span class="nav-text"> Puzzles</span></a></li>
          </ul>
        </div>
      </div>
    </nav>

    <style>
  .char {
    display: inline;
    margin: 0;
    padding: 0;
    border: 0;
    vertical-align: baseline;
    line-height: inherit;
    font: inherit;
    font-size: inherit;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    color: inherit;
    white-space: inherit;
    letter-spacing: inherit;
    word-spacing: inherit;
    text-decoration: inherit;
    text-transform: inherit;
    background: transparent;
  }

  .char-particle {
    position: fixed;
    margin: 0;
    will-change: transform;
    pointer-events: none;
  }

  body.shatter-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.bird-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.panic-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  #shatter-overlay-blocker {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 9999;
    display: none;
  }

  body.shatter-locked #shatter-overlay-blocker {
    display: block;
  }
</style>

<div id="shatter-overlay-blocker"></div>
<audio id="shatter-audio" preload="auto" src="/audio/glass_bottle_breaking.mp3"></audio>
<audio id="pop-1" preload="auto" src="/audio/pop_1.mp3"></audio>
<audio id="pop-2" preload="auto" src="/audio/pop_2.mp3"></audio>
<audio id="pop-3" preload="auto" src="/audio/pop_3.mp3"></audio>
<audio id="pop-4" preload="auto" src="/audio/pop_4.mp3"></audio>
<!-- Bird mode audio -->
<audio id="goose-honk" src="/audio/bird_sounds/goose_honk.mp3" preload="auto"></audio>
<audio id="goose-yell" src="/audio/bird_sounds/goose_yell.mp3" preload="auto"></audio>
<audio id="hawk-call" src="/audio/bird_sounds/hawk_call.mp3" preload="auto"></audio>
<!-- Panic mode audio -->
<audio id="panic-alarm" preload="auto" src="/audio/alarm.mp3"></audio>
<audio id="panic-scream" preload="auto" src="/audio/crowd_scream.mp3"></audio>

<script>
  // ============================================================================
  // SHARED STATE AND UTILITIES FOR INTERACTIVE MODES
  // ============================================================================

  // Global state
  let shatterActive = false;
  let gravityActive = false;
  let vacuumActive = false;
  let pongActive = false;
  let birdModeActive = false;
  let panicActive = false;
  let mouseX = 0;
  let mouseY = 0;
  let prevMouseX = 0;
  let prevMouseY = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function playRandomPop() {
    const popIndex = Math.floor(Math.random() * 4) + 1;
    const audio = document.getElementById(`pop-${popIndex}`);
    if (audio) {
      audio.volume = 0.3; // Quieter pops
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Pop sound failed:', err));
    }
  }

  // Check if a point is close to a line segment
  function distanceToLineSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;

    if (lengthSquared === 0) {
      // Line segment is a point
      const distX = px - x1;
      const distY = py - y1;
      return Math.sqrt(distX * distX + distY * distY);
    }

    // Project point onto line segment
    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t)); // Clamp to [0, 1]

    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;

    const distX = px - closestX;
    const distY = py - closestY;
    return Math.sqrt(distX * distX + distY * distY);
  }

  function wrapTextNodes(node) {
    // Skip script, style, and interactive mode elements
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName;
      const elemId = node.id;

      // Skip these elements entirely
      if (tagName === 'SCRIPT' || tagName === 'STYLE' ||
          tagName === 'CODE' || tagName === 'PRE' ||
          tagName === 'KBD' || tagName === 'SAMP' ||
          tagName === 'TEXTAREA' || tagName === 'INPUT' ||
          tagName === 'SELECT' || tagName === 'BUTTON' ||
          elemId === 'shatter-overlay-blocker' ||
          elemId === 'shatter-audio' ||
          elemId === 'panic-button' ||
          elemId?.startsWith('pop-')) {
        return;
      }

      // Skip fixed/absolute positioned elements (like nav, modals, etc.)
      const style = window.getComputedStyle(node);
      if (style.position === 'fixed' || style.position === 'absolute') {
        return;
      }

      // Skip elements that are hidden
      if (style.display === 'none' || style.visibility === 'hidden') {
        return;
      }
    }

    // If it's a text node, wrap each character
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text.trim().length === 0) return; // Skip whitespace-only nodes

      const fragment = document.createDocumentFragment();
      // Use Array.from to properly handle multi-byte characters like emojis
      const chars = Array.from(text);
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === ' ') {
          // Preserve spaces as regular text nodes
          fragment.appendChild(document.createTextNode(' '));
        } else {
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = char;
          fragment.appendChild(span);
        }
      }
      node.parentNode.replaceChild(fragment, node);
    }
    // Recursively process child nodes
    else if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes);
      children.forEach(child => wrapTextNodes(child));
    }
  }

  // Gaussian random number generator (Box-Muller transform)
  function gaussianRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * stdDev + mean;
  }

  // Track if text has been wrapped
  let textWrapped = false;

  // Wrap text lazily when first mode is activated
  function ensureTextWrapped() {
    if (textWrapped) return;
    textWrapped = true;
    wrapTextNodes(document.body);
  }
</script>

<script>
  // ============================================================================
  // SHATTER MODE
  // ============================================================================

  function enterShatterMode() {
    if (shatterActive) return;
    shatterActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    const particles = [];

    // Helper function to create particle from element
    function createParticle(element, rect, isText = false) {
      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the element
      const clone = element.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(element);

      // For icon elements (i, svg), copy minimal styles to avoid interfering with pseudo-elements
      if (element.tagName === 'I' || element.tagName === 'SVG') {
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.color = computedStyle.color;
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      } else {
        // For other elements, copy full styles
        // Ensure emoji fonts are preserved by adding them to the font stack
        const fontFamily = computedStyle.fontFamily;
        clone.style.fontFamily = fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.fontWeight = computedStyle.fontWeight;
        clone.style.color = computedStyle.color;
        clone.style.backgroundColor = computedStyle.backgroundColor;
        clone.style.border = computedStyle.border;
        clone.style.borderRadius = computedStyle.borderRadius;
        clone.style.padding = computedStyle.padding;

        // Preserve dimensions for all elements to prevent shrinking
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      }

      // Set z-index: text always on top, then smaller elements in front
      if (isText) {
        clone.style.zIndex = '10000';
      } else {
        // Calculate area and set z-index inversely (smaller = higher z)
        const area = rect.width * rect.height;
        // Map area to z-index range 1000-9999 (larger area = lower z)
        const zIndex = Math.max(1000, Math.min(9999, 9999 - Math.floor(area / 10)));
        clone.style.zIndex = zIndex.toString();
      }

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      element.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: rect.width,
        height: rect.height
      });
    }

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();
      createParticle(char, rect, true); // isText = true
    });

    // Collect all other shatterable elements
    const elements = document.querySelectorAll('img, button, .styled-box, h1, h2, h3, h4, h5, h6, blockquote, svg, i, nav span, nav div');
    elements.forEach(el => {
      // Skip if it's the overlay blocker
      if (el.id === 'shatter-overlay-blocker') return;

      // Skip empty elements or elements with no visible content
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return;

      createParticle(el, rect);
    });

    // Collect line breaks and render them as small horizontal lines
    const lineBreaks = document.querySelectorAll('br');
    lineBreaks.forEach(br => {
      const rect = br.getBoundingClientRect();

      // Create a visible line element for the br
      const line = document.createElement('div');
      line.style.width = '20px';
      line.style.height = '2px';
      line.style.backgroundColor = '#999';
      line.style.position = 'fixed';
      line.style.left = rect.left + 'px';
      line.style.top = rect.top + 'px';
      line.classList.add('char-particle');

      // Add to body
      document.body.appendChild(line);

      // Hide original
      br.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: line,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: 20,
        height: 2
      });
    });

    // Play shatter sound after text wrapping and particle collection
    const audio = document.getElementById('shatter-audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Audio play failed:', err));
    }

    // Start animation
    startShatterAnimation(particles);
  }

  function startShatterAnimation(particles) {
    let lastTime = performance.now();
    const gravity = 1000; // Doubled gravity for faster fall
    const damping = 0.6; // More energy loss on bounce

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Apply gravity
        particle.vy += gravity * dt;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // GRAVITY MODE
  // ============================================================================

  function enterGravityMode() {
    if (gravityActive) return;
    gravityActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "GRAVITY ON" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'GRAVITY ON';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00bfff';
    flashMessage.style.textShadow = '0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00bfff';
    flashMessage.style.boxShadow = '0 0 20px #00bfff, inset 0 0 20px rgba(0, 191, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startGravityAnimation(particles);
  }

  function startGravityAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 150; // Falloff distance for exponential potential

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 5000;
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // VACUUM MODE
  // ============================================================================

  function enterVacuumMode() {
    if (vacuumActive) return;
    vacuumActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "VACUUM MODE INITIATED" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'VACUUM MODE INITIATED';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00ff00';
    flashMessage.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00ff00';
    flashMessage.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Keep a history of 15 mouse positions for smoother direction calculation
    const mouseHistory = [];
    const HISTORY_LENGTH = 15;

    // Store vacuumed particles in order for burping
    const vacuumedParticles = [];

    // Track mouse position and update history
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;

      // Only add to history if mouse actually moved
      if (prevMouseX !== null && prevMouseY !== null) {
        const dx = mouseX - prevMouseX;
        const dy = mouseY - prevMouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.1) { // Only count as movement if moved enough
          mouseHistory.push({x: mouseX, y: mouseY});

          // Keep only last 5 positions
          if (mouseHistory.length > HISTORY_LENGTH) {
            mouseHistory.shift();
          }
        }
      }
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport or has no width (e.g., newlines)
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startVacuumAnimation(particles, vacuumedParticles, mouseHistory);
  }

  function startVacuumAnimation(particles, vacuumedParticles, mouseHistory) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 300; // Falloff distance for exponential potential
    const velocityDamping = 0.99; // Per-frame velocity damping
    const WAIT_TIME = 5; // seconds to wait before burp mode
    const V_BURP = 1000; // pixels per second
    const BURP_RATE = 30; // chars per second
    let allParticlesGoneTime = null;
    let burpAudio = null;
    let burpStarted = false;
    const burpedParticles = []; // Active burped particles

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      // Only check for particle removal if we have a valid mouse position
      if (mouseX !== null && mouseY !== null && prevMouseX !== null && prevMouseY !== null) {
        // Filter out particles that should be removed
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];

          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Also check distance to line segment traced by mouse movement
          const distToPath = distanceToLineSegment(centerX, centerY, prevMouseX, prevMouseY, mouseX, mouseY);

          // Effective capture radius is proportional to particle size
          const effectiveRadius = Math.min(particle.width, particle.height) / 2;

          // Remove particle if within effective radius of current mouse position or path
          if (dist < effectiveRadius || distToPath < effectiveRadius) {
            // Store particle info for burping later
            vacuumedParticles.push({
              el: particle.el,
              x: particle.x,
              y: particle.y,
              vx: particle.vx,
              vy: particle.vy,
              width: particle.width,
              height: particle.height
            });

            // Hide but don't remove from DOM yet (we'll reuse it for burping)
            particle.el.style.display = 'none';
            particles.splice(i, 1);
            playRandomPop(); // Play pop sound
            continue;
          }
        }
      }

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ), 30x stronger than base
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 150000; // 30x force
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Apply velocity damping
        particle.vx *= velocityDamping;
        particle.vy *= velocityDamping;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Update previous mouse position for next frame
      prevMouseX = mouseX;
      prevMouseY = mouseY;

      // Check if all particles are gone
      if (particles.length === 0 && allParticlesGoneTime === null) {
        allParticlesGoneTime = currentTime;

        // Create BURP INCOMING flash message
        const burpWarning = document.createElement('div');
        burpWarning.id = 'burp-warning';
        burpWarning.textContent = 'BURP INCOMING';
        burpWarning.style.position = 'fixed';
        burpWarning.style.top = '50%';
        burpWarning.style.left = '50%';
        burpWarning.style.transform = 'translate(-50%, -50%)';
        burpWarning.style.fontSize = '64px';
        burpWarning.style.fontFamily = 'Courier New, monospace';
        burpWarning.style.fontWeight = 'bold';
        burpWarning.style.letterSpacing = '4px';
        burpWarning.style.color = '#00ff00';
        burpWarning.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
        burpWarning.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        burpWarning.style.padding = '30px 50px';
        burpWarning.style.border = '4px solid #00ff00';
        burpWarning.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
        burpWarning.style.zIndex = '100000';
        burpWarning.style.pointerEvents = 'none';
        burpWarning.style.textAlign = 'center';
        burpWarning.style.display = 'none';
        document.body.appendChild(burpWarning);

        // Flash with 0.5s on, 0.5s off starting at 3 seconds (last 2 seconds before burp)
        let flashStartTime = null;

        function flashBurpWarning(time) {
          const elapsed = (time - allParticlesGoneTime) / 1000;

          if (elapsed >= 3 && elapsed < WAIT_TIME) {
            if (flashStartTime === null) flashStartTime = time;
            const flashElapsed = (time - flashStartTime) / 1000;
            const cycleTime = flashElapsed % 1.0; // 1 second cycle

            if (cycleTime < 0.5) {
              burpWarning.style.display = 'block';
            } else {
              burpWarning.style.display = 'none';
            }

            requestAnimationFrame(flashBurpWarning);
          } else if (elapsed >= WAIT_TIME) {
            // Remove warning when burp starts
            burpWarning.remove();
          } else if (elapsed < 3) {
            // Keep flashing until we reach 3 seconds
            requestAnimationFrame(flashBurpWarning);
          }
        }

        requestAnimationFrame(flashBurpWarning);
      }

      // Start burp mode after WAIT_TIME
      if (allParticlesGoneTime !== null && burpAudio === null) {
        const elapsed = (currentTime - allParticlesGoneTime) / 1000;

        if (elapsed >= WAIT_TIME && !burpStarted) {
          burpStarted = true;

          burpAudio = new Audio('/audio/burp_loop.mp3');
          burpAudio.loop = true;
          burpAudio.volume = 0.5;
          burpAudio.play();

          // Start burping particles at BURP_RATE
          let lastBurpTime = currentTime;
          const burpInterval = 1000 / BURP_RATE; // ms between burps

          function burpParticle() {
            if (vacuumedParticles.length > 0) {
              // Get current mouse direction
              let dirX = 0, dirY = 1; // Default down
              if (mouseHistory.length >= 2) {
                const oldest = mouseHistory[0];
                const newest = mouseHistory[mouseHistory.length - 1];
                const histDx = newest.x - oldest.x;
                const histDy = newest.y - oldest.y;
                const histDist = Math.sqrt(histDx * histDx + histDy * histDy);

                if (histDist > 0.01) {
                  // Direction is same as mouse movement
                  dirX = histDx / histDist;
                  dirY = histDy / histDist;
                }
              }

              // Pop from end (reverse order)
              const particle = vacuumedParticles.pop();

              // Reset particle position to mouse (centered on particle)
              particle.x = mouseX - particle.width / 2;
              particle.y = mouseY - particle.height / 2;

              // Add Gaussian angular jitter (mean 0, stdev 3 degrees)
              const jitterAngle = gaussianRandom(0, 3) * Math.PI / 180; // Convert to radians
              const currentAngle = Math.atan2(dirY, dirX);
              const newAngle = currentAngle + jitterAngle;
              const jitteredDirX = Math.cos(newAngle);
              const jitteredDirY = Math.sin(newAngle);

              particle.vx = jitteredDirX * V_BURP;
              particle.vy = jitteredDirY * V_BURP;

              // Show particle again
              particle.el.style.display = 'block';
              particle.el.style.left = particle.x + 'px';
              particle.el.style.top = particle.y + 'px';

              burpedParticles.push(particle);
            }

            // Schedule next burp if more particles remain
            if (vacuumedParticles.length > 0) {
              setTimeout(burpParticle, burpInterval);
            } else {
              // All particles burped out, stop the audio
              if (burpAudio) {
                burpAudio.pause();
                burpAudio.currentTime = 0;
              }
            }
          }

          // Start burping
          burpParticle();
        }
      }

      // Animate burped particles with gravity and bouncing
      if (burpStarted && burpedParticles.length > 0) {
        const gravity = 1000; // Same as shatter mode
        const bounceDamping = 0.6; // Energy loss on bounce

        for (let i = burpedParticles.length - 1; i >= 0; i--) {
          const particle = burpedParticles[i];

          // Apply gravity
          particle.vy += gravity * dt;

          // Update position
          particle.x += particle.vx * dt;
          particle.y += particle.vy * dt;

          // Bounce off edges with energy loss (same as shatter mode)
          const width = window.innerWidth;
          const height = window.innerHeight;

          // Left and right edges
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Top and bottom edges
          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.y + particle.height > height + 7) {
            // Keep character visible - allow a bit past the bottom (7px lower)
            particle.y = height - particle.height + 7;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Update transform
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  function enterPongMode() {
    if (pongActive) return;
    pongActive = true;

    // Play ready set go sound immediately
    const readyAudio = new Audio('/audio/chiptune_ready_set_go.mp3');
    readyAudio.volume = 1.0;
    readyAudio.play().catch(err => console.log('Ready audio play failed:', err));

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "METEOR SHOWER INCOMING" message
    const flashMessage = document.createElement('div');
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#ff00ff';
    flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #ff00ff';
    flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';

    const mainText = document.createElement('div');
    mainText.textContent = 'METEOR SHOWER INCOMING';
    mainText.style.fontSize = '64px';

    const subText = document.createElement('div');
    subText.textContent = '(GAME TO 10)';
    subText.style.fontSize = '32px';
    subText.style.marginTop = '10px';

    flashMessage.appendChild(mainText);
    flashMessage.appendChild(subText);
    document.body.appendChild(flashMessage);

    // Show for 2 seconds, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000);
    }, 2000);

    // Create score displays
    const leftScoreContainer = document.createElement('div');
    leftScoreContainer.style.position = 'fixed';
    leftScoreContainer.style.top = '50px';
    leftScoreContainer.style.left = '50px';
    leftScoreContainer.style.zIndex = '99999';
    leftScoreContainer.style.pointerEvents = 'none';
    leftScoreContainer.style.textAlign = 'center';

    const leftLabel = document.createElement('div');
    leftLabel.textContent = 'THEIR\nSCORE';
    leftLabel.style.fontFamily = 'Courier New, monospace';
    leftLabel.style.fontSize = '24px';
    leftLabel.style.fontWeight = 'bold';
    leftLabel.style.color = '#ff0000';
    leftLabel.style.textShadow = '0 0 10px #ff0000';
    leftLabel.style.marginBottom = '10px';
    leftLabel.style.whiteSpace = 'pre-line';
    leftLabel.style.lineHeight = '1.2';

    const leftScore = document.createElement('div');
    leftScore.textContent = '0';
    leftScore.style.fontFamily = 'Courier New, monospace';
    leftScore.style.fontSize = '72px';
    leftScore.style.fontWeight = 'bold';
    leftScore.style.color = '#ff0000';
    leftScore.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';

    leftScoreContainer.appendChild(leftLabel);
    leftScoreContainer.appendChild(leftScore);
    document.body.appendChild(leftScoreContainer);

    const rightScoreContainer = document.createElement('div');
    rightScoreContainer.style.position = 'fixed';
    rightScoreContainer.style.top = '50px';
    rightScoreContainer.style.right = '50px';
    rightScoreContainer.style.zIndex = '99999';
    rightScoreContainer.style.pointerEvents = 'none';
    rightScoreContainer.style.textAlign = 'center';

    const rightLabel = document.createElement('div');
    rightLabel.textContent = 'YOUR\nSCORE';
    rightLabel.style.fontFamily = 'Courier New, monospace';
    rightLabel.style.fontSize = '24px';
    rightLabel.style.fontWeight = 'bold';
    rightLabel.style.color = '#00ff00';
    rightLabel.style.textShadow = '0 0 10px #00ff00';
    rightLabel.style.marginBottom = '10px';
    rightLabel.style.whiteSpace = 'pre-line';
    rightLabel.style.lineHeight = '1.2';

    const rightScore = document.createElement('div');
    rightScore.textContent = '0';
    rightScore.style.fontFamily = 'Courier New, monospace';
    rightScore.style.fontSize = '72px';
    rightScore.style.fontWeight = 'bold';
    rightScore.style.color = '#00ff00';
    rightScore.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';

    rightScoreContainer.appendChild(rightLabel);
    rightScoreContainer.appendChild(rightScore);
    document.body.appendChild(rightScoreContainer);

    // Create player paddle (right side, green)
    const playerPaddle = document.createElement('div');
    playerPaddle.style.position = 'fixed';
    playerPaddle.style.right = '20px';
    playerPaddle.style.width = '15px';
    playerPaddle.style.height = '200px';
    playerPaddle.style.backgroundColor = '#00ff00';
    playerPaddle.style.boxShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';
    playerPaddle.style.zIndex = '99999';
    playerPaddle.style.pointerEvents = 'none';
    document.body.appendChild(playerPaddle);

    // Create enemy paddle (left side, red, static)
    const enemyPaddle = document.createElement('div');
    enemyPaddle.style.position = 'fixed';
    enemyPaddle.style.left = '20px';
    enemyPaddle.style.width = '15px';
    enemyPaddle.style.height = '200px';
    enemyPaddle.style.backgroundColor = '#ff0000';
    enemyPaddle.style.boxShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';
    enemyPaddle.style.zIndex = '99999';
    enemyPaddle.style.pointerEvents = 'none';
    document.body.appendChild(enemyPaddle);

    // Paddle control state
    let playerPaddleY = window.innerHeight / 2 - 100; // Center paddle
    let enemyPaddleY = window.innerHeight / 2 - 100; // Center enemy paddle (static)
    let lastMouseMoveTime = 0;
    let mouseControlActive = false;
    const paddleSpeed = 800; // px/s for keyboard control

    // Update paddle positions
    playerPaddle.style.top = playerPaddleY + 'px';
    enemyPaddle.style.top = enemyPaddleY + 'px';

    // Mouse control
    document.addEventListener('mousemove', (e) => {
      mouseControlActive = true;
      lastMouseMoveTime = Date.now();
      playerPaddleY = Math.max(0, Math.min(window.innerHeight - 200, e.clientY - 100));
    });

    // Keyboard control
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    let themScore = 0;
    let youScore = 0;

    const particles = [];

    // Collect all text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height,
        active: false,
        trail: [] // Store last 15 positions for comet tail
      });
    });

    // Activate one random letter every 2 seconds, starting after 3.5 second delay
    let activationInterval;
    setTimeout(() => {
      activationInterval = setInterval(() => {
        // Find all inactive particles
        const inactiveParticles = particles.filter(p => !p.active);

        if (inactiveParticles.length === 0) {
          clearInterval(activationInterval);
          return;
        }

        // Pick a random inactive particle
        const randomParticle = inactiveParticles[Math.floor(Math.random() * inactiveParticles.length)];

        // Give it velocity with guaranteed horizontal movement
        const minVx = 200; // Minimum horizontal speed
        const vxSign = Math.random() < 0.5 ? -1 : 1;
        randomParticle.vx = vxSign * (minVx + Math.random() * 400); // 200-600 px/s
        randomParticle.vy = (Math.random() - 0.5) * 600;
        randomParticle.active = true;

        // Create whitish-orange burst at launch position
        const launchX = randomParticle.x + randomParticle.width / 2;
        const launchY = randomParticle.y + randomParticle.height / 2;
        createLaunchBurst(launchX, launchY);

        // Play letter release buzz - create new Audio instance each time
        const letterBuzz = new Audio('/audio/chiptune_buzz.wav');
        letterBuzz.volume = 0.35;
        letterBuzz.play().catch(err => console.log('Letter buzz play failed:', err));
      }, 2000);
    }, 3500);

    // Game state
    let blackHoleActive = false;
    let blackHoleEl = null;
    let gameOver = false;

    // Start animation
    startPongAnimation(particles, leftScore, rightScore, playerPaddle, enemyPaddle, () => playerPaddleY, (newY) => { playerPaddleY = newY; }, (newY) => { enemyPaddleY = newY; }, keys, () => mouseControlActive, () => blackHoleActive, (active) => { blackHoleActive = active; }, () => gameOver, (over) => { gameOver = over; });
  }

  function createBurst(x, y, color) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '80px';
    burst.style.height = '80px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = color;
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.8';
    burst.style.boxShadow = `0 0 40px ${color}, 0 0 80px ${color}`;
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.3s, transform 0.3s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.5)';
      setTimeout(() => {
        burst.remove();
      }, 300);
    }, 50);
  }

  function flashPaddle(paddleEl) {
    let flashCount = 0;
    const maxFlashes = 6; // 3 full on/off cycles
    const flashInterval = setInterval(() => {
      paddleEl.style.opacity = paddleEl.style.opacity === '0' ? '1' : '0';
      flashCount++;
      if (flashCount >= maxFlashes) {
        clearInterval(flashInterval);
        paddleEl.style.opacity = '1'; // Ensure it ends visible
      }
    }, 80); // Flash every 80ms
  }

  function createLaunchBurst(x, y) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '50px';
    burst.style.height = '50px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = '#ffcc88'; // Whitish-orange
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.7';
    burst.style.boxShadow = '0 0 20px #ffcc88, 0 0 40px #ffcc88';
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.25s, transform 0.25s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.3)';
      setTimeout(() => {
        burst.remove();
      }, 250);
    }, 50);
  }

  function startPongAnimation(particles, leftScoreEl, rightScoreEl, playerPaddleEl, enemyPaddleEl, getPlayerPaddleY, setPlayerPaddleY, setEnemyPaddleY, keys, getMouseActive, getBlackHoleActive, setBlackHoleActive, getGameOver, setGameOver) {
    let lastTime = performance.now();
    let themScore = 0;
    let youScore = 0;
    const paddleSpeed = 1152; // 20% faster than 960
    let enemyPaddleSpeed = 540; // Slower than player
    let enemyPaddleY = window.innerHeight / 2 - 100;
    let blackHoleEl = null;
    const paddleWidth = 15;
    const paddleHeight = 200;
    const leftPaddleX = 20;
    const rightPaddleX = window.innerWidth - 20 - paddleWidth;

    // Audio elements for paddle hits and game events
    const blip1Audio = new Audio('/audio/pong_blip_1.mp3'); // YOU paddle
    const blip2Audio = new Audio('/audio/pong_blip_2.mp3'); // THEM paddle
    const damage1Audio = new Audio('/audio/chiptune_damage_1.mp3'); // YOU damaged
    const damage2Audio = new Audio('/audio/chiptune_damage_2.mp3'); // THEM damaged
    const victoryAudio = new Audio('/audio/chiptune_victory.mp3'); // Victory
    const defeatAudio = new Audio('/audio/chiptune_defeat.mp3'); // Defeat

    // AI state
    const aiReactionDelay = 280; // ms
    const aiRandomOffset = 35; // px
    let lastAIUpdate = 0;
    let aiTargetY = enemyPaddleY;

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Update player paddle position with keyboard if mouse hasn't moved recently
      if (Date.now() - performance.now() > 100 || !getMouseActive()) {
        let paddleY = getPlayerPaddleY();
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
          paddleY -= paddleSpeed * dt;
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
          paddleY += paddleSpeed * dt;
        }
        paddleY = Math.max(0, Math.min(height - paddleHeight, paddleY));
        setPlayerPaddleY(paddleY);
      }

      // Update enemy AI paddle
      if (currentTime - lastAIUpdate > aiReactionDelay) {
        lastAIUpdate = currentTime;

        // Find the nearest threatening letter (moving left towards enemy paddle)
        let closestThreat = null;
        let minTime = Infinity;

        particles.forEach(particle => {
          if (particle.vx < 0 && particle.active) { // Moving left
            const timeToReach = (particle.x - (leftPaddleX + paddleWidth)) / -particle.vx;
            if (timeToReach > 0 && timeToReach < minTime) {
              minTime = timeToReach;
              // Predict where it will be
              let predictedY = particle.y + particle.vy * timeToReach;

              // Account for bounces off top/bottom
              while (predictedY < 0 || predictedY + particle.height > height) {
                if (predictedY < 0) {
                  predictedY = -predictedY;
                } else if (predictedY + particle.height > height) {
                  predictedY = 2 * (height - particle.height) - predictedY;
                }
              }

              closestThreat = predictedY + particle.height / 2; // Center of letter
            }
          }
        });

        if (closestThreat !== null) {
          // Add random offset for imperfection
          aiTargetY = closestThreat - paddleHeight / 2 + (Math.random() - 0.5) * aiRandomOffset;
        } else {
          // No threats, drift toward center
          aiTargetY = height / 2 - paddleHeight / 2;
        }
      }

      // Move enemy paddle smoothly towards target
      if (enemyPaddleY < aiTargetY) {
        enemyPaddleY = Math.min(aiTargetY, enemyPaddleY + enemyPaddleSpeed * dt);
      } else if (enemyPaddleY > aiTargetY) {
        enemyPaddleY = Math.max(aiTargetY, enemyPaddleY - enemyPaddleSpeed * dt);
      }
      enemyPaddleY = Math.max(0, Math.min(height - paddleHeight, enemyPaddleY));
      setEnemyPaddleY(enemyPaddleY);

      // Update paddle element positions
      playerPaddleEl.style.top = getPlayerPaddleY() + 'px';
      enemyPaddleEl.style.top = enemyPaddleY + 'px';

      // Update particles and check for scoring
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Apply black hole gravity if particle is active and black hole is active
        if (particle.active && getBlackHoleActive()) {
          const blackHoleX = width / 2;
          const blackHoleY = height / 2;
          const blackHoleLambda = 250;
          const blackHoleForce = 750000; // 5x stronger than before

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = blackHoleX - centerX;
          const dy = blackHoleY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            const forceMagnitude = (1 / blackHoleLambda) * Math.exp(-dist / blackHoleLambda) * blackHoleForce;
            let fx = (dx / dist) * forceMagnitude;
            let fy = (dy / dist) * forceMagnitude;

            // Non-conservative in x-coordinate: if moving away from black hole in x, reduce force to 75%
            if (particle.vx * dx < 0) { // Moving away in x (opposite signs)
              fx *= 0.75;
            }
            // Y-component remains conservative (no adjustment)

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Check for player paddle collision (right side)
        const playerPaddleY = getPlayerPaddleY();
        if (particle.vx > 0 && // Moving right
            particle.x + particle.width > rightPaddleX &&
            particle.x < rightPaddleX + paddleWidth &&
            particle.y + particle.height > playerPaddleY &&
            particle.y < playerPaddleY + paddleHeight) {

          // Play YOU paddle blip sound
          blip1Audio.currentTime = 0;
          blip1Audio.play().catch(err => console.log('Blip1 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - playerPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = rightPaddleX - particle.width;
        }

        // Check for enemy paddle collision (left side)
        if (particle.vx < 0 && // Moving left
            particle.x < leftPaddleX + paddleWidth &&
            particle.x + particle.width > leftPaddleX &&
            particle.y + particle.height > enemyPaddleY &&
            particle.y < enemyPaddleY + paddleHeight) {

          // Play THEM paddle blip sound
          blip2Audio.currentTime = 0;
          blip2Audio.play().catch(err => console.log('Blip2 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - enemyPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = leftPaddleX + paddleWidth;
        }

        // Check for left edge (YOU score - enemy missed)
        if (particle.x + particle.width < 0) {
          // Create red burst at contact point (you scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(0, contactY, '#ff0000');

          // Play THEM damage sound
          damage2Audio.currentTime = 0;
          damage2Audio.play().catch(err => console.log('Damage2 play failed:', err));

          // Flash enemy paddle
          flashPaddle(enemyPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            youScore++;
            rightScoreEl.textContent = youScore.toString();

            // Check for YOU reaching 10
            if (youScore === 10 && !getBlackHoleActive()) {
              activateBlackHole();
            } else if (youScore === 20) {
              endGame(true); // YOU win
            }
          }
          continue;
        }

        // Check for right edge (THEM score - player missed)
        if (particle.x > width) {
          // Create green burst at contact point (they scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(width, contactY, '#00ff00');

          // Play YOU damage sound
          damage1Audio.currentTime = 0;
          damage1Audio.play().catch(err => console.log('Damage1 play failed:', err));

          // Flash player paddle
          flashPaddle(playerPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            themScore++;
            leftScoreEl.textContent = themScore.toString();

            // Check for THEM reaching 10
            if (themScore === 10 && !getBlackHoleActive()) {
              endGame(false); // YOU lose
            } else if (themScore === 20) {
              endGame(false); // YOU lose
            }
          }
          continue;
        }

        // Bounce off top and bottom
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height) {
          particle.y = height - particle.height;
          particle.vy = -particle.vy;
        }

        // Update trail (store last 15 positions)
        if (particle.active) {
          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 15) {
            // Remove oldest trail element if it exists
            const oldest = particle.trail.shift();
            if (oldest.el) {
              oldest.el.remove();
            }
          }

          // Create/update trail elements
          particle.trail.forEach((trailPos, idx) => {
            if (!trailPos.el) {
              // Create new trail element
              const trailEl = particle.el.cloneNode(true);
              trailEl.style.pointerEvents = 'none';
              document.body.appendChild(trailEl);
              trailPos.el = trailEl;
            }

            // Update trail element position and style
            const age = particle.trail.length - idx - 1; // 0 = newest, 14 = oldest
            const opacity = 1 - (age + 1) / 16; // Fade from 0.94 to 0.06
            const scale = 1 - (age + 1) * 0.05; // Scale from 0.95 to 0.25

            trailPos.el.style.opacity = opacity.toString();
            trailPos.el.style.transform = `translate(${trailPos.x - parseFloat(particle.el.style.left)}px, ${trailPos.y - parseFloat(particle.el.style.top)}px) scale(${scale})`;
            trailPos.el.style.zIndex = (10000 - age - 1).toString(); // Behind main letter
          });
        }

        // Apply transform to main particle
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      }

      requestAnimationFrame(animate);
    }

    // Helper function to activate black hole
    function activateBlackHole() {
      setBlackHoleActive(true);

      // Increase AI speed
      enemyPaddleSpeed = 700;

      // Create black hole element
      const width = window.innerWidth;
      const height = window.innerHeight;
      blackHoleEl = document.createElement('div');
      blackHoleEl.style.position = 'fixed';
      blackHoleEl.style.left = (width / 2) + 'px';
      blackHoleEl.style.top = (height / 2) + 'px';
      blackHoleEl.style.width = '50px';
      blackHoleEl.style.height = '50px';
      blackHoleEl.style.marginLeft = '-25px';
      blackHoleEl.style.marginTop = '-25px';
      blackHoleEl.style.borderRadius = '50%';
      blackHoleEl.style.backgroundColor = '#000000';
      blackHoleEl.style.boxShadow = '0 0 30px 10px rgba(0, 0, 0, 0.8)';
      blackHoleEl.style.zIndex = '9999';
      blackHoleEl.style.pointerEvents = 'none';
      document.body.appendChild(blackHoleEl);

      // Animate the pulsing
      let pulseTime = 0;
      function pulseBlackHole() {
        if (!getBlackHoleActive() || !blackHoleEl) return;
        pulseTime += 0.05;
        const size = 40 + 10 * Math.sin(pulseTime);
        blackHoleEl.style.width = size + 'px';
        blackHoleEl.style.height = size + 'px';
        blackHoleEl.style.marginLeft = (-size / 2) + 'px';
        blackHoleEl.style.marginTop = (-size / 2) + 'px';
        requestAnimationFrame(pulseBlackHole);
      }
      pulseBlackHole();

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '20%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s ease-out';

      const mainText = document.createElement('div');
      mainText.textContent = 'BLACK HOLE ACTIVATED';
      mainText.style.fontSize = '64px';

      const subText = document.createElement('div');
      subText.textContent = '(GAME TO 20)';
      subText.style.fontSize = '32px';
      subText.style.marginTop = '10px';

      flashMessage.appendChild(mainText);
      flashMessage.appendChild(subText);
      document.body.appendChild(flashMessage);

      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => flashMessage.remove(), 2000);
      }, 4000);
    }

    // Helper function to end the game
    function endGame(playerWon) {
      setGameOver(true);

      // Play victory or defeat sound
      if (playerWon) {
        victoryAudio.currentTime = 0;
        victoryAudio.play().catch(err => console.log('Victory play failed:', err));
      } else {
        defeatAudio.currentTime = 0;
        defeatAudio.play().catch(err => console.log('Defeat play failed:', err));
      }

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontSize = '96px';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.whiteSpace = 'nowrap';
      flashMessage.textContent = playerWon ? 'VICTORY' : 'DEFEATED';
      document.body.appendChild(flashMessage);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // BIRD MODE
  // ============================================================================

</script>

<script>
  // ============================================================================
  // BIRD MODE DEBUG SETTINGS
  // ============================================================================
  const DRAW_FORCES = false;  // Set to false to disable force visualization

  function enterBirdMode() {
    if (birdModeActive) return;
    birdModeActive = true;

    try {
      console.log('Starting bird mode...');

      // Disable clicks on mystery button (but keep it visible so it can become a bird)
      const mysteryIcon = document.querySelector('.fa-question-circle');
      if (mysteryIcon) {
        const mysteryLink = mysteryIcon.closest('a.nav-link');
        if (mysteryLink) {
          mysteryLink.style.pointerEvents = 'none';
        }
      }

      // Create flashy "BIRD MODE ACTIVATED" message FIRST (before laggy operations)
      const flashMessage = document.createElement('div');
      flashMessage.textContent = 'BIRD MODE ACTIVATED';
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontSize = '64px';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff6b9d';
      flashMessage.style.textShadow = '0 0 10px #ff6b9d, 0 0 20px #ff6b9d, 0 0 30px #ff6b9d, 0 0 40px #ff6b9d';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff6b9d';
      flashMessage.style.boxShadow = '0 0 20px #ff6b9d, inset 0 0 20px rgba(255, 107, 157, 0.2)';
      flashMessage.style.zIndex = '100000';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s';
      document.body.appendChild(flashMessage);

      // Show for 1 second, then fade out over 2 seconds
      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => {
          flashMessage.remove();
        }, 2000);
      }, 1000);

      // Wait 50ms to ensure banner renders before starting laggy operations
      setTimeout(() => {
        // Wrap text
        ensureTextWrapped();

        // Lock body
        const scrollY = window.scrollY;
        document.body.classList.add('bird-locked');
        document.body.style.top = `-${scrollY}px`;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        });

        const particles = [];
        const MAX_BIRD_COUNT = 1000;

        // Find header characters to make them hawks (h1, or h2, or h3 if no h1)
        let headerElement = document.querySelector('h1');
        if (!headerElement) {
          headerElement = document.querySelector('h2');
        }
        if (!headerElement) {
          headerElement = document.querySelector('h3');
        }
        let h1Chars = [];
        if (headerElement) {
          h1Chars = Array.from(headerElement.querySelectorAll('.char'));
        }

        // Collect all character and glyph elements with their data
        // Separate hawks (always keep) from non-hawks (randomly select)
        const hawkElements = [];
        const nonHawkElements = [];

        // Collect all characters
        const chars = document.querySelectorAll('.char');
        chars.forEach(char => {
          const rect = char.getBoundingClientRect();

          // Skip if outside viewport
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth) {
            return;
          }

          const hawkIndex = h1Chars.indexOf(char);
          const isHawk = hawkIndex !== -1;

          const elem = {
            original: char,
            rect: rect,
            isChar: true,
            isHawk: isHawk,
            hawkIndex: hawkIndex,
            randomOrder: Math.random()  // For shuffling
          };

          if (isHawk) {
            hawkElements.push(elem);
          } else {
            nonHawkElements.push(elem);
          }
        });

        // Also collect glyphs and icons (all non-hawks)
        const glyphs = document.querySelectorAll('i, svg');
        glyphs.forEach(glyph => {
          const rect = glyph.getBoundingClientRect();

          // Skip if outside viewport or has no size
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth ||
              rect.width === 0 || rect.height === 0) {
            return;
          }

          nonHawkElements.push({
            original: glyph,
            rect: rect,
            isChar: false,
            isHawk: false,
            hawkIndex: -1,
            randomOrder: Math.random()  // For shuffling
          });
        });

        // Randomly shuffle non-hawks
        nonHawkElements.sort((a, b) => a.randomOrder - b.randomOrder);

        // Select non-hawks up to MAX_BIRD_COUNT - number of hawks
        const maxNonHawks = MAX_BIRD_COUNT - hawkElements.length;
        const selectedNonHawks = nonHawkElements.slice(0, maxNonHawks);
        const fadedNonHawks = nonHawkElements.slice(maxNonHawks);

        // Combine: all hawks + selected non-hawks become birds
        const birdElements = [...hawkElements, ...selectedNonHawks];

        // Process bird elements (become birds)
        birdElements.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Add to particles array (all bird elements become birds)
          particles.push({
            el: clone,
            x: rect.left,
            y: rect.top,
            vx: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,  // Hawks get tiny random velocity
            vy: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,
            width: rect.width,
            height: rect.height,
            isHawk: elem.isHawk,
            hawkIndex: elem.hawkIndex,  // -1 for non-hawks, 0+ for hawks
            isActive: !elem.isHawk,  // Hawks start dormant, boids start active
            originalX: rect.left,  // Store original position for dormant hawks
            originalY: rect.top
          });
        });

        // Process faded elements (fade out smoothly)
        fadedNonHawks.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Fade out this element smoothly
          clone.style.transition = 'opacity 3s ease-out';
          setTimeout(() => {
            clone.style.opacity = '0';
            setTimeout(() => {
              clone.remove();
            }, 3000);
          }, 10);
        });

        // Start animation
        // Create trajectory ray for hawk
        const trajectoryRay = document.createElement('div');
        trajectoryRay.id = 'hawk-trajectory-ray';
        trajectoryRay.style.position = 'fixed';
        trajectoryRay.style.height = '2px';
        trajectoryRay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        trajectoryRay.style.transformOrigin = '0 0';
        trajectoryRay.style.pointerEvents = 'none';
        trajectoryRay.style.zIndex = '9998';
        trajectoryRay.style.display = 'none';
        document.body.appendChild(trajectoryRay);

        // Create perpendicular lines container (SVG for efficient line drawing)
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'fear-lines-svg';
        svg.style.position = 'fixed';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '9997';
        document.body.appendChild(svg);

        // Create force vectors SVG overlay (for debug visualization)
        const forceVectorsSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        forceVectorsSvg.id = 'force-vectors-svg';
        forceVectorsSvg.style.position = 'fixed';
        forceVectorsSvg.style.top = '0';
        forceVectorsSvg.style.left = '0';
        forceVectorsSvg.style.width = '100%';
        forceVectorsSvg.style.height = '100%';
        forceVectorsSvg.style.pointerEvents = 'none';
        forceVectorsSvg.style.zIndex = '9999';
        forceVectorsSvg.style.display = DRAW_FORCES ? 'block' : 'none';
        document.body.appendChild(forceVectorsSvg);

        // Create force legend (for debug visualization)
        if (DRAW_FORCES) {
          const legend = document.createElement('div');
          legend.id = 'force-legend';
          legend.style.position = 'fixed';
          legend.style.top = '10px';
          legend.style.right = '10px';
          legend.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          legend.style.color = 'white';
          legend.style.padding = '10px';
          legend.style.fontFamily = 'monospace';
          legend.style.fontSize = '12px';
          legend.style.zIndex = '100001';
          legend.style.borderRadius = '5px';
          legend.style.lineHeight = '1.5';
          legend.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">FORCE LEGEND</div>
            <div><span style="color: #ff0000;">■</span> Repulsion (boid-boid)</div>
            <div><span style="color: #0000ff;">■</span> Cohesion</div>
            <div><span style="color: #00ff00;">■</span> Alignment</div>
            <div><span style="color: #00ffff;">■</span> Speed Stabilization</div>
            <div><span style="color: #ff8800;">■</span> Wall Repulsion</div>
            <div><span style="color: #ff00ff;">■</span> Fear</div>
            <div><span style="color: #ffff00;">■</span> Boid Attraction (hawks)</div>
            <div><span style="color: #ff69b4;">■</span> Hawk-Hawk Repulsion</div>
          `;
          document.body.appendChild(legend);
        }

        console.log('Starting animation with', particles.length, 'particles');
        startBirdAnimation(particles, trajectoryRay, svg, forceVectorsSvg);
      }, 50);  // End of 50ms setTimeout
    } catch (error) {
      console.error('Error in enterBirdMode:', error);
      birdModeActive = false;
      alert('Error starting bird mode: ' + error.message);
    }
  }

  function startBirdAnimation(particles, trajectoryRay, fearLinesSvg, forceVectorsSvg) {
    let lastTime = performance.now();
    let hawkInfos = [];  // Store all active hawks' positions and velocities for fear calculations

    const FORCE_MULTIPLIER = 25;  // Global force multiplication factor
    const MAX_SPEED = 400;   // Maximum speed
    const F_MAX = 10;  // Maximum force magnitude before clamping
    const FORCE_ARROW_SCALE = 20;  // Scale factor for visualizing force arrows

    // Repulsion parameters
    const LENGTH_SCALE = 20;  // px
    const R_REPULSION = 1 * LENGTH_SCALE;  // 20px
    const F_REPULSION = 5;  // Repulsion strength

    // Speed stabilization parameters
    const TARGET_SPEED = 15;  // px/s
    const TARGET_SPEED_HAWK = 50;  // px/s
    const F_SPEEDSTABILITY = 5;
    const F_SPEEDSTABILITY_HAWK = 2;

    // Alignment parameters
    const F_ALIGN = 2;

    // Wall repulsion parameters
    const WALL_REPULSION_DIST = 5 * LENGTH_SCALE;  // 100px
    const F_WALL_REPULSION = 4;

    // Hawk-specific wall repulsion (2x distance and magnitude)
    const WALL_REPULSION_DIST_HAWK = 1 * WALL_REPULSION_DIST;  // 200px
    const F_WALL_REPULSION_HAWK = .5 * F_WALL_REPULSION;  // 8

    // Hawk attraction parameters
    const F_ATTR_HAWK = 0.3;

    // Fear parameters
    const F_FEAR = 3;
    const FEAR_DIST = 15 * LENGTH_SCALE;  // 300px

    // Spatial grid parameters
    const CELL_SIZE = 2 * LENGTH_SCALE;  // 60px

    // Hawk release tracking
    let nextHawkIndex = 0;
    let nextHawkReleaseTime = 20.0;  // First hawk at 20 seconds (wall time)
    let elapsedTime = 0;  // Wall time in seconds

    function releaseHawk(hawk) {
      hawk.isActive = true;
      hawk.releaseTime = elapsedTime;  // Track when hawk was released

      // Play hawk call at 30% volume
      const hawkAudio = document.getElementById('hawk-call');
      if (hawkAudio) {
        hawkAudio.volume = 0.3;
        hawkAudio.currentTime = 0;
        hawkAudio.play().catch(e => console.log('Audio play failed:', e));
      }

      // Create big brown burst
      const burstX = hawk.x + hawk.width / 2;
      const burstY = hawk.y + hawk.height / 2;
      const burst = document.createElement('div');

      burst.style.position = 'fixed';
      burst.style.left = burstX + 'px';
      burst.style.top = burstY + 'px';
      burst.style.width = '0px';
      burst.style.height = '0px';
      burst.style.borderRadius = '50%';
      burst.style.backgroundColor = 'rgba(139, 69, 19, 0.6)';  // Brown color
      burst.style.transform = 'translate(-50%, -50%)';
      burst.style.pointerEvents = 'none';
      burst.style.zIndex = '9999';
      document.body.appendChild(burst);

      // Animate burst (much bigger)
      setTimeout(() => {
        burst.style.transition = 'all 0.6s ease-out';
        burst.style.width = '200px';
        burst.style.height = '200px';
        burst.style.backgroundColor = 'rgba(139, 69, 19, 0)';
      }, 10);

      setTimeout(() => burst.remove(), 650);
    }

    // Helper function to draw a force arrow in SVG
    function createArrow(x, y, fx, fy, color) {
      const length = Math.sqrt(fx * fx + fy * fy);
      if (length < 0.01) return null;  // Skip tiny forces

      const endX = x + fx * FORCE_ARROW_SCALE;
      const endY = y + fy * FORCE_ARROW_SCALE;

      // Create line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x);
      line.setAttribute('y1', y);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('opacity', '0.7');

      // Create arrowhead
      const arrowSize = 5;
      const angle = Math.atan2(fy, fx);
      const arrowX1 = endX - arrowSize * Math.cos(angle - Math.PI / 6);
      const arrowY1 = endY - arrowSize * Math.sin(angle - Math.PI / 6);
      const arrowX2 = endX - arrowSize * Math.cos(angle + Math.PI / 6);
      const arrowY2 = endY - arrowSize * Math.sin(angle + Math.PI / 6);

      const arrowhead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      arrowhead.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
      arrowhead.setAttribute('fill', color);
      arrowhead.setAttribute('opacity', '0.7');

      return { line, arrowhead };
    }

    function animate(currentTime) {
      if (!birdModeActive) return;

      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      // Update elapsed time (wall time in real seconds)
      elapsedTime += dt;

      // Simulation runs at 4x speed
      const simulationDt = dt * 4;

      // Clear hawk infos from previous frame
      hawkInfos = [];

      // Check if it's time to release the next hawk
      if (elapsedTime >= nextHawkReleaseTime) {
        // Find the hawk with hawkIndex === nextHawkIndex
        const hawkToRelease = particles.find(p => p.hawkIndex === nextHawkIndex);
        if (hawkToRelease && !hawkToRelease.isActive) {
          releaseHawk(hawkToRelease);
          nextHawkIndex++;
          // First hawk at 20s, then every 60s thereafter
          nextHawkReleaseTime += 60.0;
        }
      }

      // Build spatial grid (only for active, non-hawk particles)
      const grid = new Map();
      particles.forEach((particle, i) => {
        if (!particle.isActive || particle.isHawk) return;

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);
        const key = `${cellX},${cellY}`;

        if (!grid.has(key)) {
          grid.set(key, []);
        }
        grid.get(key).push(i);
      });

      // Check for hawk overlaps and hide captured particles
      particles.forEach((hawk, i) => {
        if (!hawk.isHawk || !hawk.isActive) return;

        // Hawks can't capture during their 2-second frozen period
        const timeSinceRelease = elapsedTime - (hawk.releaseTime || 0);
        if (timeSinceRelease < 2.0) return;

        particles.forEach((boid, j) => {
          if (i === j || !boid.isActive || boid.isHawk) return;

          // Check bounding box overlap
          if (hawk.x < boid.x + boid.width &&
              hawk.x + hawk.width > boid.x &&
              hawk.y < boid.y + boid.height &&
              hawk.y + hawk.height > boid.y) {
            // Overlap! Hide boid and create burst
            boid.isActive = false;
            boid.el.remove();

            // Play goose sound (75% honk, 25% yell)
            const soundId = Math.random() < 0.75 ? 'goose-honk' : 'goose-yell';
            const audio = document.getElementById(soundId);
            if (audio) {
              audio.currentTime = 0;
              audio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Create colorful burst
            const burstX = boid.x + boid.width / 2;
            const burstY = boid.y + boid.height / 2;
            const burst = document.createElement('div');

            // Random hue, high saturation, high lightness
            const hue = Math.floor(Math.random() * 360);
            const saturation = 70 + Math.floor(Math.random() * 20); // 70-90%
            const lightness = 60; // Medium-bright

            burst.style.position = 'fixed';
            burst.style.left = burstX + 'px';
            burst.style.top = burstY + 'px';
            burst.style.width = '0px';
            burst.style.height = '0px';
            burst.style.borderRadius = '50%';
            burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.6)`;
            burst.style.transform = 'translate(-50%, -50%)';
            burst.style.pointerEvents = 'none';
            burst.style.zIndex = '9999';
            document.body.appendChild(burst);

            // Animate burst
            setTimeout(() => {
              burst.style.transition = 'all 0.4s ease-out';
              burst.style.width = '60px';
              burst.style.height = '60px';
              burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`;
            }, 10);

            setTimeout(() => burst.remove(), 450);
          }
        });
      });

      // Apply forces to each particle
      particles.forEach((particle, i) => {
        if (!particle.isActive) return;  // Skip inactive particles

        // Initialize force tracking for debug visualization
        particle.forces = {
          speedStab: { x: 0, y: 0 },
          boidAttr: { x: 0, y: 0 },
          hawkRepulsion: { x: 0, y: 0 },
          wallRepulsion: { x: 0, y: 0 },
          repulsion: { x: 0, y: 0 },
          cohesion: { x: 0, y: 0 },
          alignment: { x: 0, y: 0 },
          fear: { x: 0, y: 0 }
        };

        // Hawks have their own forces
        if (particle.isHawk) {
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Keep hawk stationary for 2 seconds after release (for suspense)
          const timeSinceRelease = elapsedTime - (particle.releaseTime || 0);
          if (timeSinceRelease < 2.0) {
            // Hawk is frozen - keep it in place
            particle.vx = 0;
            particle.vy = 0;
            particle.x = particle.originalX;
            particle.y = particle.originalY;
            particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

            // Still store hawk info for fear calculations
            hawkInfos.push({
              x: centerX,
              y: centerY,
              vx: 0,
              vy: 0,
              speed: 0
            });
            return;  // Skip rest of hawk physics
          }

          let hawkForceX = 0;
          let hawkForceY = 0;

          // Speed stabilization force (weaker than boids, higher target speed)
          const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
          if (currentSpeed > 0) {
            const speedRatio = 1 - currentSpeed / TARGET_SPEED_HAWK;
            const speedForceMag = F_SPEEDSTABILITY_HAWK * Math.pow(speedRatio, 3);
            particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
            particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
            hawkForceX += particle.forces.speedStab.x;
            hawkForceY += particle.forces.speedStab.y;
          }

          // Attraction to nearest boid
          let nearestBoid = null;
          let nearestDist = Infinity;
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestBoid = { x: otherCenterX, y: otherCenterY, dist: dist };
            }
          });

          if (nearestBoid && nearestBoid.dist > 0) {
            const dx = nearestBoid.x - centerX;
            const dy = nearestBoid.y - centerY;
            particle.forces.boidAttr.x = (dx / nearestBoid.dist) * F_ATTR_HAWK;
            particle.forces.boidAttr.y = (dy / nearestBoid.dist) * F_ATTR_HAWK;
            hawkForceX += particle.forces.boidAttr.x;
            hawkForceY += particle.forces.boidAttr.y;
          }

          // Repulsion from nearest k hawks
          const K_HAWKS = 3;
          const HAWK_REPULSION_DIST = 50;  // px
          const F_HAWK_REPULSION = 0.5;  // Mild repulsion strength

          // Find all other active hawks
          const otherHawks = [];
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || !other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < HAWK_REPULSION_DIST) {
              otherHawks.push({ x: otherCenterX, y: otherCenterY, dist: dist });
            }
          });

          if (otherHawks.length > 0) {
            // Sort by distance and take k nearest
            otherHawks.sort((a, b) => a.dist - b.dist);
            const nearestKHawks = otherHawks.slice(0, K_HAWKS);

            // Calculate average position
            let avgHawkX = 0, avgHawkY = 0;
            nearestKHawks.forEach(h => {
              avgHawkX += h.x;
              avgHawkY += h.y;
            });
            avgHawkX /= nearestKHawks.length;
            avgHawkY /= nearestKHawks.length;

            // Calculate average distance
            let avgDist = 0;
            nearestKHawks.forEach(h => avgDist += h.dist);
            avgDist /= nearestKHawks.length;

            // Apply repulsive force (drops off linearly)
            if (avgDist > 0) {
              const repulsionStrength = F_HAWK_REPULSION * (1 - avgDist / HAWK_REPULSION_DIST);
              const dx = centerX - avgHawkX;
              const dy = centerY - avgHawkY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                particle.forces.hawkRepulsion.x = (dx / dist) * repulsionStrength;
                particle.forces.hawkRepulsion.y = (dy / dist) * repulsionStrength;
                hawkForceX += particle.forces.hawkRepulsion.x;
                hawkForceY += particle.forces.hawkRepulsion.y;
              }
            }
          }

          // Wall repulsion forces (stronger and longer range for hawks)
          const width = window.innerWidth;
          const height = window.innerHeight;

          let wallForceX = 0;
          let wallForceY = 0;

          // Left wall
          const distLeft = centerX;
          if (distLeft < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distLeft / WALL_REPULSION_DIST_HAWK);
            wallForceX += wallForceMag;  // Push right
          }

          // Right wall
          const distRight = width - centerX;
          if (distRight < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distRight / WALL_REPULSION_DIST_HAWK);
            wallForceX -= wallForceMag;  // Push left
          }

          // Top wall
          const distTop = centerY;
          if (distTop < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distTop / WALL_REPULSION_DIST_HAWK);
            wallForceY += wallForceMag;  // Push down
          }

          // Bottom wall
          const distBottom = height - centerY;
          if (distBottom < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distBottom / WALL_REPULSION_DIST_HAWK);
            wallForceY -= wallForceMag;  // Push up
          }

          particle.forces.wallRepulsion.x = wallForceX;
          particle.forces.wallRepulsion.y = wallForceY;
          hawkForceX += wallForceX;
          hawkForceY += wallForceY;

          // Clamp force to F_MAX
          const hawkForceMag = Math.sqrt(hawkForceX * hawkForceX + hawkForceY * hawkForceY);
          if (hawkForceMag > F_MAX) {
            hawkForceX = (hawkForceX / hawkForceMag) * F_MAX;
            hawkForceY = (hawkForceY / hawkForceMag) * F_MAX;
          }

          // Apply forces
          particle.vx += hawkForceX * FORCE_MULTIPLIER * simulationDt;
          particle.vy += hawkForceY * FORCE_MULTIPLIER * simulationDt;

          // Update position
          particle.x += particle.vx * simulationDt;
          particle.y += particle.vy * simulationDt;

          // Bounce off walls (width and height already declared above)
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx;
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx;
          }

          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy;
          } else if (particle.y + particle.height > height) {
            particle.y = height - particle.height;
            particle.vy = -particle.vy;
          }

          // Update visual position
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

          // Store hawk info for fear calculations
          hawkInfos.push({
            x: centerX,
            y: centerY,
            vx: particle.vx,
            vy: particle.vy,
            speed: currentSpeed
          });

          return;  // Skip boid forces
        }

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;

        // Accumulate total force
        let totalForceX = 0;
        let totalForceY = 0;

        // Fear force from all hawks
        let isFearful = false;
        hawkInfos.forEach(hawkInfo => {
          if (hawkInfo.speed > 0) {
            const toHawkX = hawkInfo.x - centerX;
            const toHawkY = hawkInfo.y - centerY;
            const distToHawk = Math.sqrt(toHawkX * toHawkX + toHawkY * toHawkY);

            // Check if boid is in front of hawk (dot product > 0)
            const toBoidX = centerX - hawkInfo.x;
            const toBoidY = centerY - hawkInfo.y;
            const dotProduct = toBoidX * hawkInfo.vx + toBoidY * hawkInfo.vy;

            if (distToHawk < FEAR_DIST && dotProduct > 0) {
              // Boid feels fear!
              isFearful = true;

              // Calculate perpendicular direction away from ray
              const dirX = hawkInfo.vx / hawkInfo.speed;
              const dirY = hawkInfo.vy / hawkInfo.speed;

              // Project boid position onto ray
              const projection = toBoidX * dirX + toBoidY * dirY;
              const rayPointX = hawkInfo.x + projection * dirX;
              const rayPointY = hawkInfo.y + projection * dirY;

              // Direction from ray to boid (perpendicular escape direction)
              const perpX = centerX - rayPointX;
              const perpY = centerY - rayPointY;
              const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

              if (perpDist > 0) {
                const fearMagnitude = F_FEAR * (1 - distToHawk / FEAR_DIST);

                // Blend perpendicular direction with "away from hawk" for 70 degree angle
                const perpNormX = perpX / perpDist;
                const perpNormY = perpY / perpDist;
                const awayNormX = -dirX;  // Opposite of hawk direction
                const awayNormY = -dirY;

                // sin(70°) ≈ 0.94, cos(70°) ≈ 0.34
                const fearDirX = 0.94 * perpNormX + 0.34 * awayNormX;
                const fearDirY = 0.94 * perpNormY + 0.34 * awayNormY;

                // Normalize the blended direction
                const fearDirMag = Math.sqrt(fearDirX * fearDirX + fearDirY * fearDirY);
                if (fearDirMag > 0) {
                  particle.forces.fear.x += (fearDirX / fearDirMag) * fearMagnitude;
                  particle.forces.fear.y += (fearDirY / fearDirMag) * fearMagnitude;
                  totalForceX += (fearDirX / fearDirMag) * fearMagnitude;
                  totalForceY += (fearDirY / fearDirMag) * fearMagnitude;
                }
              }
            }
          }
        });

        // Get particle's grid cell
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);

        // Find distances to particles in nearby cells (3x3 neighborhood)
        const distances = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${cellX + dx},${cellY + dy}`;
            const cellParticles = grid.get(key);
            if (!cellParticles) continue;

            cellParticles.forEach(j => {
              if (i === j) return;

              const other = particles[j];
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              const deltaX = otherCenterX - centerX;
              const deltaY = otherCenterY - centerY;
              const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

              distances.push({
                index: j,
                dist: dist,
                dx: deltaX,
                dy: deltaY,
                x: otherCenterX,
                y: otherCenterY
              });

              // Repulsion force (only for close neighbors) - 1/r form with offset
              if (dist <= R_REPULSION && dist > 0) {
                const normalizedDist = dist / LENGTH_SCALE;
                const repulsionMag = F_REPULSION * (1 - normalizedDist);
                particle.forces.repulsion.x -= (deltaX / dist) * repulsionMag;  // Negative = repulsion
                particle.forces.repulsion.y -= (deltaY / dist) * repulsionMag;
                totalForceX -= (deltaX / dist) * repulsionMag;
                totalForceY -= (deltaY / dist) * repulsionMag;
              }
            });
          }
        }

        // Sort by distance and take 5 nearest
        distances.sort((a, b) => a.dist - b.dist);
        const nearest5 = distances.slice(0, 5);

        // Calculate average position of 5 nearest neighbors
        let avgX = 0, avgY = 0;
        nearest5.forEach(n => {
          avgX += n.x;
          avgY += n.y;
        });
        avgX /= nearest5.length;
        avgY /= nearest5.length;

        // Cohesion force: magnitude 1 towards average position
        const dx = avgX - centerX;
        const dy = avgY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          particle.forces.cohesion.x = (dx / dist) * 1.0;
          particle.forces.cohesion.y = (dy / dist) * 1.0;
          totalForceX += particle.forces.cohesion.x;
          totalForceY += particle.forces.cohesion.y;
        }

        // Alignment force: magnitude F_ALIGN in direction of average velocity
        let avgVx = 0, avgVy = 0;
        nearest5.forEach(n => {
          const neighbor = particles[n.index];
          avgVx += neighbor.vx;
          avgVy += neighbor.vy;
        });
        avgVx /= nearest5.length;
        avgVy /= nearest5.length;

        const avgVelMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
        if (avgVelMag > 0) {
          particle.forces.alignment.x = (avgVx / avgVelMag) * F_ALIGN;
          particle.forces.alignment.y = (avgVy / avgVelMag) * F_ALIGN;
          totalForceX += particle.forces.alignment.x;
          totalForceY += particle.forces.alignment.y;
        }

        // Speed stabilization force
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (currentSpeed > 0) {
          const speedRatio = 1 - currentSpeed / TARGET_SPEED;
          const speedForceMag = F_SPEEDSTABILITY * Math.pow(speedRatio, 3);
          particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
          particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
          totalForceX += particle.forces.speedStab.x;
          totalForceY += particle.forces.speedStab.y;
        }

        // Wall repulsion forces
        const width = window.innerWidth;
        const height = window.innerHeight;

        let wallForceX = 0;
        let wallForceY = 0;

        // Left wall
        const distLeft = centerX;
        if (distLeft < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distLeft / WALL_REPULSION_DIST);
          wallForceX += wallForceMag;  // Push right
        }

        // Right wall
        const distRight = width - centerX;
        if (distRight < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distRight / WALL_REPULSION_DIST);
          wallForceX -= wallForceMag;  // Push left
        }

        // Top wall
        const distTop = centerY;
        if (distTop < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distTop / WALL_REPULSION_DIST);
          wallForceY += wallForceMag;  // Push down
        }

        // Bottom wall
        const distBottom = height - centerY;
        if (distBottom < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distBottom / WALL_REPULSION_DIST);
          wallForceY -= wallForceMag;  // Push up
        }

        particle.forces.wallRepulsion.x = wallForceX;
        particle.forces.wallRepulsion.y = wallForceY;
        totalForceX += wallForceX;
        totalForceY += wallForceY;

        // Clamp force to F_MAX
        const totalForceMag = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
        if (totalForceMag > F_MAX) {
          totalForceX = (totalForceX / totalForceMag) * F_MAX;
          totalForceY = (totalForceY / totalForceMag) * F_MAX;
        }

        // Apply total force with global multiplier
        particle.vx += totalForceX * FORCE_MULTIPLIER * simulationDt;
        particle.vy += totalForceY * FORCE_MULTIPLIER * simulationDt;

        // Limit speed
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed > MAX_SPEED) {
          particle.vx = (particle.vx / speed) * MAX_SPEED;
          particle.vy = (particle.vy / speed) * MAX_SPEED;
        }

        // Update position
        particle.x += particle.vx * simulationDt;
        particle.y += particle.vy * simulationDt;

        // Bounce off edges with perfect reflection (no energy loss)
        // (width and height already declared above for wall repulsion)

        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx;
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx;
        }

        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height + 7) {
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy;
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Keep dormant hawks at their original position
      particles.forEach(particle => {
        if (particle.isHawk && !particle.isActive) {
          particle.x = particle.originalX;
          particle.y = particle.originalY;
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      });

      // Draw force vectors for debug visualization
      if (DRAW_FORCES) {
        // Clear previous arrows
        while (forceVectorsSvg.firstChild) {
          forceVectorsSvg.removeChild(forceVectorsSvg.firstChild);
        }

        // Draw force vectors for each active particle
        particles.forEach(particle => {
          if (!particle.isActive || !particle.forces) return;

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Define force colors
          const forceColors = {
            repulsion: '#ff0000',       // Red (boid-boid repulsion)
            cohesion: '#0000ff',        // Blue
            alignment: '#00ff00',       // Green
            speedStab: '#00ffff',       // Cyan
            wallRepulsion: '#ff8800',   // Orange
            fear: '#ff00ff',            // Magenta
            boidAttr: '#ffff00',        // Yellow (hawk attraction to boids)
            hawkRepulsion: '#ff69b4'    // Pink (hawk-hawk repulsion)
          };

          // Draw each force type
          Object.entries(particle.forces).forEach(([forceType, force]) => {
            if (!forceColors[forceType]) return;

            const arrow = createArrow(centerX, centerY, force.x, force.y, forceColors[forceType]);
            if (arrow) {
              forceVectorsSvg.appendChild(arrow.line);
              forceVectorsSvg.appendChild(arrow.arrowhead);
            }
          });
        });
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // INITIALIZATION
  // ============================================================================
</script>

<script>
  // ============================================================================
  // PANIC MODE
  // ============================================================================

  let panicTextWrapped = false;
  let alarmAudio = null;
  let screamAudio = null;

  function enterPanicMode() {
    if (panicActive) return;
    panicActive = true;

    // Wrap text if not already wrapped by other modes
    if (!textWrapped && !panicTextWrapped) {
      panicTextWrapped = true;
      wrapTextNodes(document.body);
    }

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('panic-locked');
    document.body.style.top = `-${scrollY}px`;

    // Start alarm sound immediately
    const alarm = document.getElementById('panic-alarm');
    if (alarm) {
      alarmAudio = alarm;
      alarmAudio.loop = true;
      alarmAudio.currentTime = 0;
      alarmAudio.play();
    }

    // Start crowd scream after 2 seconds (when movement begins)
    setTimeout(() => {
      if (panicActive) {
        const scream = document.getElementById('panic-scream');
        if (scream) {
          screamAudio = scream;
          screamAudio.loop = true;
          screamAudio.currentTime = 0;
          screamAudio.play();
        }
      }
    }, 2000);

    // Create persistent flashing "PANIC MODE" text
    const panicLabel = document.createElement('div');
    panicLabel.id = 'panic-mode-label';
    panicLabel.textContent = 'PANIC MODE';
    panicLabel.style.position = 'fixed';
    panicLabel.style.top = '50%';
    panicLabel.style.left = '50%';
    panicLabel.style.transform = 'translate(-50%, -50%)';
    panicLabel.style.fontSize = '48px';
    panicLabel.style.fontFamily = 'Courier New, monospace';
    panicLabel.style.fontWeight = 'bold';
    panicLabel.style.letterSpacing = '4px';
    panicLabel.style.color = '#ff0000';
    panicLabel.style.textShadow = '0 0 10px #ff0000, 0 0 20px #ff0000';
    panicLabel.style.zIndex = '99999';
    panicLabel.style.pointerEvents = 'none';
    panicLabel.style.textAlign = 'center';
    document.body.appendChild(panicLabel);

    // Flash on/off every 0.51 seconds
    const flashInterval = setInterval(() => {
      if (!panicActive) {
        clearInterval(flashInterval);
        panicLabel.remove();
        return;
      }
      panicLabel.style.visibility = panicLabel.style.visibility === 'hidden' ? 'visible' : 'hidden';
    }, 510);

    const particles = [];

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startPanicAnimation(particles, scrollY);
  }

  function startPanicAnimation(particles, originalScrollY) {
    const DELAY_TIME = 2000; // 2 seconds delay before movement
    const MOVEMENT_TIME = 7800; // 7.8 seconds of movement
    const TOTAL_TIME = DELAY_TIME + MOVEMENT_TIME; // 9.8 seconds total
    const startTime = performance.now();

    function animate(currentTime) {
      if (!panicActive) return;

      // Calculate elapsed time in milliseconds
      const elapsed = currentTime - startTime;

      // Check if 9.8 seconds have elapsed
      if (elapsed >= TOTAL_TIME) {
        exitPanicMode(particles, originalScrollY);
        return;
      }

      // Calculate t as fraction of movement time (0 to 1)
      // During the first 2 seconds (delay), t = 0 (no movement)
      let t = 0;
      if (elapsed > DELAY_TIME) {
        t = (elapsed - DELAY_TIME) / MOVEMENT_TIME;
      }

      particles.forEach(particle => {
        // Epicycle parameterization: sum of circles at different frequencies
        // x(t) = sum_j r_j * cos(2π * j * t + theta_j) - offset_x
        // y(t) = sum_j r_j * sin(2π * j * t + theta_j) - offset_y
        let dx = 0;
        let dy = 0;

        for (let j = 0; j < particle.radii.length; j++) {
          const freq = j + 1; // Frequency is 1, 2, 3, ...
          const angle = 2 * Math.PI * freq * t * particle.signs[j] + particle.thetas[j];
          dx += particle.radii[j] * Math.cos(angle);
          dy += particle.radii[j] * Math.sin(angle);
        }

        // Subtract offsets to ensure path starts at origin
        dx -= particle.offset_x;
        dy -= particle.offset_y;

        // Apply radial coefficient to make letters drift farther over time
        // radial_coeff = max(1, elapsed_in_seconds + 2 - TOTAL_TIME_in_seconds)
        const elapsed_seconds = elapsed / 1000;
        const total_seconds = TOTAL_TIME / 1000;
        const radial_coeff = Math.max(1, elapsed_seconds + 2 - total_seconds);
        dx *= radial_coeff;
        dy *= radial_coeff;

        // Calculate current position (original position + offset)
        const x = particle.x0 + dx;
        const y = particle.y0 + dy;

        // Apply transform (relative to the element's original left/top)
        particle.el.style.transform = `translate(${x - parseFloat(particle.el.style.left)}px, ${y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  function exitPanicMode(particles, originalScrollY) {
    panicActive = false;

    // Stop and clean up audio
    if (alarmAudio) {
      alarmAudio.pause();
      alarmAudio.currentTime = 0;
      alarmAudio = null;
    }
    if (screamAudio) {
      screamAudio.pause();
      screamAudio.currentTime = 0;
      screamAudio = null;
    }

    // Remove all particles
    particles.forEach(particle => {
      particle.el.remove();
    });

    // Remove flashing label
    const panicLabel = document.getElementById('panic-mode-label');
    if (panicLabel) {
      panicLabel.remove();
    }

    // Restore original characters
    document.querySelectorAll('.char').forEach(char => {
      char.style.visibility = '';
    });

    // Restore original glyphs
    document.querySelectorAll('i, svg').forEach(glyph => {
      glyph.style.visibility = '';
    });

    // Unlock body
    document.body.classList.remove('panic-locked');
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.left = '';
    document.body.style.right = '';
    document.body.style.overflow = '';
    document.body.style.width = '';
    window.scrollTo(0, originalScrollY);
  }
</script>

<script>
  // ============================================================================
  // NAVIGATION AND MYSTERY BUTTON LOGIC
  // ============================================================================

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    // Add mysterious glyphs to navbar
    const navList = document.querySelector('nav ul.navbar-nav');
    if (navList) {
      // Single question mark icon that randomly picks a mode
      const mysteryLi = document.createElement('li');
      mysteryLi.className = 'nav-item active';

      const mysteryLink = document.createElement('a');
      mysteryLink.className = 'nav-link';
      mysteryLink.style.cursor = 'pointer';
      mysteryLink.href = '#';

      const mysteryIcon = document.createElement('i');
      mysteryIcon.className = 'fas fa-question-circle';

      mysteryLink.appendChild(mysteryIcon);
      mysteryLi.appendChild(mysteryLink);

      mysteryLink.addEventListener('click', (e) => {
        e.preventDefault();

        // Check localStorage for click count
        let clickCount = parseInt(localStorage.getItem('mysteryButtonClicks') || '0');

        // If user hasn't clicked 3 times yet, show warning and increment
        if (clickCount < 3) {
          const messages = ["Hey, stop that!", "Can't you read?", "I'm serious!"];
          alert(messages[clickCount]);
          clickCount++;
          localStorage.setItem('mysteryButtonClicks', clickCount.toString());
          return; // Don't activate mode
        }

        // After 3 clicks, cycle through modes sequentially
        // Define the rotation order
        const modeSequence = ['shatter', 'gravity', 'bird', 'splash', 'vacuum', 'panic', 'pong'];

        // Get current mode index with error handling
        let modeIndex = 0;
        try {
          const storedIndex = localStorage.getItem('mysteryModeIndex');
          if (storedIndex !== null) {
            const parsed = parseInt(storedIndex);
            // Validate the index is within bounds
            if (!isNaN(parsed) && parsed >= 0 && parsed < modeSequence.length) {
              modeIndex = parsed;
            } else {
              // Invalid index, reset to 0
              console.warn('Invalid mysteryModeIndex, resetting to 0');
              modeIndex = 0;
            }
          }
        } catch (e) {
          console.error('Error reading mysteryModeIndex:', e);
          modeIndex = 0;
        }

        // Get the current mode
        const currentMode = modeSequence[modeIndex];

        // Increment and save the next index (with wraparound)
        const nextIndex = (modeIndex + 1) % modeSequence.length;
        try {
          localStorage.setItem('mysteryModeIndex', nextIndex.toString());
        } catch (e) {
          console.error('Error saving mysteryModeIndex:', e);
        }

        // Reset button appearance (remove hover state)
        mysteryLink.blur();
        mysteryLink.style.setProperty('background-color', '', 'important');
        mysteryLink.style.setProperty('color', '', 'important');
        mysteryIcon.style.setProperty('color', 'black', 'important');

        // Activate the selected mode with error handling
        try {
          switch(currentMode) {
            case 'shatter':
              if (typeof enterShatterMode === 'function') {
                enterShatterMode();
              } else {
                console.error('enterShatterMode is not defined');
              }
              break;
            case 'gravity':
              if (typeof enterGravityMode === 'function') {
                enterGravityMode();
              } else {
                console.error('enterGravityMode is not defined');
              }
              break;
            case 'bird':
              if (typeof enterBirdMode === 'function') {
                enterBirdMode();
              } else {
                console.error('enterBirdMode is not defined');
              }
              break;
            case 'splash':
              window.location.href = '/splash/';
              break;
            case 'vacuum':
              if (typeof enterVacuumMode === 'function') {
                enterVacuumMode();
              } else {
                console.error('enterVacuumMode is not defined');
              }
              break;
            case 'panic':
              if (typeof enterPanicMode === 'function') {
                enterPanicMode();
              } else {
                console.error('enterPanicMode is not defined');
              }
              break;
            case 'pong':
              if (typeof enterPongMode === 'function') {
                enterPongMode();
              } else {
                console.error('enterPongMode is not defined');
              }
              break;
            default:
              console.error('Unknown mode:', currentMode);
          }
        } catch (e) {
          console.error('Error activating mode:', currentMode, e);
        }
      });

      navList.appendChild(mysteryLi);

      /* DEBUG VERSION: Uncomment to show all five icons for debugging
      // Shatter mode icon (question mark)
      const shatterLi = document.createElement('li');
      shatterLi.className = 'nav-item active';

      const shatterLink = document.createElement('a');
      shatterLink.className = 'nav-link';
      shatterLink.style.cursor = 'pointer';
      shatterLink.href = '#';

      const shatterIcon = document.createElement('i');
      shatterIcon.className = 'fas fa-question-circle';

      shatterLink.appendChild(shatterIcon);
      shatterLi.appendChild(shatterLink);

      shatterLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterShatterMode();
      });

      navList.appendChild(shatterLi);

      // Gravity mode icon (magnet)
      const gravityLi = document.createElement('li');
      gravityLi.className = 'nav-item active';

      const gravityLink = document.createElement('a');
      gravityLink.className = 'nav-link';
      gravityLink.style.cursor = 'pointer';
      gravityLink.href = '#';

      const gravityIcon = document.createElement('i');
      gravityIcon.className = 'fas fa-magnet';

      gravityLink.appendChild(gravityIcon);
      gravityLi.appendChild(gravityLink);

      gravityLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterGravityMode();
      });

      navList.appendChild(gravityLi);

      // Vacuum mode icon (meteor)
      const vacuumLi = document.createElement('li');
      vacuumLi.className = 'nav-item active';

      const vacuumLink = document.createElement('a');
      vacuumLink.className = 'nav-link';
      vacuumLink.style.cursor = 'pointer';
      vacuumLink.href = '#';

      const vacuumIcon = document.createElement('i');
      vacuumIcon.className = 'fas fa-meteor';

      vacuumLink.appendChild(vacuumIcon);
      vacuumLi.appendChild(vacuumLink);

      vacuumLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterVacuumMode();
      });

      navList.appendChild(vacuumLi);

      // Splash page link icon (home)
      const splashLi = document.createElement('li');
      splashLi.className = 'nav-item active';

      const splashLink = document.createElement('a');
      splashLink.className = 'nav-link';
      splashLink.style.cursor = 'pointer';
      splashLink.href = '/splash/';

      const splashIcon = document.createElement('i');
      splashIcon.className = 'fas fa-home';

      splashLink.appendChild(splashIcon);
      splashLi.appendChild(splashLink);

      navList.appendChild(splashLi);

      // Pong mode icon (gamepad)
      const pongLi = document.createElement('li');
      pongLi.className = 'nav-item active';

      const pongLink = document.createElement('a');
      pongLink.className = 'nav-link';
      pongLink.style.cursor = 'pointer';
      pongLink.href = '#';

      const pongIcon = document.createElement('i');
      pongIcon.className = 'fas fa-gamepad';

      pongLink.appendChild(pongIcon);
      pongLi.appendChild(pongLink);

      pongLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterPongMode();
      });

      navList.appendChild(pongLi);
      */
    }
  });
</script>



    <div class="page-content" style="flex: 1 0 auto;">
      <div class="wrapper">
        <style>
  h1 {
    margin-top: 1.5em;
  }

  .hr-thin {
    border: none;
    height: 1px;
    color: #aaaaaa;
    background-color: #aaaaaa;
  }

  .hr-pale {
    border: none;
    height: 1px;
    color: #eeeeee;
    background-color: #eeeeee;
    margin-top: 0.3em;
    margin-bottom: 0.3em;
  }

  .hr-thick {
    border: none;
    height: 2px;
    color: #aaaaaa;
    background-color: #aaaaaa;
  }

  .category-section {
    margin-bottom: 2em;
    margin-left: -15px;
    padding-left: 25px;
    border-left: 5px solid;
  }

  .category-title {
    margin-top: 1em;
    margin-bottom: 0.3em;
    font-size: 1.5em;
  }

  .category-description {
    font-size: 90%;
    color: #555;
    margin-bottom: 0.8em;
  }

  .paper-item {
    margin-bottom: 0.5em;
    padding-bottom: 0.5em;
    border-bottom: 1px solid #aaa;
  }

  .paper-item:last-child {
    border-bottom: none;
  }

  .paper-header {
    cursor: pointer;
    display: flex;
    align-items: baseline;
    gap: 8px;
  }

  .paper-toggle {
    font-size: 0.9em;
    transition: transform 0.2s ease;
    flex-shrink: 0;
  }

  .paper-toggle.expanded {
    transform: rotate(90deg);
  }

  .paper-title {
    font-size: 1.05em;
    margin: 0;
    flex: 1;
  }

  .paper-header-links {
    font-size: 0.9em;
    margin-left: 0.1em;
  }

  .paper-header-links a {
    margin-left: 0.1em;
  }

  .paper-details {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;
    margin-left: 20px;
    margin-top: 0.5em;
  }

  .paper-details.expanded {
    max-height: 2000px;
  }

  .paper-meta {
    font-size: 85%;
    margin-bottom: 0.5em;
    color: #666;
  }

  .paper-description {
    font-size: 90%;
    margin-bottom: 0.5em;
  }

  .paper-links a {
    margin-right: 0.5em;
  }

  .paper-image {
    width: 100%;
    height: auto;
  }

  /* Tighten spacing between superscript asterisk and comma */
  .tight-comma {
    margin-left: -0.25em;
  }

  /* Lower the asterisk superscripts a bit */
  .paper-meta sup {
    vertical-align: super;
    font-size: 0.75em;
    top: 0.15em;
    position: relative;
  }
</style>

<div class="container">
  <h1><i class="fas fa-cogs"></i> Research</h1>
  <hr class="hr-thick">

  <p>
    Understanding deep learning will be one of the grand scientific challenges of the early 21st century. I want to develop fundamental theory to explain how neural networks learn. This is a big project that in total will require at least some theory of the data, a picture of the dynamics of neural net optimization, and a picture of how the model pulls out patterns from the data during this optimization process. We've seen a lot of progress in the past decade, I'm optimistic.
  </p>
  <p>
    This page gives a sketch of my major research threads, with each paper annotated to explain how it fits into its larger line of work and/or how I suggest you read it. The best articulation of my research philosophy's currently <a href="/blog/on-the-scientific-method/">here</a>. I'm a physicist by training, and I tend to take a first-principles, bottom-up, dynamics-first approach to the task of theorycraft.
  </p>
  <p>
    A lot of my papers have come about from helping people doing (mostly) empirical ML research come up with good minimal theoretical toy models that explain effects they're seeing [<a href="https://arxiv.org/abs/2003.10397">1</a>,<a href="https://arxiv.org/abs/2207.06569">2</a>,<a href="https://arxiv.org/abs/2107.11774">3</a>,<a href="https://arxiv.org/abs/2306.13185">4</a>,<a href="https://arxiv.org/abs/2410.04642">5</a>]. Some of these ideas came about from quick initial conversations! If you've got a curious empirical phenomenon you're trying to explain, please reach out.
  </p>

  
  

  <hr class="hr-thick">

  
    
    
    <div class="category-section" style="border-left-color: #e88a8a;">
      <h3 class="category-title">Developing + using the theory of kernel regression</h3>

      
        <p class="category-description">Kernel ridge regression (KRR) is a primitive learning algorithm that looks a lot like deep learning in some ways (e.g., as a model of overparameterized optimization). It's strictly simpler, and any question you can't answer for KRR, you can't answer for deep learning, so you should ask your questions about KRR first to get your thinking straight. I've done a lot of that. KRR is the only learning algorithm for which we have a simple, general, and verifiable theory of generalization. I've helped build this hammer and hit a lot of nails with it.</p>
      

      

      <hr class="hr-thin">

      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Predicting kernel regression learning curves from only raw data statistics
              
                (2025)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2510.14878" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Dhruva Karkada*, Joey Turnbull*, Yuxi Liu, James B. Simon</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/hea_paper_mainpage_figure.png" alt="Predicting kernel regression learning curves from only raw data statistics">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">We study KRR with rotation-invariant kernels. We give a theoretical framework that predicts learning curves (test risk vs. sample size) from only two measurements: the empirical data covariance matrix and an empirical polynomial decomposition of the target function $f_*$. <br><br> This is possible because it turns out the kernel's eigenfunctions are approximately Hermite polynomials (and approximately insensitive to the actual choice of rotation-invariant kernel). We capture this idea mathematically as the <b>Hermite eigenstructure ansatz</b>, prove it in informative limiting cases for Gaussian data, and validate it empirically for several real image datasets. <br><br> We did this project as a stepping stone towards a theory of MLPs. We needed a rudimentary theory of the structure of the data, and now we have one. As we show in the paper, even feature-learning MLPs seem to learn Hermite monomials in an order predicted by the HEA! This paper worked far better than any of us expected, which when doing science, is a good sign you're on to something. <br><br> This was my first paper functioning as a PI. It's also my best work -- my coauthors did a remarkable job.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              More is better in modern machine learning: when infinite overparameterization is optimal and overfitting is obligatory
              
                (ICLR 2024)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2311.14646" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James B. Simon, Dhruva Karkada, Nikhil Ghosh, Mikhail Belkin</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/more_is_better_figure.png" alt="More is better in modern machine learning: when infinite overparameterization is optimal and overfitting is obligatory">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">Our main contribution here a theory of the generalization of random feature models. It's a simple eigenframework which generalizes the one for KRR. With it, we conclude that random feature regression performs better with more parameters, more data, and less regularization, putting theoretical backing to these observations in modern ML. This gives a fairly solid mathematical picture to replace classical intuitions about the risks of overparameterization and overfitting. The eigenframework here can probably be used to answer a lot of other questions.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              An agnostic view on the cost of overfitting in (kernel) ridge regression
              
                (ICLR 2024)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2306.13185" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Lijia Zhou, James B. Simon, Gal Vardi, Nathan Srebro</div>
              <hr class="hr-pale">
            
            
              <div class="paper-description">In this paper, we work backwards from the KRR eigenframework, which is <i>omniscient</i> in the sense that it assumes knowledge of the target function, to an <i>agnostic</i> theory which does not. It's similar in goal to <a href='/blog/backsolving-classical-bounds/'>this blogpost</a>.</div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Benign, tempered, or catastrophic: toward a refined taxonomy of overfitting
              
                (NeurIPS 2022)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2207.06569" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Neil Mallinar*, James B. Simon*, Amirhesam Abedsoltan, Parthe Pandit, Misha Belkin, Preetum Nakkiran</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/tempered_overfitting.png" alt="Benign, tempered, or catastrophic: toward a refined taxonomy of overfitting">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">Classical wisdom holds that overparameterization is harmful. Neural nets defy this wisdom, generalizing well despite their overparameterization and interpolation of the training data. What gives? How can we understand this discrepancy?<br><br>Recent landmark papers have explored the concept of benign overfitting -- a phenomenon in which certain models can interpolate noisy data without harming generalization -- suggesting that that neural nets may fit benignly. Here we put this idea to the empirical test, giving a new characterization of neural network overfitting and noise sensitivity. We find that neural networks trained to interpolation do not overfit benignly, but neither do they exhibit the catastrophic overfitting foretold by classical wisdom: instead, they usually lie in a third, intermediate regime we call tempered overfitting. I found that we can understand these three regimes of overfitting analytically for kernel regression (a toy model for neural networks), and I proved a simple "trichotomy theorem" relating a kernel's eigenspectrum to its overfitting behavior.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              On kernel regression with data-dependent kernels
              
                (2022)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2209.01691" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James B. Simon</div>
              <hr class="hr-pale">
            
            
              <div class="paper-description">A short note connecting optimal kernel adaptation to the data to a Bayesian view of target functions. This hasn't been useful since, but maybe someday.</div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              The eigenlearning framework: a conservation law perspective on kernel regression and wide neural networks
              
                (TMLR 2023)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2110.03922" onclick="event.stopPropagation();">[arXiv]</a><a href="/blog/eigenlearning/" onclick="event.stopPropagation();" style="margin-left: 0.3em;">[blog]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James B. Simon, Madeline Dickens, Dhruva Karkada, Michael R. DeWeese</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/eigenlearning_mainpage_figure.png" alt="The eigenlearning framework: a conservation law perspective on kernel regression and wide neural networks">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">This is the paper that started this whole sequence for me. Maddie and I managed to derive a simple, physicsy eigenframework for the generalization of KRR. It turned out others had beat us to it, but I was captivated by the beauty of the equations, so we published this paper giving what I think is still the simplest and most accessible version of the theory, plus a handful of applications, plus a surprising connection to quantum physics. If you're not familiar with these ideas and want to study generalization in machine learning, I strongly recommend you read this paper or one of the related ones we cite.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      

    </div>

    
      <hr class="hr-thick">
    
  
    
    
    <div class="category-section" style="border-left-color: #f0a868;">
      <h3 class="category-title">Stepwise learning dynamics</h3>

      
        <p class="category-description">In certain regimes, neural nets show staircase-like loss curves over the course of optimization, with plateaus punctuated by sudden drops. This sort of dynamics is called "stepwise," "<a href=\"https://arxiv.org/abs/2505.21722\">saddle-to-saddle</a>," or "incremental" learning, and it has the flavor of greedy low-rank optimization. The dynamics in these cases is often easier to understand than in more traditional regimes, so it's worth understanding what's going on to look for generalizing insights.</p>
      

      

      <hr class="hr-thin">

      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Closed-form training dynamics reveal learned features and linear structure in word2vec-like models
              
                (NeurIPS 2025)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2502.09863" onclick="event.stopPropagation();">[arXiv]</a><a href="https://dkarkada.xyz/posts/qwem/" onclick="event.stopPropagation();" style="margin-left: 0.3em;">[blog]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Dhruva Karkada, James B. Simon, Yasaman Bahri, Michael R. DeWeese</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/word2vec_paper_figure.png" alt="Closed-form training dynamics reveal learned features and linear structure in word2vec-like models">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">We show that <code>word2vec</code> exhibits stepwise learning, and even better, the early steps correspond to interpretable semantic concepts in the vocabulary. This is a promising bridge for connecting fundamental theory to mechanistic interpretability.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Alternating gradient flows: a theory of feature learning in two-layer neural networks
              
                (NeurIPS 2025)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2506.06489" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Daniel Kunin, Giovanni Luca Marchetti, Feng Chen, Dhruva Karkada, James B. Simon, Michael R. DeWeese, Surya Ganguli, Nina Miolane</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/agf_figure.png" alt="Alternating gradient flows: a theory of feature learning in two-layer neural networks">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">We give an explicit algorithmic description of feature learning in some shallow neural networks trained from small init. In this picture, the model alternates between <i>alignment phases,</i> in which dormant neurons align with the current residual gradient, and <i>growth phases,</i> in which a newly grown neuron joints the community, which collectively settles into a new locally optimal configuration.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Saddle-to-saddle dynamics in deep ReLU networks: low-rank bias in the first saddle escape
              
                (2025)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2505.21722" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Ioannis Bantzis, James B. Simon, Arthur Jacot</div>
              <hr class="hr-pale">
            
            
              <div class="paper-description">Do general deep neural networks show stepwise learning dynamics from small initialization? Empirically, it's surprisingly hard to tell. Theoretically, it's also surprisingly hard to tell. In this paper, we take the first step by studying the first step a deep $\textrm{ReLU}$ net provably has at least one plateau-and-drop step, and we characterize this first step, showing that the growth direction is <i>rank-one</i> in almost all weight matrices.</div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              On the stepwise nature of self-supervised learning
              
                (ICML 2023)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2303.15438" onclick="event.stopPropagation();">[arXiv]</a><a href="https://bair.berkeley.edu/blog/2023/07/10/stepwise-ssl/" onclick="event.stopPropagation();" style="margin-left: 0.3em;">[blog]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James B. Simon, Maksis Knutins, Liu Ziyin, Daniel Geisz, Abraham J. Fetterman, Joshua Albrecht</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/stepwise_mainpage_figure.png" alt="On the stepwise nature of self-supervised learning">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">This is the paper that started this sequence for me. We noticed that self-supervised models sometimes exhibited stepwise loss curves, and I developed a kernel theory that explains why. The theory is exact in the neural tangent kernel regime. The theory and supporting empirics suggest that we can understand self-supervised models as building their representations a few directions at a time, working in a low-rank subspace at any given moment.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      

    </div>

    
      <hr class="hr-thick">
    
  
    
    
    <div class="category-section" style="border-left-color: #f0d868;">
      <h3 class="category-title">Scaling dynamics and hyperparameters of feature learning</h3>

      
        <p class="category-description">A central tenet of the developing science of deep learning is that you should study your hyperparameters, because if you don't control for them, they'll confound whatever conclusion you're attempting to draw. In these papers, we study hyperparameters related to feature learning. These scaling relationships help lay down foundations for future science.</p>
      

      

      <hr class="hr-thin">

      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              The optimization landscape of sgd across the feature learning strength
              
                (ICLR 2025)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2410.04642" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Alexander Atanasov*, Alexandru Meterez*, James B. Simon*, Cengiz Pehlevan</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/richness_phase_diagram.png" alt="The optimization landscape of sgd across the feature learning strength">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">We disentangle the network <i>richness parameter</i> $\gamma$ from the <i>learning rate</i> $\eta$, identifying scaling relationships and giving a phase diagram. We give a definition and characterization of the <i>ultra-rich</i> regime, which lives $\gamma \gg 1$ beyond the rich regime. Training in the ultra-rich regime often shows stepwise learning and is conceptually related to training from small initialization. It seems to be mathematically simpler than the rich regime but no less performant (at least given long enough to train), and we came away from this thinking it is a useful subject for future theoretical research.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              A spectral condition for feature learning
              
                (2023)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2310.17813" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Greg Yang*, James B. Simon*, Jeremy Bernstein*</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/spectral_scaling_mainpage_figure.png" alt="A spectral condition for feature learning">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">We give a simple scaling treatment of feature learning in wide networks in terms of the spectral norm of weight matrices. If you want to understand the $\mu$-parameterization, this is probably the easiest place to start.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      

    </div>

    
      <hr class="hr-thick">
    
  
    
    
    <div class="category-section" style="border-left-color: #88c88a;">
      <h3 class="category-title">My thesis</h3>

      

      

      <hr class="hr-thin">

      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Discretized Theories of Deep Learning at Large Width: an Eigenthesis
              
                (2024)
              
              <span class="paper-header-links"><a href="https://www.proquest.com/openview/5549e5f80dfdbf42ce7c865b8c357998/1?pq-origsite=gscholar&cbl=18750&diss=y" onclick="event.stopPropagation();">[pdf]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James Simon</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/thesis_figure.png" alt="Discretized Theories of Deep Learning at Large Width: an Eigenthesis">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">The introduction here is probably a good resource for new students in DL theory to read to get some bearings. The rest is my papers stapled together with some personal history thrown in.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      

    </div>

    
      <hr class="hr-thick">
    
  
    
    
    <div class="category-section" style="border-left-color: #68c8d0;">
      <h3 class="category-title">Other machine learning theory</h3>

      
        <p class="category-description">Odds and ends.</p>
      

      

      <hr class="hr-thin">

      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              FACT: the Features at Convergence Theorem
              
                (2025)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2507.05644" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Enric Boix-Adserà*, Neil Mallinar*, James B. Simon, Mikhail Belkin</div>
              <hr class="hr-pale">
            
            
              <div class="paper-description">I quite like the neural feature ansatz, but it's not derivable from first principles, and I was (and remain) convinced it's not quite the right object to study. This paper gives an alternative which <i>does</i> provably come from a first-principles calculation and serves basically the same purposes.</div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              You can just put up a poster at ICML and nobody will stop you
              
                (ICML 2023)
              
              <span class="paper-header-links"><a href="https://x.com/_dsevero/status/1684677903382982656" onclick="event.stopPropagation();">[viral tweet]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Jimmy Neuron, Chet G. P. Tee, Ada Grahd</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/fedex_attack_mainpage_figure.png" alt="You can just put up a poster at ICML and nobody will stop you">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">Did you know you can just do things?</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Reverse engineering the neural tangent kernel
              
                (ICML 2022)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2106.03186" onclick="event.stopPropagation();">[arXiv]</a><a href="/blog/reverse-engineering/" onclick="event.stopPropagation();" style="margin-left: 0.3em;">[blog]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James B. Simon, Sajant Anand, Michael R. DeWeese</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/shallow_learning_sketch.png" alt="Reverse engineering the neural tangent kernel">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">This was a cute idea with some surprisingly nice math. It's where I first used Hermite polynomials, which would later return. It was a pretty idea, but I no longer believe in it.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              SGD with a constant large learning rate can converge to local maxima
              
                (ICLR 2022)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2107.11774" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Liu Ziyin, Botao Li, James B. Simon, Masahito Ueda</div>
              <hr class="hr-pale">
            
            
              <div class="paper-description">A cute observation about pathological cases of SGD loss landscapes.</div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Critical point-finding methods reveal gradient-flat regions of deep network losses
              
                (Neural Computation 2021)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2003.10397" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Charles G. Frye, James Simon, Neha S. Wadia, Andrew Ligeralde, Michael R. DeWeese, Kristofer E. Bouchard</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/trajectories.png" alt="Critical point-finding methods reveal gradient-flat regions of deep network losses">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">This was my first ML theory paper!</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      

    </div>

    
      <hr class="hr-thick">
    
  
    
    
    <div class="category-section" style="border-left-color: #7884c8;">
      <h3 class="category-title">My past life as a physicist</h3>

      
        <p class="category-description">My academic roots are in physics, and that still informs how I see the world and the development of human knowledge.</p>
      

      

      <hr class="hr-thin">

      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Interleaved electro-optic dual comb generation to expand bandwidth and scan rate for molecular spectroscopy and dynamics studies near 1.6 µm
              
                (Optics Express 2021)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2106.11414" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Jasper R. Stroud, James B. Simon, Gerd A. Wagner, David F. Plusquellic</div>
              <hr class="hr-pale">
            
            
              <div class="paper-description">Experimental optics work done during summer internship at NIST in 2017.</div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Simplified Josephson-junction fabrication process for reproducibly high-performance superconducting qubits
              
                (APL 2021)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2011.05230" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">Amr Osman, James Simon, Andreas Bengtsson, Sandoko Kosen, Philip Krantz, Daniel Perez, Marco Scigliuzzo, Per Delsing, Jonas Bylander, Anita Fadavi Roudsari</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/jj.png" alt="Simplified Josephson-junction fabrication process for reproducibly high-performance superconducting qubits">
                </div>
                <div class="col-md-9">
                  
                    <div class="paper-description" style="margin-top: 8px;">In the spring and summer of 2019 I worked in the lab of Prof. Per Delsing developing nanofabrication methods for Josephson junctions, ubiquitous components in superconducting circuitry. My main project was a study of how junctions age in the months after fabrication, but my biggest contribution was elsewhere: Anita Fadavi, Amr Osman and I developed a junction design that's faster to fabricate by one lithography step, or potentially several days of work.</div>
                  
                </div>
              </div>
            
          </div>
        </div>
      
        <div class="paper-item">
          <div class="paper-header" onclick="togglePaper(this)">
            <span class="paper-toggle">▸</span>
            <span class="paper-title">
              Fast noise-resistant control of donor nuclear spin qubits in silicon
              
                (PRB 2020)
              
              <span class="paper-header-links"><a href="https://arxiv.org/abs/2001.10029" onclick="event.stopPropagation();">[arXiv]</a></span>
            </span>
          </div>
          <div class="paper-details">
            
              <div class="paper-meta">James Simon, F. A. Calderon-Vargas, Edwin Barnes, Sophia E. Economou</div>
              <hr class="hr-pale">
            
            
              <div class="row">
                <div class="col-md-3">
                  <img class="paper-image" src="/img/mainpage_figures/statediagram.png" alt="Fast noise-resistant control of donor nuclear spin qubits in silicon">
                </div>
                <div class="col-md-9">
                  
                </div>
              </div>
            
          </div>
        </div>
      

    </div>

    
  

</div>

<script>
function togglePaper(headerElement) {
  const toggle = headerElement.querySelector('.paper-toggle');
  const details = headerElement.nextElementSibling;

  toggle.classList.toggle('expanded');
  details.classList.toggle('expanded');
}

function processAuthors() {
  // Process all author lists on page load
  const authorDivs = document.querySelectorAll('.paper-meta');
  authorDivs.forEach(div => {
    let text = div.textContent;

    // Replace "James B. Simon" or "James Simon" with bold "JS"
    text = text.replace(/James B\. Simon/g, '<b>JS</b>');
    text = text.replace(/James Simon/g, '<b>JS</b>');

    // Remove middle initials from all names (e.g., "John A. Doe" -> "John Doe")
    // Match pattern: space + single capital letter + period + space
    text = text.replace(/ [A-Z]\. /g, ' ');

    // Convert asterisks to superscripts and tighten commas after them
    text = text.replace(/\*,/g, '<sup>*</sup><span class="tight-comma">,</span>');
    // Handle any remaining asterisks not followed by commas
    text = text.replace(/\*/g, '<sup>*</sup>');

    div.innerHTML = text;
  });
}

// Run on page load
document.addEventListener('DOMContentLoaded', processAuthors);
</script>

      </div>
    </div>

    <div class="text-center p-3" style="background-color: #e8e8e8;">
  <div class="container ">
    <div class="row justify-content-md-center">

      <div class="col-2">
        <p class="text-center">
          <i class="far fa-envelope"></i>
          <a href="mailto:jsi@berkeley.edu">jsi@berkeley.edu</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-github"></i>
          <a href="https://github.com/james-simon">james-simon</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fas fa-graduation-cap"></i>
          <a href=https://scholar.google.com/citations?user=zjGfh3sAAAAJ&hl=en>gScholar</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-instagram"></i>
          <a href="https://instagram.com/sam.simon17">sam.simon17</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          SSN: 314-15-9265
        </p>
      </div>

    </div>
  </div>
</div>
</footer>

  </body>

</html>
