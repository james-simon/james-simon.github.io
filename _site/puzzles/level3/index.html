<!DOCTYPE html>
<html>

  <head>
  
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: { autoNumber: "AMS" },
        tagSide: "right"
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      }
    });
    MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function () {
      MathJax.InputJax.TeX.Stack.Item.AMSarray.Augment({
        clearTag() {
          if (!this.global.notags) {
            this.super(arguments).clearTag.call(this);
          }
        }
      });
    });
  </script>
  <script type="text/javascript" charset="utf-8"
    src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML">
  </script>


  <!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Level 3</title>
  <meta name="description" content="">

  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">

  <!-- <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">
  <script src="/boostrap/js/bootstrap.js"></script> -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">

  <link rel="canonical" href="http://localhost:4000/puzzles/level3/">
  <link rel="alternate" type="application/rss+xml" title="Jamie Simon" href="http://localhost:4000/feed.xml">

  <style>
    body {
      font-family: "et-book", "ETBookOT", "ET Book", Georgia, "Times New Roman", serif !important;
    }

    a:link {
      color: #1a4d8f;
      text-decoration: none;
    }

    a:visited {
      color: #6b2d8f;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>

  

</head>


  <body style="display: flex; flex-direction: column; min-height: 100vh; margin: 0;">

    <!-- <header class="site-header"> -->
    <!-- <a class="site-title" href="/">Jamie Simon</a> -->
<!-- </header> -->

    <style>
      .nav-link {
        transition: all 0.2s ease;
        border-radius: 4px;
        padding: 8px 16px !important;
      }

      .nav-link:hover {
        background-color: #333 !important;
        color: white !important;
      }

      .nav-link:hover i {
        color: white !important;
      }

      /* Hide text on narrow screens, show only icons */
      @media (max-width: 767px) {
        .nav-link .nav-text {
          display: none;
        }
        .nav-link {
          padding: 8px 12px !important;
        }
      }
    </style>

    <nav class="navbar navbar-expand navbar-light" style="background-color: #e8e8e8;">
      <div class = "container">
        <a class="navbar-brand" href="/">Jamie Simon</a></span> </a>
        <div class="navbar-collapse">
          <ul class="nav navbar-nav ml-auto" style="flex-wrap: nowrap;">
            <li class = "nav-item active"><a class="nav-link" href="/research/"><i class="fas fa-cogs"></i><span class="nav-text"> Research</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/blog/"><i class="fas fa-seedling"></i><span class="nav-text"> Blog</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/puzzles/"><i class="fab fa-laravel"></i><span class="nav-text"> Puzzles</span></a></li>
          </ul>
        </div>
      </div>
    </nav>

    <style>
  .char {
    display: inline;
    margin: 0;
    padding: 0;
    border: 0;
    vertical-align: baseline;
    line-height: inherit;
    font: inherit;
    font-size: inherit;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    color: inherit;
    white-space: inherit;
    letter-spacing: inherit;
    word-spacing: inherit;
    text-decoration: inherit;
    text-transform: inherit;
    background: transparent;
  }

  .char-particle {
    position: fixed;
    margin: 0;
    will-change: transform;
    pointer-events: none;
  }

  body.shatter-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.bird-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.panic-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  #shatter-overlay-blocker {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 9999;
    display: none;
  }

  body.shatter-locked #shatter-overlay-blocker {
    display: block;
  }
</style>

<div id="shatter-overlay-blocker"></div>
<audio id="shatter-audio" preload="auto" src="/audio/glass_bottle_breaking.mp3"></audio>
<audio id="pop-1" preload="auto" src="/audio/pop_1.mp3"></audio>
<audio id="pop-2" preload="auto" src="/audio/pop_2.mp3"></audio>
<audio id="pop-3" preload="auto" src="/audio/pop_3.mp3"></audio>
<audio id="pop-4" preload="auto" src="/audio/pop_4.mp3"></audio>
<!-- Bird mode audio -->
<audio id="goose-honk" src="/audio/bird_sounds/goose_honk.mp3" preload="auto"></audio>
<audio id="goose-yell" src="/audio/bird_sounds/goose_yell.mp3" preload="auto"></audio>
<audio id="hawk-call" src="/audio/bird_sounds/hawk_call.mp3" preload="auto"></audio>
<!-- Panic mode audio -->
<audio id="panic-alarm" preload="auto" src="/audio/alarm.mp3"></audio>
<audio id="panic-scream" preload="auto" src="/audio/crowd_scream.mp3"></audio>

<script>
  // ============================================================================
  // SHARED STATE AND UTILITIES FOR INTERACTIVE MODES
  // ============================================================================

  // Global state
  let shatterActive = false;
  let gravityActive = false;
  let vacuumActive = false;
  let pongActive = false;
  let birdModeActive = false;
  let panicActive = false;
  let mouseX = 0;
  let mouseY = 0;
  let prevMouseX = 0;
  let prevMouseY = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function playRandomPop() {
    const popIndex = Math.floor(Math.random() * 4) + 1;
    const audio = document.getElementById(`pop-${popIndex}`);
    if (audio) {
      audio.volume = 0.3; // Quieter pops
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Pop sound failed:', err));
    }
  }

  // Check if a point is close to a line segment
  function distanceToLineSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;

    if (lengthSquared === 0) {
      // Line segment is a point
      const distX = px - x1;
      const distY = py - y1;
      return Math.sqrt(distX * distX + distY * distY);
    }

    // Project point onto line segment
    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t)); // Clamp to [0, 1]

    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;

    const distX = px - closestX;
    const distY = py - closestY;
    return Math.sqrt(distX * distX + distY * distY);
  }

  function wrapTextNodes(node) {
    // Skip script, style, and interactive mode elements
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName;
      const elemId = node.id;

      // Skip these elements entirely
      if (tagName === 'SCRIPT' || tagName === 'STYLE' ||
          tagName === 'CODE' || tagName === 'PRE' ||
          tagName === 'KBD' || tagName === 'SAMP' ||
          tagName === 'TEXTAREA' || tagName === 'INPUT' ||
          tagName === 'SELECT' || tagName === 'BUTTON' ||
          elemId === 'shatter-overlay-blocker' ||
          elemId === 'shatter-audio' ||
          elemId === 'panic-button' ||
          elemId?.startsWith('pop-')) {
        return;
      }

      // Skip fixed/absolute positioned elements (like nav, modals, etc.)
      const style = window.getComputedStyle(node);
      if (style.position === 'fixed' || style.position === 'absolute') {
        return;
      }

      // Skip elements that are hidden
      if (style.display === 'none' || style.visibility === 'hidden') {
        return;
      }
    }

    // If it's a text node, wrap each character
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text.trim().length === 0) return; // Skip whitespace-only nodes

      const fragment = document.createDocumentFragment();
      // Use Array.from to properly handle multi-byte characters like emojis
      const chars = Array.from(text);
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === ' ') {
          // Preserve spaces as regular text nodes
          fragment.appendChild(document.createTextNode(' '));
        } else {
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = char;
          fragment.appendChild(span);
        }
      }
      node.parentNode.replaceChild(fragment, node);
    }
    // Recursively process child nodes
    else if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes);
      children.forEach(child => wrapTextNodes(child));
    }
  }

  // Gaussian random number generator (Box-Muller transform)
  function gaussianRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * stdDev + mean;
  }

  // Track if text has been wrapped
  let textWrapped = false;

  // Wrap text lazily when first mode is activated
  function ensureTextWrapped() {
    if (textWrapped) return;
    textWrapped = true;
    wrapTextNodes(document.body);
  }
</script>

<script>
  // ============================================================================
  // SHATTER MODE
  // ============================================================================

  function enterShatterMode() {
    if (shatterActive) return;
    shatterActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    const particles = [];

    // Helper function to create particle from element
    function createParticle(element, rect, isText = false) {
      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the element
      const clone = element.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(element);

      // For icon elements (i, svg), copy minimal styles to avoid interfering with pseudo-elements
      if (element.tagName === 'I' || element.tagName === 'SVG') {
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.color = computedStyle.color;
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      } else {
        // For other elements, copy full styles
        // Ensure emoji fonts are preserved by adding them to the font stack
        const fontFamily = computedStyle.fontFamily;
        clone.style.fontFamily = fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.fontWeight = computedStyle.fontWeight;
        clone.style.color = computedStyle.color;
        clone.style.backgroundColor = computedStyle.backgroundColor;
        clone.style.border = computedStyle.border;
        clone.style.borderRadius = computedStyle.borderRadius;
        clone.style.padding = computedStyle.padding;

        // Preserve dimensions for all elements to prevent shrinking
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      }

      // Set z-index: text always on top, then smaller elements in front
      if (isText) {
        clone.style.zIndex = '10000';
      } else {
        // Calculate area and set z-index inversely (smaller = higher z)
        const area = rect.width * rect.height;
        // Map area to z-index range 1000-9999 (larger area = lower z)
        const zIndex = Math.max(1000, Math.min(9999, 9999 - Math.floor(area / 10)));
        clone.style.zIndex = zIndex.toString();
      }

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      element.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: rect.width,
        height: rect.height
      });
    }

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();
      createParticle(char, rect, true); // isText = true
    });

    // Collect all other shatterable elements
    const elements = document.querySelectorAll('img, button, .styled-box, h1, h2, h3, h4, h5, h6, blockquote, svg, i, nav span, nav div');
    elements.forEach(el => {
      // Skip if it's the overlay blocker
      if (el.id === 'shatter-overlay-blocker') return;

      // Skip empty elements or elements with no visible content
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return;

      createParticle(el, rect);
    });

    // Collect line breaks and render them as small horizontal lines
    const lineBreaks = document.querySelectorAll('br');
    lineBreaks.forEach(br => {
      const rect = br.getBoundingClientRect();

      // Create a visible line element for the br
      const line = document.createElement('div');
      line.style.width = '20px';
      line.style.height = '2px';
      line.style.backgroundColor = '#999';
      line.style.position = 'fixed';
      line.style.left = rect.left + 'px';
      line.style.top = rect.top + 'px';
      line.classList.add('char-particle');

      // Add to body
      document.body.appendChild(line);

      // Hide original
      br.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: line,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: 20,
        height: 2
      });
    });

    // Play shatter sound after text wrapping and particle collection
    const audio = document.getElementById('shatter-audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Audio play failed:', err));
    }

    // Start animation
    startShatterAnimation(particles);
  }

  function startShatterAnimation(particles) {
    let lastTime = performance.now();
    const gravity = 1000; // Doubled gravity for faster fall
    const damping = 0.6; // More energy loss on bounce

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Apply gravity
        particle.vy += gravity * dt;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // GRAVITY MODE
  // ============================================================================

  function enterGravityMode() {
    if (gravityActive) return;
    gravityActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "GRAVITY ON" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'GRAVITY ON';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00bfff';
    flashMessage.style.textShadow = '0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00bfff';
    flashMessage.style.boxShadow = '0 0 20px #00bfff, inset 0 0 20px rgba(0, 191, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startGravityAnimation(particles);
  }

  function startGravityAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 150; // Falloff distance for exponential potential

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 5000;
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // VACUUM MODE
  // ============================================================================

  function enterVacuumMode() {
    if (vacuumActive) return;
    vacuumActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "VACUUM MODE INITIATED" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'VACUUM MODE INITIATED';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00ff00';
    flashMessage.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00ff00';
    flashMessage.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Keep a history of 15 mouse positions for smoother direction calculation
    const mouseHistory = [];
    const HISTORY_LENGTH = 15;

    // Store vacuumed particles in order for burping
    const vacuumedParticles = [];

    // Track mouse position and update history
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;

      // Only add to history if mouse actually moved
      if (prevMouseX !== null && prevMouseY !== null) {
        const dx = mouseX - prevMouseX;
        const dy = mouseY - prevMouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.1) { // Only count as movement if moved enough
          mouseHistory.push({x: mouseX, y: mouseY});

          // Keep only last 5 positions
          if (mouseHistory.length > HISTORY_LENGTH) {
            mouseHistory.shift();
          }
        }
      }
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport or has no width (e.g., newlines)
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startVacuumAnimation(particles, vacuumedParticles, mouseHistory);
  }

  function startVacuumAnimation(particles, vacuumedParticles, mouseHistory) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 300; // Falloff distance for exponential potential
    const velocityDamping = 0.99; // Per-frame velocity damping
    const WAIT_TIME = 5; // seconds to wait before burp mode
    const V_BURP = 1000; // pixels per second
    const BURP_RATE = 30; // chars per second
    let allParticlesGoneTime = null;
    let burpAudio = null;
    let burpStarted = false;
    const burpedParticles = []; // Active burped particles

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      // Only check for particle removal if we have a valid mouse position
      if (mouseX !== null && mouseY !== null && prevMouseX !== null && prevMouseY !== null) {
        // Filter out particles that should be removed
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];

          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Also check distance to line segment traced by mouse movement
          const distToPath = distanceToLineSegment(centerX, centerY, prevMouseX, prevMouseY, mouseX, mouseY);

          // Effective capture radius is proportional to particle size
          const effectiveRadius = Math.min(particle.width, particle.height) / 2;

          // Remove particle if within effective radius of current mouse position or path
          if (dist < effectiveRadius || distToPath < effectiveRadius) {
            // Store particle info for burping later
            vacuumedParticles.push({
              el: particle.el,
              x: particle.x,
              y: particle.y,
              vx: particle.vx,
              vy: particle.vy,
              width: particle.width,
              height: particle.height
            });

            // Hide but don't remove from DOM yet (we'll reuse it for burping)
            particle.el.style.display = 'none';
            particles.splice(i, 1);
            playRandomPop(); // Play pop sound
            continue;
          }
        }
      }

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ), 30x stronger than base
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 150000; // 30x force
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Apply velocity damping
        particle.vx *= velocityDamping;
        particle.vy *= velocityDamping;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Update previous mouse position for next frame
      prevMouseX = mouseX;
      prevMouseY = mouseY;

      // Check if all particles are gone
      if (particles.length === 0 && allParticlesGoneTime === null) {
        allParticlesGoneTime = currentTime;

        // Create BURP INCOMING flash message
        const burpWarning = document.createElement('div');
        burpWarning.id = 'burp-warning';
        burpWarning.textContent = 'BURP INCOMING';
        burpWarning.style.position = 'fixed';
        burpWarning.style.top = '50%';
        burpWarning.style.left = '50%';
        burpWarning.style.transform = 'translate(-50%, -50%)';
        burpWarning.style.fontSize = '64px';
        burpWarning.style.fontFamily = 'Courier New, monospace';
        burpWarning.style.fontWeight = 'bold';
        burpWarning.style.letterSpacing = '4px';
        burpWarning.style.color = '#00ff00';
        burpWarning.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
        burpWarning.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        burpWarning.style.padding = '30px 50px';
        burpWarning.style.border = '4px solid #00ff00';
        burpWarning.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
        burpWarning.style.zIndex = '100000';
        burpWarning.style.pointerEvents = 'none';
        burpWarning.style.textAlign = 'center';
        burpWarning.style.display = 'none';
        document.body.appendChild(burpWarning);

        // Flash with 0.5s on, 0.5s off starting at 3 seconds (last 2 seconds before burp)
        let flashStartTime = null;

        function flashBurpWarning(time) {
          const elapsed = (time - allParticlesGoneTime) / 1000;

          if (elapsed >= 3 && elapsed < WAIT_TIME) {
            if (flashStartTime === null) flashStartTime = time;
            const flashElapsed = (time - flashStartTime) / 1000;
            const cycleTime = flashElapsed % 1.0; // 1 second cycle

            if (cycleTime < 0.5) {
              burpWarning.style.display = 'block';
            } else {
              burpWarning.style.display = 'none';
            }

            requestAnimationFrame(flashBurpWarning);
          } else if (elapsed >= WAIT_TIME) {
            // Remove warning when burp starts
            burpWarning.remove();
          } else if (elapsed < 3) {
            // Keep flashing until we reach 3 seconds
            requestAnimationFrame(flashBurpWarning);
          }
        }

        requestAnimationFrame(flashBurpWarning);
      }

      // Start burp mode after WAIT_TIME
      if (allParticlesGoneTime !== null && burpAudio === null) {
        const elapsed = (currentTime - allParticlesGoneTime) / 1000;

        if (elapsed >= WAIT_TIME && !burpStarted) {
          burpStarted = true;

          burpAudio = new Audio('/audio/burp_loop.mp3');
          burpAudio.loop = true;
          burpAudio.volume = 0.5;
          burpAudio.play();

          // Start burping particles at BURP_RATE
          let lastBurpTime = currentTime;
          const burpInterval = 1000 / BURP_RATE; // ms between burps

          function burpParticle() {
            if (vacuumedParticles.length > 0) {
              // Get current mouse direction
              let dirX = 0, dirY = 1; // Default down
              if (mouseHistory.length >= 2) {
                const oldest = mouseHistory[0];
                const newest = mouseHistory[mouseHistory.length - 1];
                const histDx = newest.x - oldest.x;
                const histDy = newest.y - oldest.y;
                const histDist = Math.sqrt(histDx * histDx + histDy * histDy);

                if (histDist > 0.01) {
                  // Direction is same as mouse movement
                  dirX = histDx / histDist;
                  dirY = histDy / histDist;
                }
              }

              // Pop from end (reverse order)
              const particle = vacuumedParticles.pop();

              // Reset particle position to mouse (centered on particle)
              particle.x = mouseX - particle.width / 2;
              particle.y = mouseY - particle.height / 2;

              // Add Gaussian angular jitter (mean 0, stdev 3 degrees)
              const jitterAngle = gaussianRandom(0, 3) * Math.PI / 180; // Convert to radians
              const currentAngle = Math.atan2(dirY, dirX);
              const newAngle = currentAngle + jitterAngle;
              const jitteredDirX = Math.cos(newAngle);
              const jitteredDirY = Math.sin(newAngle);

              particle.vx = jitteredDirX * V_BURP;
              particle.vy = jitteredDirY * V_BURP;

              // Show particle again
              particle.el.style.display = 'block';
              particle.el.style.left = particle.x + 'px';
              particle.el.style.top = particle.y + 'px';

              burpedParticles.push(particle);
            }

            // Schedule next burp if more particles remain
            if (vacuumedParticles.length > 0) {
              setTimeout(burpParticle, burpInterval);
            } else {
              // All particles burped out, stop the audio
              if (burpAudio) {
                burpAudio.pause();
                burpAudio.currentTime = 0;
              }
            }
          }

          // Start burping
          burpParticle();
        }
      }

      // Animate burped particles with gravity and bouncing
      if (burpStarted && burpedParticles.length > 0) {
        const gravity = 1000; // Same as shatter mode
        const bounceDamping = 0.6; // Energy loss on bounce

        for (let i = burpedParticles.length - 1; i >= 0; i--) {
          const particle = burpedParticles[i];

          // Apply gravity
          particle.vy += gravity * dt;

          // Update position
          particle.x += particle.vx * dt;
          particle.y += particle.vy * dt;

          // Bounce off edges with energy loss (same as shatter mode)
          const width = window.innerWidth;
          const height = window.innerHeight;

          // Left and right edges
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Top and bottom edges
          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.y + particle.height > height + 7) {
            // Keep character visible - allow a bit past the bottom (7px lower)
            particle.y = height - particle.height + 7;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Update transform
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  function enterPongMode() {
    if (pongActive) return;
    pongActive = true;

    // Play ready set go sound immediately
    const readyAudio = new Audio('/audio/chiptune_ready_set_go.mp3');
    readyAudio.volume = 1.0;
    readyAudio.play().catch(err => console.log('Ready audio play failed:', err));

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "METEOR SHOWER INCOMING" message
    const flashMessage = document.createElement('div');
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#ff00ff';
    flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #ff00ff';
    flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';

    const mainText = document.createElement('div');
    mainText.textContent = 'METEOR SHOWER INCOMING';
    mainText.style.fontSize = '64px';

    const subText = document.createElement('div');
    subText.textContent = '(GAME TO 10)';
    subText.style.fontSize = '32px';
    subText.style.marginTop = '10px';

    flashMessage.appendChild(mainText);
    flashMessage.appendChild(subText);
    document.body.appendChild(flashMessage);

    // Show for 2 seconds, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000);
    }, 2000);

    // Create score displays
    const leftScoreContainer = document.createElement('div');
    leftScoreContainer.style.position = 'fixed';
    leftScoreContainer.style.top = '50px';
    leftScoreContainer.style.left = '50px';
    leftScoreContainer.style.zIndex = '99999';
    leftScoreContainer.style.pointerEvents = 'none';
    leftScoreContainer.style.textAlign = 'center';

    const leftLabel = document.createElement('div');
    leftLabel.textContent = 'THEIR\nSCORE';
    leftLabel.style.fontFamily = 'Courier New, monospace';
    leftLabel.style.fontSize = '24px';
    leftLabel.style.fontWeight = 'bold';
    leftLabel.style.color = '#ff0000';
    leftLabel.style.textShadow = '0 0 10px #ff0000';
    leftLabel.style.marginBottom = '10px';
    leftLabel.style.whiteSpace = 'pre-line';
    leftLabel.style.lineHeight = '1.2';

    const leftScore = document.createElement('div');
    leftScore.textContent = '0';
    leftScore.style.fontFamily = 'Courier New, monospace';
    leftScore.style.fontSize = '72px';
    leftScore.style.fontWeight = 'bold';
    leftScore.style.color = '#ff0000';
    leftScore.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';

    leftScoreContainer.appendChild(leftLabel);
    leftScoreContainer.appendChild(leftScore);
    document.body.appendChild(leftScoreContainer);

    const rightScoreContainer = document.createElement('div');
    rightScoreContainer.style.position = 'fixed';
    rightScoreContainer.style.top = '50px';
    rightScoreContainer.style.right = '50px';
    rightScoreContainer.style.zIndex = '99999';
    rightScoreContainer.style.pointerEvents = 'none';
    rightScoreContainer.style.textAlign = 'center';

    const rightLabel = document.createElement('div');
    rightLabel.textContent = 'YOUR\nSCORE';
    rightLabel.style.fontFamily = 'Courier New, monospace';
    rightLabel.style.fontSize = '24px';
    rightLabel.style.fontWeight = 'bold';
    rightLabel.style.color = '#00ff00';
    rightLabel.style.textShadow = '0 0 10px #00ff00';
    rightLabel.style.marginBottom = '10px';
    rightLabel.style.whiteSpace = 'pre-line';
    rightLabel.style.lineHeight = '1.2';

    const rightScore = document.createElement('div');
    rightScore.textContent = '0';
    rightScore.style.fontFamily = 'Courier New, monospace';
    rightScore.style.fontSize = '72px';
    rightScore.style.fontWeight = 'bold';
    rightScore.style.color = '#00ff00';
    rightScore.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';

    rightScoreContainer.appendChild(rightLabel);
    rightScoreContainer.appendChild(rightScore);
    document.body.appendChild(rightScoreContainer);

    // Create player paddle (right side, green)
    const playerPaddle = document.createElement('div');
    playerPaddle.style.position = 'fixed';
    playerPaddle.style.right = '20px';
    playerPaddle.style.width = '15px';
    playerPaddle.style.height = '200px';
    playerPaddle.style.backgroundColor = '#00ff00';
    playerPaddle.style.boxShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';
    playerPaddle.style.zIndex = '99999';
    playerPaddle.style.pointerEvents = 'none';
    document.body.appendChild(playerPaddle);

    // Create enemy paddle (left side, red, static)
    const enemyPaddle = document.createElement('div');
    enemyPaddle.style.position = 'fixed';
    enemyPaddle.style.left = '20px';
    enemyPaddle.style.width = '15px';
    enemyPaddle.style.height = '200px';
    enemyPaddle.style.backgroundColor = '#ff0000';
    enemyPaddle.style.boxShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';
    enemyPaddle.style.zIndex = '99999';
    enemyPaddle.style.pointerEvents = 'none';
    document.body.appendChild(enemyPaddle);

    // Paddle control state
    let playerPaddleY = window.innerHeight / 2 - 100; // Center paddle
    let enemyPaddleY = window.innerHeight / 2 - 100; // Center enemy paddle (static)
    let lastMouseMoveTime = 0;
    let mouseControlActive = false;
    const paddleSpeed = 800; // px/s for keyboard control

    // Update paddle positions
    playerPaddle.style.top = playerPaddleY + 'px';
    enemyPaddle.style.top = enemyPaddleY + 'px';

    // Mouse control
    document.addEventListener('mousemove', (e) => {
      mouseControlActive = true;
      lastMouseMoveTime = Date.now();
      playerPaddleY = Math.max(0, Math.min(window.innerHeight - 200, e.clientY - 100));
    });

    // Keyboard control
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    let themScore = 0;
    let youScore = 0;

    const particles = [];

    // Collect all text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height,
        active: false,
        trail: [] // Store last 15 positions for comet tail
      });
    });

    // Activate one random letter every 2 seconds, starting after 3.5 second delay
    let activationInterval;
    setTimeout(() => {
      activationInterval = setInterval(() => {
        // Find all inactive particles
        const inactiveParticles = particles.filter(p => !p.active);

        if (inactiveParticles.length === 0) {
          clearInterval(activationInterval);
          return;
        }

        // Pick a random inactive particle
        const randomParticle = inactiveParticles[Math.floor(Math.random() * inactiveParticles.length)];

        // Give it velocity with guaranteed horizontal movement
        const minVx = 200; // Minimum horizontal speed
        const vxSign = Math.random() < 0.5 ? -1 : 1;
        randomParticle.vx = vxSign * (minVx + Math.random() * 400); // 200-600 px/s
        randomParticle.vy = (Math.random() - 0.5) * 600;
        randomParticle.active = true;

        // Create whitish-orange burst at launch position
        const launchX = randomParticle.x + randomParticle.width / 2;
        const launchY = randomParticle.y + randomParticle.height / 2;
        createLaunchBurst(launchX, launchY);

        // Play letter release buzz - create new Audio instance each time
        const letterBuzz = new Audio('/audio/chiptune_buzz.wav');
        letterBuzz.volume = 0.35;
        letterBuzz.play().catch(err => console.log('Letter buzz play failed:', err));
      }, 2000);
    }, 3500);

    // Game state
    let blackHoleActive = false;
    let blackHoleEl = null;
    let gameOver = false;

    // Start animation
    startPongAnimation(particles, leftScore, rightScore, playerPaddle, enemyPaddle, () => playerPaddleY, (newY) => { playerPaddleY = newY; }, (newY) => { enemyPaddleY = newY; }, keys, () => mouseControlActive, () => blackHoleActive, (active) => { blackHoleActive = active; }, () => gameOver, (over) => { gameOver = over; });
  }

  function createBurst(x, y, color) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '80px';
    burst.style.height = '80px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = color;
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.8';
    burst.style.boxShadow = `0 0 40px ${color}, 0 0 80px ${color}`;
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.3s, transform 0.3s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.5)';
      setTimeout(() => {
        burst.remove();
      }, 300);
    }, 50);
  }

  function flashPaddle(paddleEl) {
    let flashCount = 0;
    const maxFlashes = 6; // 3 full on/off cycles
    const flashInterval = setInterval(() => {
      paddleEl.style.opacity = paddleEl.style.opacity === '0' ? '1' : '0';
      flashCount++;
      if (flashCount >= maxFlashes) {
        clearInterval(flashInterval);
        paddleEl.style.opacity = '1'; // Ensure it ends visible
      }
    }, 80); // Flash every 80ms
  }

  function createLaunchBurst(x, y) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '50px';
    burst.style.height = '50px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = '#ffcc88'; // Whitish-orange
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.7';
    burst.style.boxShadow = '0 0 20px #ffcc88, 0 0 40px #ffcc88';
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.25s, transform 0.25s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.3)';
      setTimeout(() => {
        burst.remove();
      }, 250);
    }, 50);
  }

  function startPongAnimation(particles, leftScoreEl, rightScoreEl, playerPaddleEl, enemyPaddleEl, getPlayerPaddleY, setPlayerPaddleY, setEnemyPaddleY, keys, getMouseActive, getBlackHoleActive, setBlackHoleActive, getGameOver, setGameOver) {
    let lastTime = performance.now();
    let themScore = 0;
    let youScore = 0;
    const paddleSpeed = 1152; // 20% faster than 960
    let enemyPaddleSpeed = 540; // Slower than player
    let enemyPaddleY = window.innerHeight / 2 - 100;
    let blackHoleEl = null;
    const paddleWidth = 15;
    const paddleHeight = 200;
    const leftPaddleX = 20;
    const rightPaddleX = window.innerWidth - 20 - paddleWidth;

    // Audio elements for paddle hits and game events
    const blip1Audio = new Audio('/audio/pong_blip_1.mp3'); // YOU paddle
    const blip2Audio = new Audio('/audio/pong_blip_2.mp3'); // THEM paddle
    const damage1Audio = new Audio('/audio/chiptune_damage_1.mp3'); // YOU damaged
    const damage2Audio = new Audio('/audio/chiptune_damage_2.mp3'); // THEM damaged
    const victoryAudio = new Audio('/audio/chiptune_victory.mp3'); // Victory
    const defeatAudio = new Audio('/audio/chiptune_defeat.mp3'); // Defeat

    // AI state
    const aiReactionDelay = 280; // ms
    const aiRandomOffset = 35; // px
    let lastAIUpdate = 0;
    let aiTargetY = enemyPaddleY;

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Update player paddle position with keyboard if mouse hasn't moved recently
      if (Date.now() - performance.now() > 100 || !getMouseActive()) {
        let paddleY = getPlayerPaddleY();
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
          paddleY -= paddleSpeed * dt;
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
          paddleY += paddleSpeed * dt;
        }
        paddleY = Math.max(0, Math.min(height - paddleHeight, paddleY));
        setPlayerPaddleY(paddleY);
      }

      // Update enemy AI paddle
      if (currentTime - lastAIUpdate > aiReactionDelay) {
        lastAIUpdate = currentTime;

        // Find the nearest threatening letter (moving left towards enemy paddle)
        let closestThreat = null;
        let minTime = Infinity;

        particles.forEach(particle => {
          if (particle.vx < 0 && particle.active) { // Moving left
            const timeToReach = (particle.x - (leftPaddleX + paddleWidth)) / -particle.vx;
            if (timeToReach > 0 && timeToReach < minTime) {
              minTime = timeToReach;
              // Predict where it will be
              let predictedY = particle.y + particle.vy * timeToReach;

              // Account for bounces off top/bottom
              while (predictedY < 0 || predictedY + particle.height > height) {
                if (predictedY < 0) {
                  predictedY = -predictedY;
                } else if (predictedY + particle.height > height) {
                  predictedY = 2 * (height - particle.height) - predictedY;
                }
              }

              closestThreat = predictedY + particle.height / 2; // Center of letter
            }
          }
        });

        if (closestThreat !== null) {
          // Add random offset for imperfection
          aiTargetY = closestThreat - paddleHeight / 2 + (Math.random() - 0.5) * aiRandomOffset;
        } else {
          // No threats, drift toward center
          aiTargetY = height / 2 - paddleHeight / 2;
        }
      }

      // Move enemy paddle smoothly towards target
      if (enemyPaddleY < aiTargetY) {
        enemyPaddleY = Math.min(aiTargetY, enemyPaddleY + enemyPaddleSpeed * dt);
      } else if (enemyPaddleY > aiTargetY) {
        enemyPaddleY = Math.max(aiTargetY, enemyPaddleY - enemyPaddleSpeed * dt);
      }
      enemyPaddleY = Math.max(0, Math.min(height - paddleHeight, enemyPaddleY));
      setEnemyPaddleY(enemyPaddleY);

      // Update paddle element positions
      playerPaddleEl.style.top = getPlayerPaddleY() + 'px';
      enemyPaddleEl.style.top = enemyPaddleY + 'px';

      // Update particles and check for scoring
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Apply black hole gravity if particle is active and black hole is active
        if (particle.active && getBlackHoleActive()) {
          const blackHoleX = width / 2;
          const blackHoleY = height / 2;
          const blackHoleLambda = 250;
          const blackHoleForce = 750000; // 5x stronger than before

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = blackHoleX - centerX;
          const dy = blackHoleY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            const forceMagnitude = (1 / blackHoleLambda) * Math.exp(-dist / blackHoleLambda) * blackHoleForce;
            let fx = (dx / dist) * forceMagnitude;
            let fy = (dy / dist) * forceMagnitude;

            // Non-conservative in x-coordinate: if moving away from black hole in x, reduce force to 75%
            if (particle.vx * dx < 0) { // Moving away in x (opposite signs)
              fx *= 0.75;
            }
            // Y-component remains conservative (no adjustment)

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Check for player paddle collision (right side)
        const playerPaddleY = getPlayerPaddleY();
        if (particle.vx > 0 && // Moving right
            particle.x + particle.width > rightPaddleX &&
            particle.x < rightPaddleX + paddleWidth &&
            particle.y + particle.height > playerPaddleY &&
            particle.y < playerPaddleY + paddleHeight) {

          // Play YOU paddle blip sound
          blip1Audio.currentTime = 0;
          blip1Audio.play().catch(err => console.log('Blip1 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - playerPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = rightPaddleX - particle.width;
        }

        // Check for enemy paddle collision (left side)
        if (particle.vx < 0 && // Moving left
            particle.x < leftPaddleX + paddleWidth &&
            particle.x + particle.width > leftPaddleX &&
            particle.y + particle.height > enemyPaddleY &&
            particle.y < enemyPaddleY + paddleHeight) {

          // Play THEM paddle blip sound
          blip2Audio.currentTime = 0;
          blip2Audio.play().catch(err => console.log('Blip2 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - enemyPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = leftPaddleX + paddleWidth;
        }

        // Check for left edge (YOU score - enemy missed)
        if (particle.x + particle.width < 0) {
          // Create red burst at contact point (you scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(0, contactY, '#ff0000');

          // Play THEM damage sound
          damage2Audio.currentTime = 0;
          damage2Audio.play().catch(err => console.log('Damage2 play failed:', err));

          // Flash enemy paddle
          flashPaddle(enemyPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            youScore++;
            rightScoreEl.textContent = youScore.toString();

            // Check for YOU reaching 10
            if (youScore === 10 && !getBlackHoleActive()) {
              activateBlackHole();
            } else if (youScore === 20) {
              endGame(true); // YOU win
            }
          }
          continue;
        }

        // Check for right edge (THEM score - player missed)
        if (particle.x > width) {
          // Create green burst at contact point (they scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(width, contactY, '#00ff00');

          // Play YOU damage sound
          damage1Audio.currentTime = 0;
          damage1Audio.play().catch(err => console.log('Damage1 play failed:', err));

          // Flash player paddle
          flashPaddle(playerPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            themScore++;
            leftScoreEl.textContent = themScore.toString();

            // Check for THEM reaching 10
            if (themScore === 10 && !getBlackHoleActive()) {
              endGame(false); // YOU lose
            } else if (themScore === 20) {
              endGame(false); // YOU lose
            }
          }
          continue;
        }

        // Bounce off top and bottom
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height) {
          particle.y = height - particle.height;
          particle.vy = -particle.vy;
        }

        // Update trail (store last 15 positions)
        if (particle.active) {
          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 15) {
            // Remove oldest trail element if it exists
            const oldest = particle.trail.shift();
            if (oldest.el) {
              oldest.el.remove();
            }
          }

          // Create/update trail elements
          particle.trail.forEach((trailPos, idx) => {
            if (!trailPos.el) {
              // Create new trail element
              const trailEl = particle.el.cloneNode(true);
              trailEl.style.pointerEvents = 'none';
              document.body.appendChild(trailEl);
              trailPos.el = trailEl;
            }

            // Update trail element position and style
            const age = particle.trail.length - idx - 1; // 0 = newest, 14 = oldest
            const opacity = 1 - (age + 1) / 16; // Fade from 0.94 to 0.06
            const scale = 1 - (age + 1) * 0.05; // Scale from 0.95 to 0.25

            trailPos.el.style.opacity = opacity.toString();
            trailPos.el.style.transform = `translate(${trailPos.x - parseFloat(particle.el.style.left)}px, ${trailPos.y - parseFloat(particle.el.style.top)}px) scale(${scale})`;
            trailPos.el.style.zIndex = (10000 - age - 1).toString(); // Behind main letter
          });
        }

        // Apply transform to main particle
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      }

      requestAnimationFrame(animate);
    }

    // Helper function to activate black hole
    function activateBlackHole() {
      setBlackHoleActive(true);

      // Increase AI speed
      enemyPaddleSpeed = 700;

      // Create black hole element
      const width = window.innerWidth;
      const height = window.innerHeight;
      blackHoleEl = document.createElement('div');
      blackHoleEl.style.position = 'fixed';
      blackHoleEl.style.left = (width / 2) + 'px';
      blackHoleEl.style.top = (height / 2) + 'px';
      blackHoleEl.style.width = '50px';
      blackHoleEl.style.height = '50px';
      blackHoleEl.style.marginLeft = '-25px';
      blackHoleEl.style.marginTop = '-25px';
      blackHoleEl.style.borderRadius = '50%';
      blackHoleEl.style.backgroundColor = '#000000';
      blackHoleEl.style.boxShadow = '0 0 30px 10px rgba(0, 0, 0, 0.8)';
      blackHoleEl.style.zIndex = '9999';
      blackHoleEl.style.pointerEvents = 'none';
      document.body.appendChild(blackHoleEl);

      // Animate the pulsing
      let pulseTime = 0;
      function pulseBlackHole() {
        if (!getBlackHoleActive() || !blackHoleEl) return;
        pulseTime += 0.05;
        const size = 40 + 10 * Math.sin(pulseTime);
        blackHoleEl.style.width = size + 'px';
        blackHoleEl.style.height = size + 'px';
        blackHoleEl.style.marginLeft = (-size / 2) + 'px';
        blackHoleEl.style.marginTop = (-size / 2) + 'px';
        requestAnimationFrame(pulseBlackHole);
      }
      pulseBlackHole();

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '20%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s ease-out';

      const mainText = document.createElement('div');
      mainText.textContent = 'BLACK HOLE ACTIVATED';
      mainText.style.fontSize = '64px';

      const subText = document.createElement('div');
      subText.textContent = '(GAME TO 20)';
      subText.style.fontSize = '32px';
      subText.style.marginTop = '10px';

      flashMessage.appendChild(mainText);
      flashMessage.appendChild(subText);
      document.body.appendChild(flashMessage);

      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => flashMessage.remove(), 2000);
      }, 4000);
    }

    // Helper function to end the game
    function endGame(playerWon) {
      setGameOver(true);

      // Play victory or defeat sound
      if (playerWon) {
        victoryAudio.currentTime = 0;
        victoryAudio.play().catch(err => console.log('Victory play failed:', err));
      } else {
        defeatAudio.currentTime = 0;
        defeatAudio.play().catch(err => console.log('Defeat play failed:', err));
      }

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontSize = '96px';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.whiteSpace = 'nowrap';
      flashMessage.textContent = playerWon ? 'VICTORY' : 'DEFEATED';
      document.body.appendChild(flashMessage);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // BIRD MODE
  // ============================================================================

</script>

<script>
  // ============================================================================
  // BIRD MODE DEBUG SETTINGS
  // ============================================================================
  const DRAW_FORCES = false;  // Set to false to disable force visualization

  function enterBirdMode() {
    if (birdModeActive) return;
    birdModeActive = true;

    try {
      console.log('Starting bird mode...');

      // Disable clicks on mystery button (but keep it visible so it can become a bird)
      const mysteryIcon = document.querySelector('.fa-question-circle');
      if (mysteryIcon) {
        const mysteryLink = mysteryIcon.closest('a.nav-link');
        if (mysteryLink) {
          mysteryLink.style.pointerEvents = 'none';
        }
      }

      // Create flashy "BIRD MODE ACTIVATED" message FIRST (before laggy operations)
      const flashMessage = document.createElement('div');
      flashMessage.textContent = 'BIRD MODE ACTIVATED';
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontSize = '64px';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff6b9d';
      flashMessage.style.textShadow = '0 0 10px #ff6b9d, 0 0 20px #ff6b9d, 0 0 30px #ff6b9d, 0 0 40px #ff6b9d';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff6b9d';
      flashMessage.style.boxShadow = '0 0 20px #ff6b9d, inset 0 0 20px rgba(255, 107, 157, 0.2)';
      flashMessage.style.zIndex = '100000';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s';
      document.body.appendChild(flashMessage);

      // Show for 1 second, then fade out over 2 seconds
      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => {
          flashMessage.remove();
        }, 2000);
      }, 1000);

      // Wait 50ms to ensure banner renders before starting laggy operations
      setTimeout(() => {
        // Wrap text
        ensureTextWrapped();

        // Lock body
        const scrollY = window.scrollY;
        document.body.classList.add('bird-locked');
        document.body.style.top = `-${scrollY}px`;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        });

        const particles = [];
        const MAX_BIRD_COUNT = 1000;

        // Find header characters to make them hawks (h1, or h2, or h3 if no h1)
        let headerElement = document.querySelector('h1');
        if (!headerElement) {
          headerElement = document.querySelector('h2');
        }
        if (!headerElement) {
          headerElement = document.querySelector('h3');
        }
        let h1Chars = [];
        if (headerElement) {
          h1Chars = Array.from(headerElement.querySelectorAll('.char'));
        }

        // Collect all character and glyph elements with their data
        // Separate hawks (always keep) from non-hawks (randomly select)
        const hawkElements = [];
        const nonHawkElements = [];

        // Collect all characters
        const chars = document.querySelectorAll('.char');
        chars.forEach(char => {
          const rect = char.getBoundingClientRect();

          // Skip if outside viewport
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth) {
            return;
          }

          const hawkIndex = h1Chars.indexOf(char);
          const isHawk = hawkIndex !== -1;

          const elem = {
            original: char,
            rect: rect,
            isChar: true,
            isHawk: isHawk,
            hawkIndex: hawkIndex,
            randomOrder: Math.random()  // For shuffling
          };

          if (isHawk) {
            hawkElements.push(elem);
          } else {
            nonHawkElements.push(elem);
          }
        });

        // Also collect glyphs and icons (all non-hawks)
        const glyphs = document.querySelectorAll('i, svg');
        glyphs.forEach(glyph => {
          const rect = glyph.getBoundingClientRect();

          // Skip if outside viewport or has no size
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth ||
              rect.width === 0 || rect.height === 0) {
            return;
          }

          nonHawkElements.push({
            original: glyph,
            rect: rect,
            isChar: false,
            isHawk: false,
            hawkIndex: -1,
            randomOrder: Math.random()  // For shuffling
          });
        });

        // Randomly shuffle non-hawks
        nonHawkElements.sort((a, b) => a.randomOrder - b.randomOrder);

        // Select non-hawks up to MAX_BIRD_COUNT - number of hawks
        const maxNonHawks = MAX_BIRD_COUNT - hawkElements.length;
        const selectedNonHawks = nonHawkElements.slice(0, maxNonHawks);
        const fadedNonHawks = nonHawkElements.slice(maxNonHawks);

        // Combine: all hawks + selected non-hawks become birds
        const birdElements = [...hawkElements, ...selectedNonHawks];

        // Process bird elements (become birds)
        birdElements.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Add to particles array (all bird elements become birds)
          particles.push({
            el: clone,
            x: rect.left,
            y: rect.top,
            vx: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,  // Hawks get tiny random velocity
            vy: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,
            width: rect.width,
            height: rect.height,
            isHawk: elem.isHawk,
            hawkIndex: elem.hawkIndex,  // -1 for non-hawks, 0+ for hawks
            isActive: !elem.isHawk,  // Hawks start dormant, boids start active
            originalX: rect.left,  // Store original position for dormant hawks
            originalY: rect.top
          });
        });

        // Process faded elements (fade out smoothly)
        fadedNonHawks.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Fade out this element smoothly
          clone.style.transition = 'opacity 3s ease-out';
          setTimeout(() => {
            clone.style.opacity = '0';
            setTimeout(() => {
              clone.remove();
            }, 3000);
          }, 10);
        });

        // Start animation
        // Create trajectory ray for hawk
        const trajectoryRay = document.createElement('div');
        trajectoryRay.id = 'hawk-trajectory-ray';
        trajectoryRay.style.position = 'fixed';
        trajectoryRay.style.height = '2px';
        trajectoryRay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        trajectoryRay.style.transformOrigin = '0 0';
        trajectoryRay.style.pointerEvents = 'none';
        trajectoryRay.style.zIndex = '9998';
        trajectoryRay.style.display = 'none';
        document.body.appendChild(trajectoryRay);

        // Create perpendicular lines container (SVG for efficient line drawing)
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'fear-lines-svg';
        svg.style.position = 'fixed';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '9997';
        document.body.appendChild(svg);

        // Create force vectors SVG overlay (for debug visualization)
        const forceVectorsSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        forceVectorsSvg.id = 'force-vectors-svg';
        forceVectorsSvg.style.position = 'fixed';
        forceVectorsSvg.style.top = '0';
        forceVectorsSvg.style.left = '0';
        forceVectorsSvg.style.width = '100%';
        forceVectorsSvg.style.height = '100%';
        forceVectorsSvg.style.pointerEvents = 'none';
        forceVectorsSvg.style.zIndex = '9999';
        forceVectorsSvg.style.display = DRAW_FORCES ? 'block' : 'none';
        document.body.appendChild(forceVectorsSvg);

        // Create force legend (for debug visualization)
        if (DRAW_FORCES) {
          const legend = document.createElement('div');
          legend.id = 'force-legend';
          legend.style.position = 'fixed';
          legend.style.top = '10px';
          legend.style.right = '10px';
          legend.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          legend.style.color = 'white';
          legend.style.padding = '10px';
          legend.style.fontFamily = 'monospace';
          legend.style.fontSize = '12px';
          legend.style.zIndex = '100001';
          legend.style.borderRadius = '5px';
          legend.style.lineHeight = '1.5';
          legend.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">FORCE LEGEND</div>
            <div><span style="color: #ff0000;">■</span> Repulsion (boid-boid)</div>
            <div><span style="color: #0000ff;">■</span> Cohesion</div>
            <div><span style="color: #00ff00;">■</span> Alignment</div>
            <div><span style="color: #00ffff;">■</span> Speed Stabilization</div>
            <div><span style="color: #ff8800;">■</span> Wall Repulsion</div>
            <div><span style="color: #ff00ff;">■</span> Fear</div>
            <div><span style="color: #ffff00;">■</span> Boid Attraction (hawks)</div>
            <div><span style="color: #ff69b4;">■</span> Hawk-Hawk Repulsion</div>
          `;
          document.body.appendChild(legend);
        }

        console.log('Starting animation with', particles.length, 'particles');
        startBirdAnimation(particles, trajectoryRay, svg, forceVectorsSvg);
      }, 50);  // End of 50ms setTimeout
    } catch (error) {
      console.error('Error in enterBirdMode:', error);
      birdModeActive = false;
      alert('Error starting bird mode: ' + error.message);
    }
  }

  function startBirdAnimation(particles, trajectoryRay, fearLinesSvg, forceVectorsSvg) {
    let lastTime = performance.now();
    let hawkInfos = [];  // Store all active hawks' positions and velocities for fear calculations

    const FORCE_MULTIPLIER = 25;  // Global force multiplication factor
    const MAX_SPEED = 400;   // Maximum speed
    const F_MAX = 10;  // Maximum force magnitude before clamping
    const FORCE_ARROW_SCALE = 20;  // Scale factor for visualizing force arrows

    // Repulsion parameters
    const LENGTH_SCALE = 20;  // px
    const R_REPULSION = 1 * LENGTH_SCALE;  // 20px
    const F_REPULSION = 5;  // Repulsion strength

    // Speed stabilization parameters
    const TARGET_SPEED = 15;  // px/s
    const TARGET_SPEED_HAWK = 50;  // px/s
    const F_SPEEDSTABILITY = 5;
    const F_SPEEDSTABILITY_HAWK = 2;

    // Alignment parameters
    const F_ALIGN = 2;

    // Wall repulsion parameters
    const WALL_REPULSION_DIST = 5 * LENGTH_SCALE;  // 100px
    const F_WALL_REPULSION = 4;

    // Hawk-specific wall repulsion (2x distance and magnitude)
    const WALL_REPULSION_DIST_HAWK = 1 * WALL_REPULSION_DIST;  // 200px
    const F_WALL_REPULSION_HAWK = .5 * F_WALL_REPULSION;  // 8

    // Hawk attraction parameters
    const F_ATTR_HAWK = 0.3;

    // Fear parameters
    const F_FEAR = 3;
    const FEAR_DIST = 15 * LENGTH_SCALE;  // 300px

    // Spatial grid parameters
    const CELL_SIZE = 2 * LENGTH_SCALE;  // 60px

    // Hawk release tracking
    let nextHawkIndex = 0;
    let nextHawkReleaseTime = 20.0;  // First hawk at 20 seconds (wall time)
    let elapsedTime = 0;  // Wall time in seconds

    function releaseHawk(hawk) {
      hawk.isActive = true;
      hawk.releaseTime = elapsedTime;  // Track when hawk was released

      // Play hawk call at 30% volume
      const hawkAudio = document.getElementById('hawk-call');
      if (hawkAudio) {
        hawkAudio.volume = 0.3;
        hawkAudio.currentTime = 0;
        hawkAudio.play().catch(e => console.log('Audio play failed:', e));
      }

      // Create big brown burst
      const burstX = hawk.x + hawk.width / 2;
      const burstY = hawk.y + hawk.height / 2;
      const burst = document.createElement('div');

      burst.style.position = 'fixed';
      burst.style.left = burstX + 'px';
      burst.style.top = burstY + 'px';
      burst.style.width = '0px';
      burst.style.height = '0px';
      burst.style.borderRadius = '50%';
      burst.style.backgroundColor = 'rgba(139, 69, 19, 0.6)';  // Brown color
      burst.style.transform = 'translate(-50%, -50%)';
      burst.style.pointerEvents = 'none';
      burst.style.zIndex = '9999';
      document.body.appendChild(burst);

      // Animate burst (much bigger)
      setTimeout(() => {
        burst.style.transition = 'all 0.6s ease-out';
        burst.style.width = '200px';
        burst.style.height = '200px';
        burst.style.backgroundColor = 'rgba(139, 69, 19, 0)';
      }, 10);

      setTimeout(() => burst.remove(), 650);
    }

    // Helper function to draw a force arrow in SVG
    function createArrow(x, y, fx, fy, color) {
      const length = Math.sqrt(fx * fx + fy * fy);
      if (length < 0.01) return null;  // Skip tiny forces

      const endX = x + fx * FORCE_ARROW_SCALE;
      const endY = y + fy * FORCE_ARROW_SCALE;

      // Create line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x);
      line.setAttribute('y1', y);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('opacity', '0.7');

      // Create arrowhead
      const arrowSize = 5;
      const angle = Math.atan2(fy, fx);
      const arrowX1 = endX - arrowSize * Math.cos(angle - Math.PI / 6);
      const arrowY1 = endY - arrowSize * Math.sin(angle - Math.PI / 6);
      const arrowX2 = endX - arrowSize * Math.cos(angle + Math.PI / 6);
      const arrowY2 = endY - arrowSize * Math.sin(angle + Math.PI / 6);

      const arrowhead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      arrowhead.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
      arrowhead.setAttribute('fill', color);
      arrowhead.setAttribute('opacity', '0.7');

      return { line, arrowhead };
    }

    function animate(currentTime) {
      if (!birdModeActive) return;

      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      // Update elapsed time (wall time in real seconds)
      elapsedTime += dt;

      // Simulation runs at 4x speed
      const simulationDt = dt * 4;

      // Clear hawk infos from previous frame
      hawkInfos = [];

      // Check if it's time to release the next hawk
      if (elapsedTime >= nextHawkReleaseTime) {
        // Find the hawk with hawkIndex === nextHawkIndex
        const hawkToRelease = particles.find(p => p.hawkIndex === nextHawkIndex);
        if (hawkToRelease && !hawkToRelease.isActive) {
          releaseHawk(hawkToRelease);
          nextHawkIndex++;
          // First hawk at 20s, then every 60s thereafter
          nextHawkReleaseTime += 60.0;
        }
      }

      // Build spatial grid (only for active, non-hawk particles)
      const grid = new Map();
      particles.forEach((particle, i) => {
        if (!particle.isActive || particle.isHawk) return;

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);
        const key = `${cellX},${cellY}`;

        if (!grid.has(key)) {
          grid.set(key, []);
        }
        grid.get(key).push(i);
      });

      // Check for hawk overlaps and hide captured particles
      particles.forEach((hawk, i) => {
        if (!hawk.isHawk || !hawk.isActive) return;

        // Hawks can't capture during their 2-second frozen period
        const timeSinceRelease = elapsedTime - (hawk.releaseTime || 0);
        if (timeSinceRelease < 2.0) return;

        particles.forEach((boid, j) => {
          if (i === j || !boid.isActive || boid.isHawk) return;

          // Check bounding box overlap
          if (hawk.x < boid.x + boid.width &&
              hawk.x + hawk.width > boid.x &&
              hawk.y < boid.y + boid.height &&
              hawk.y + hawk.height > boid.y) {
            // Overlap! Hide boid and create burst
            boid.isActive = false;
            boid.el.remove();

            // Play goose sound (75% honk, 25% yell)
            const soundId = Math.random() < 0.75 ? 'goose-honk' : 'goose-yell';
            const audio = document.getElementById(soundId);
            if (audio) {
              audio.currentTime = 0;
              audio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Create colorful burst
            const burstX = boid.x + boid.width / 2;
            const burstY = boid.y + boid.height / 2;
            const burst = document.createElement('div');

            // Random hue, high saturation, high lightness
            const hue = Math.floor(Math.random() * 360);
            const saturation = 70 + Math.floor(Math.random() * 20); // 70-90%
            const lightness = 60; // Medium-bright

            burst.style.position = 'fixed';
            burst.style.left = burstX + 'px';
            burst.style.top = burstY + 'px';
            burst.style.width = '0px';
            burst.style.height = '0px';
            burst.style.borderRadius = '50%';
            burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.6)`;
            burst.style.transform = 'translate(-50%, -50%)';
            burst.style.pointerEvents = 'none';
            burst.style.zIndex = '9999';
            document.body.appendChild(burst);

            // Animate burst
            setTimeout(() => {
              burst.style.transition = 'all 0.4s ease-out';
              burst.style.width = '60px';
              burst.style.height = '60px';
              burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`;
            }, 10);

            setTimeout(() => burst.remove(), 450);
          }
        });
      });

      // Apply forces to each particle
      particles.forEach((particle, i) => {
        if (!particle.isActive) return;  // Skip inactive particles

        // Initialize force tracking for debug visualization
        particle.forces = {
          speedStab: { x: 0, y: 0 },
          boidAttr: { x: 0, y: 0 },
          hawkRepulsion: { x: 0, y: 0 },
          wallRepulsion: { x: 0, y: 0 },
          repulsion: { x: 0, y: 0 },
          cohesion: { x: 0, y: 0 },
          alignment: { x: 0, y: 0 },
          fear: { x: 0, y: 0 }
        };

        // Hawks have their own forces
        if (particle.isHawk) {
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Keep hawk stationary for 2 seconds after release (for suspense)
          const timeSinceRelease = elapsedTime - (particle.releaseTime || 0);
          if (timeSinceRelease < 2.0) {
            // Hawk is frozen - keep it in place
            particle.vx = 0;
            particle.vy = 0;
            particle.x = particle.originalX;
            particle.y = particle.originalY;
            particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

            // Still store hawk info for fear calculations
            hawkInfos.push({
              x: centerX,
              y: centerY,
              vx: 0,
              vy: 0,
              speed: 0
            });
            return;  // Skip rest of hawk physics
          }

          let hawkForceX = 0;
          let hawkForceY = 0;

          // Speed stabilization force (weaker than boids, higher target speed)
          const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
          if (currentSpeed > 0) {
            const speedRatio = 1 - currentSpeed / TARGET_SPEED_HAWK;
            const speedForceMag = F_SPEEDSTABILITY_HAWK * Math.pow(speedRatio, 3);
            particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
            particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
            hawkForceX += particle.forces.speedStab.x;
            hawkForceY += particle.forces.speedStab.y;
          }

          // Attraction to nearest boid
          let nearestBoid = null;
          let nearestDist = Infinity;
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestBoid = { x: otherCenterX, y: otherCenterY, dist: dist };
            }
          });

          if (nearestBoid && nearestBoid.dist > 0) {
            const dx = nearestBoid.x - centerX;
            const dy = nearestBoid.y - centerY;
            particle.forces.boidAttr.x = (dx / nearestBoid.dist) * F_ATTR_HAWK;
            particle.forces.boidAttr.y = (dy / nearestBoid.dist) * F_ATTR_HAWK;
            hawkForceX += particle.forces.boidAttr.x;
            hawkForceY += particle.forces.boidAttr.y;
          }

          // Repulsion from nearest k hawks
          const K_HAWKS = 3;
          const HAWK_REPULSION_DIST = 50;  // px
          const F_HAWK_REPULSION = 0.5;  // Mild repulsion strength

          // Find all other active hawks
          const otherHawks = [];
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || !other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < HAWK_REPULSION_DIST) {
              otherHawks.push({ x: otherCenterX, y: otherCenterY, dist: dist });
            }
          });

          if (otherHawks.length > 0) {
            // Sort by distance and take k nearest
            otherHawks.sort((a, b) => a.dist - b.dist);
            const nearestKHawks = otherHawks.slice(0, K_HAWKS);

            // Calculate average position
            let avgHawkX = 0, avgHawkY = 0;
            nearestKHawks.forEach(h => {
              avgHawkX += h.x;
              avgHawkY += h.y;
            });
            avgHawkX /= nearestKHawks.length;
            avgHawkY /= nearestKHawks.length;

            // Calculate average distance
            let avgDist = 0;
            nearestKHawks.forEach(h => avgDist += h.dist);
            avgDist /= nearestKHawks.length;

            // Apply repulsive force (drops off linearly)
            if (avgDist > 0) {
              const repulsionStrength = F_HAWK_REPULSION * (1 - avgDist / HAWK_REPULSION_DIST);
              const dx = centerX - avgHawkX;
              const dy = centerY - avgHawkY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                particle.forces.hawkRepulsion.x = (dx / dist) * repulsionStrength;
                particle.forces.hawkRepulsion.y = (dy / dist) * repulsionStrength;
                hawkForceX += particle.forces.hawkRepulsion.x;
                hawkForceY += particle.forces.hawkRepulsion.y;
              }
            }
          }

          // Wall repulsion forces (stronger and longer range for hawks)
          const width = window.innerWidth;
          const height = window.innerHeight;

          let wallForceX = 0;
          let wallForceY = 0;

          // Left wall
          const distLeft = centerX;
          if (distLeft < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distLeft / WALL_REPULSION_DIST_HAWK);
            wallForceX += wallForceMag;  // Push right
          }

          // Right wall
          const distRight = width - centerX;
          if (distRight < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distRight / WALL_REPULSION_DIST_HAWK);
            wallForceX -= wallForceMag;  // Push left
          }

          // Top wall
          const distTop = centerY;
          if (distTop < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distTop / WALL_REPULSION_DIST_HAWK);
            wallForceY += wallForceMag;  // Push down
          }

          // Bottom wall
          const distBottom = height - centerY;
          if (distBottom < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distBottom / WALL_REPULSION_DIST_HAWK);
            wallForceY -= wallForceMag;  // Push up
          }

          particle.forces.wallRepulsion.x = wallForceX;
          particle.forces.wallRepulsion.y = wallForceY;
          hawkForceX += wallForceX;
          hawkForceY += wallForceY;

          // Clamp force to F_MAX
          const hawkForceMag = Math.sqrt(hawkForceX * hawkForceX + hawkForceY * hawkForceY);
          if (hawkForceMag > F_MAX) {
            hawkForceX = (hawkForceX / hawkForceMag) * F_MAX;
            hawkForceY = (hawkForceY / hawkForceMag) * F_MAX;
          }

          // Apply forces
          particle.vx += hawkForceX * FORCE_MULTIPLIER * simulationDt;
          particle.vy += hawkForceY * FORCE_MULTIPLIER * simulationDt;

          // Update position
          particle.x += particle.vx * simulationDt;
          particle.y += particle.vy * simulationDt;

          // Bounce off walls (width and height already declared above)
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx;
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx;
          }

          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy;
          } else if (particle.y + particle.height > height) {
            particle.y = height - particle.height;
            particle.vy = -particle.vy;
          }

          // Update visual position
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

          // Store hawk info for fear calculations
          hawkInfos.push({
            x: centerX,
            y: centerY,
            vx: particle.vx,
            vy: particle.vy,
            speed: currentSpeed
          });

          return;  // Skip boid forces
        }

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;

        // Accumulate total force
        let totalForceX = 0;
        let totalForceY = 0;

        // Fear force from all hawks
        let isFearful = false;
        hawkInfos.forEach(hawkInfo => {
          if (hawkInfo.speed > 0) {
            const toHawkX = hawkInfo.x - centerX;
            const toHawkY = hawkInfo.y - centerY;
            const distToHawk = Math.sqrt(toHawkX * toHawkX + toHawkY * toHawkY);

            // Check if boid is in front of hawk (dot product > 0)
            const toBoidX = centerX - hawkInfo.x;
            const toBoidY = centerY - hawkInfo.y;
            const dotProduct = toBoidX * hawkInfo.vx + toBoidY * hawkInfo.vy;

            if (distToHawk < FEAR_DIST && dotProduct > 0) {
              // Boid feels fear!
              isFearful = true;

              // Calculate perpendicular direction away from ray
              const dirX = hawkInfo.vx / hawkInfo.speed;
              const dirY = hawkInfo.vy / hawkInfo.speed;

              // Project boid position onto ray
              const projection = toBoidX * dirX + toBoidY * dirY;
              const rayPointX = hawkInfo.x + projection * dirX;
              const rayPointY = hawkInfo.y + projection * dirY;

              // Direction from ray to boid (perpendicular escape direction)
              const perpX = centerX - rayPointX;
              const perpY = centerY - rayPointY;
              const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

              if (perpDist > 0) {
                const fearMagnitude = F_FEAR * (1 - distToHawk / FEAR_DIST);

                // Blend perpendicular direction with "away from hawk" for 70 degree angle
                const perpNormX = perpX / perpDist;
                const perpNormY = perpY / perpDist;
                const awayNormX = -dirX;  // Opposite of hawk direction
                const awayNormY = -dirY;

                // sin(70°) ≈ 0.94, cos(70°) ≈ 0.34
                const fearDirX = 0.94 * perpNormX + 0.34 * awayNormX;
                const fearDirY = 0.94 * perpNormY + 0.34 * awayNormY;

                // Normalize the blended direction
                const fearDirMag = Math.sqrt(fearDirX * fearDirX + fearDirY * fearDirY);
                if (fearDirMag > 0) {
                  particle.forces.fear.x += (fearDirX / fearDirMag) * fearMagnitude;
                  particle.forces.fear.y += (fearDirY / fearDirMag) * fearMagnitude;
                  totalForceX += (fearDirX / fearDirMag) * fearMagnitude;
                  totalForceY += (fearDirY / fearDirMag) * fearMagnitude;
                }
              }
            }
          }
        });

        // Get particle's grid cell
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);

        // Find distances to particles in nearby cells (3x3 neighborhood)
        const distances = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${cellX + dx},${cellY + dy}`;
            const cellParticles = grid.get(key);
            if (!cellParticles) continue;

            cellParticles.forEach(j => {
              if (i === j) return;

              const other = particles[j];
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              const deltaX = otherCenterX - centerX;
              const deltaY = otherCenterY - centerY;
              const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

              distances.push({
                index: j,
                dist: dist,
                dx: deltaX,
                dy: deltaY,
                x: otherCenterX,
                y: otherCenterY
              });

              // Repulsion force (only for close neighbors) - 1/r form with offset
              if (dist <= R_REPULSION && dist > 0) {
                const normalizedDist = dist / LENGTH_SCALE;
                const repulsionMag = F_REPULSION * (1 - normalizedDist);
                particle.forces.repulsion.x -= (deltaX / dist) * repulsionMag;  // Negative = repulsion
                particle.forces.repulsion.y -= (deltaY / dist) * repulsionMag;
                totalForceX -= (deltaX / dist) * repulsionMag;
                totalForceY -= (deltaY / dist) * repulsionMag;
              }
            });
          }
        }

        // Sort by distance and take 5 nearest
        distances.sort((a, b) => a.dist - b.dist);
        const nearest5 = distances.slice(0, 5);

        // Calculate average position of 5 nearest neighbors
        let avgX = 0, avgY = 0;
        nearest5.forEach(n => {
          avgX += n.x;
          avgY += n.y;
        });
        avgX /= nearest5.length;
        avgY /= nearest5.length;

        // Cohesion force: magnitude 1 towards average position
        const dx = avgX - centerX;
        const dy = avgY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          particle.forces.cohesion.x = (dx / dist) * 1.0;
          particle.forces.cohesion.y = (dy / dist) * 1.0;
          totalForceX += particle.forces.cohesion.x;
          totalForceY += particle.forces.cohesion.y;
        }

        // Alignment force: magnitude F_ALIGN in direction of average velocity
        let avgVx = 0, avgVy = 0;
        nearest5.forEach(n => {
          const neighbor = particles[n.index];
          avgVx += neighbor.vx;
          avgVy += neighbor.vy;
        });
        avgVx /= nearest5.length;
        avgVy /= nearest5.length;

        const avgVelMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
        if (avgVelMag > 0) {
          particle.forces.alignment.x = (avgVx / avgVelMag) * F_ALIGN;
          particle.forces.alignment.y = (avgVy / avgVelMag) * F_ALIGN;
          totalForceX += particle.forces.alignment.x;
          totalForceY += particle.forces.alignment.y;
        }

        // Speed stabilization force
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (currentSpeed > 0) {
          const speedRatio = 1 - currentSpeed / TARGET_SPEED;
          const speedForceMag = F_SPEEDSTABILITY * Math.pow(speedRatio, 3);
          particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
          particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
          totalForceX += particle.forces.speedStab.x;
          totalForceY += particle.forces.speedStab.y;
        }

        // Wall repulsion forces
        const width = window.innerWidth;
        const height = window.innerHeight;

        let wallForceX = 0;
        let wallForceY = 0;

        // Left wall
        const distLeft = centerX;
        if (distLeft < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distLeft / WALL_REPULSION_DIST);
          wallForceX += wallForceMag;  // Push right
        }

        // Right wall
        const distRight = width - centerX;
        if (distRight < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distRight / WALL_REPULSION_DIST);
          wallForceX -= wallForceMag;  // Push left
        }

        // Top wall
        const distTop = centerY;
        if (distTop < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distTop / WALL_REPULSION_DIST);
          wallForceY += wallForceMag;  // Push down
        }

        // Bottom wall
        const distBottom = height - centerY;
        if (distBottom < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distBottom / WALL_REPULSION_DIST);
          wallForceY -= wallForceMag;  // Push up
        }

        particle.forces.wallRepulsion.x = wallForceX;
        particle.forces.wallRepulsion.y = wallForceY;
        totalForceX += wallForceX;
        totalForceY += wallForceY;

        // Clamp force to F_MAX
        const totalForceMag = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
        if (totalForceMag > F_MAX) {
          totalForceX = (totalForceX / totalForceMag) * F_MAX;
          totalForceY = (totalForceY / totalForceMag) * F_MAX;
        }

        // Apply total force with global multiplier
        particle.vx += totalForceX * FORCE_MULTIPLIER * simulationDt;
        particle.vy += totalForceY * FORCE_MULTIPLIER * simulationDt;

        // Limit speed
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed > MAX_SPEED) {
          particle.vx = (particle.vx / speed) * MAX_SPEED;
          particle.vy = (particle.vy / speed) * MAX_SPEED;
        }

        // Update position
        particle.x += particle.vx * simulationDt;
        particle.y += particle.vy * simulationDt;

        // Bounce off edges with perfect reflection (no energy loss)
        // (width and height already declared above for wall repulsion)

        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx;
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx;
        }

        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height + 7) {
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy;
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Keep dormant hawks at their original position
      particles.forEach(particle => {
        if (particle.isHawk && !particle.isActive) {
          particle.x = particle.originalX;
          particle.y = particle.originalY;
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      });

      // Draw force vectors for debug visualization
      if (DRAW_FORCES) {
        // Clear previous arrows
        while (forceVectorsSvg.firstChild) {
          forceVectorsSvg.removeChild(forceVectorsSvg.firstChild);
        }

        // Draw force vectors for each active particle
        particles.forEach(particle => {
          if (!particle.isActive || !particle.forces) return;

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Define force colors
          const forceColors = {
            repulsion: '#ff0000',       // Red (boid-boid repulsion)
            cohesion: '#0000ff',        // Blue
            alignment: '#00ff00',       // Green
            speedStab: '#00ffff',       // Cyan
            wallRepulsion: '#ff8800',   // Orange
            fear: '#ff00ff',            // Magenta
            boidAttr: '#ffff00',        // Yellow (hawk attraction to boids)
            hawkRepulsion: '#ff69b4'    // Pink (hawk-hawk repulsion)
          };

          // Draw each force type
          Object.entries(particle.forces).forEach(([forceType, force]) => {
            if (!forceColors[forceType]) return;

            const arrow = createArrow(centerX, centerY, force.x, force.y, forceColors[forceType]);
            if (arrow) {
              forceVectorsSvg.appendChild(arrow.line);
              forceVectorsSvg.appendChild(arrow.arrowhead);
            }
          });
        });
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // INITIALIZATION
  // ============================================================================
</script>

<script>
  // ============================================================================
  // PANIC MODE
  // ============================================================================

  let panicTextWrapped = false;
  let alarmAudio = null;
  let screamAudio = null;

  function enterPanicMode() {
    if (panicActive) return;
    panicActive = true;

    // Wrap text if not already wrapped by other modes
    if (!textWrapped && !panicTextWrapped) {
      panicTextWrapped = true;
      wrapTextNodes(document.body);
    }

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('panic-locked');
    document.body.style.top = `-${scrollY}px`;

    // Start alarm sound immediately
    const alarm = document.getElementById('panic-alarm');
    if (alarm) {
      alarmAudio = alarm;
      alarmAudio.loop = true;
      alarmAudio.currentTime = 0;
      alarmAudio.play();
    }

    // Start crowd scream after 2 seconds (when movement begins)
    setTimeout(() => {
      if (panicActive) {
        const scream = document.getElementById('panic-scream');
        if (scream) {
          screamAudio = scream;
          screamAudio.loop = true;
          screamAudio.currentTime = 0;
          screamAudio.play();
        }
      }
    }, 2000);

    // Create persistent flashing "PANIC MODE" text
    const panicLabel = document.createElement('div');
    panicLabel.id = 'panic-mode-label';
    panicLabel.textContent = 'PANIC MODE';
    panicLabel.style.position = 'fixed';
    panicLabel.style.top = '50%';
    panicLabel.style.left = '50%';
    panicLabel.style.transform = 'translate(-50%, -50%)';
    panicLabel.style.fontSize = '48px';
    panicLabel.style.fontFamily = 'Courier New, monospace';
    panicLabel.style.fontWeight = 'bold';
    panicLabel.style.letterSpacing = '4px';
    panicLabel.style.color = '#ff0000';
    panicLabel.style.textShadow = '0 0 10px #ff0000, 0 0 20px #ff0000';
    panicLabel.style.zIndex = '99999';
    panicLabel.style.pointerEvents = 'none';
    panicLabel.style.textAlign = 'center';
    document.body.appendChild(panicLabel);

    // Flash on/off every 0.51 seconds
    const flashInterval = setInterval(() => {
      if (!panicActive) {
        clearInterval(flashInterval);
        panicLabel.remove();
        return;
      }
      panicLabel.style.visibility = panicLabel.style.visibility === 'hidden' ? 'visible' : 'hidden';
    }, 510);

    const particles = [];

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startPanicAnimation(particles, scrollY);
  }

  function startPanicAnimation(particles, originalScrollY) {
    const DELAY_TIME = 2000; // 2 seconds delay before movement
    const MOVEMENT_TIME = 7800; // 7.8 seconds of movement
    const TOTAL_TIME = DELAY_TIME + MOVEMENT_TIME; // 9.8 seconds total
    const startTime = performance.now();

    function animate(currentTime) {
      if (!panicActive) return;

      // Calculate elapsed time in milliseconds
      const elapsed = currentTime - startTime;

      // Check if 9.8 seconds have elapsed
      if (elapsed >= TOTAL_TIME) {
        exitPanicMode(particles, originalScrollY);
        return;
      }

      // Calculate t as fraction of movement time (0 to 1)
      // During the first 2 seconds (delay), t = 0 (no movement)
      let t = 0;
      if (elapsed > DELAY_TIME) {
        t = (elapsed - DELAY_TIME) / MOVEMENT_TIME;
      }

      particles.forEach(particle => {
        // Epicycle parameterization: sum of circles at different frequencies
        // x(t) = sum_j r_j * cos(2π * j * t + theta_j) - offset_x
        // y(t) = sum_j r_j * sin(2π * j * t + theta_j) - offset_y
        let dx = 0;
        let dy = 0;

        for (let j = 0; j < particle.radii.length; j++) {
          const freq = j + 1; // Frequency is 1, 2, 3, ...
          const angle = 2 * Math.PI * freq * t * particle.signs[j] + particle.thetas[j];
          dx += particle.radii[j] * Math.cos(angle);
          dy += particle.radii[j] * Math.sin(angle);
        }

        // Subtract offsets to ensure path starts at origin
        dx -= particle.offset_x;
        dy -= particle.offset_y;

        // Apply radial coefficient to make letters drift farther over time
        // radial_coeff = max(1, elapsed_in_seconds + 2 - TOTAL_TIME_in_seconds)
        const elapsed_seconds = elapsed / 1000;
        const total_seconds = TOTAL_TIME / 1000;
        const radial_coeff = Math.max(1, elapsed_seconds + 2 - total_seconds);
        dx *= radial_coeff;
        dy *= radial_coeff;

        // Calculate current position (original position + offset)
        const x = particle.x0 + dx;
        const y = particle.y0 + dy;

        // Apply transform (relative to the element's original left/top)
        particle.el.style.transform = `translate(${x - parseFloat(particle.el.style.left)}px, ${y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  function exitPanicMode(particles, originalScrollY) {
    panicActive = false;

    // Stop and clean up audio
    if (alarmAudio) {
      alarmAudio.pause();
      alarmAudio.currentTime = 0;
      alarmAudio = null;
    }
    if (screamAudio) {
      screamAudio.pause();
      screamAudio.currentTime = 0;
      screamAudio = null;
    }

    // Remove all particles
    particles.forEach(particle => {
      particle.el.remove();
    });

    // Remove flashing label
    const panicLabel = document.getElementById('panic-mode-label');
    if (panicLabel) {
      panicLabel.remove();
    }

    // Restore original characters
    document.querySelectorAll('.char').forEach(char => {
      char.style.visibility = '';
    });

    // Restore original glyphs
    document.querySelectorAll('i, svg').forEach(glyph => {
      glyph.style.visibility = '';
    });

    // Unlock body
    document.body.classList.remove('panic-locked');
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.left = '';
    document.body.style.right = '';
    document.body.style.overflow = '';
    document.body.style.width = '';
    window.scrollTo(0, originalScrollY);
  }
</script>

<script>
  // ============================================================================
  // NAVIGATION AND MYSTERY BUTTON LOGIC
  // ============================================================================

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    // Add mysterious glyphs to navbar
    const navList = document.querySelector('nav ul.navbar-nav');
    if (navList) {
      // Single question mark icon that randomly picks a mode
      const mysteryLi = document.createElement('li');
      mysteryLi.className = 'nav-item active';

      const mysteryLink = document.createElement('a');
      mysteryLink.className = 'nav-link';
      mysteryLink.style.cursor = 'pointer';
      mysteryLink.href = '#';

      const mysteryIcon = document.createElement('i');
      mysteryIcon.className = 'fas fa-question-circle';

      mysteryLink.appendChild(mysteryIcon);
      mysteryLi.appendChild(mysteryLink);

      mysteryLink.addEventListener('click', (e) => {
        e.preventDefault();

        // Check if on mobile device
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const isSmallScreen = window.innerWidth < 1024;
        const isMobile = isTouchDevice && isSmallScreen;

        // Check localStorage for click count
        let clickCount = parseInt(localStorage.getItem('mysteryButtonClicks') || '0');

        // If user hasn't clicked 3 times yet, show warning and increment
        if (clickCount < 3) {
          const messages = ["Hey, stop that!", "Can't you read?", "I'm serious!"];
          alert(messages[clickCount]);
          clickCount++;
          localStorage.setItem('mysteryButtonClicks', clickCount.toString());
          return; // Don't activate mode
        }

        // After 3 clicks, cycle through modes sequentially
        // Define the rotation order (skip gravity, vacuum, pong on mobile)
        const modeSequence = isMobile
          ? ['shatter', 'bird', 'splash', 'panic']
          : ['shatter', 'gravity', 'bird', 'splash', 'vacuum', 'panic', 'pong'];

        // Get current mode index with error handling
        let modeIndex = 0;
        try {
          const storedIndex = localStorage.getItem('mysteryModeIndex');
          if (storedIndex !== null) {
            const parsed = parseInt(storedIndex);
            // Validate the index is within bounds
            if (!isNaN(parsed) && parsed >= 0 && parsed < modeSequence.length) {
              modeIndex = parsed;
            } else {
              // Invalid index, reset to 0
              console.warn('Invalid mysteryModeIndex, resetting to 0');
              modeIndex = 0;
            }
          }
        } catch (e) {
          console.error('Error reading mysteryModeIndex:', e);
          modeIndex = 0;
        }

        // Get the current mode
        const currentMode = modeSequence[modeIndex];

        // Increment and save the next index (with wraparound)
        const nextIndex = (modeIndex + 1) % modeSequence.length;
        try {
          localStorage.setItem('mysteryModeIndex', nextIndex.toString());
        } catch (e) {
          console.error('Error saving mysteryModeIndex:', e);
        }

        // Reset button appearance (remove hover state)
        mysteryLink.blur();
        mysteryLink.style.setProperty('background-color', '', 'important');
        mysteryLink.style.setProperty('color', '', 'important');
        mysteryIcon.style.setProperty('color', 'black', 'important');

        // Activate the selected mode with error handling
        try {
          switch(currentMode) {
            case 'shatter':
              if (typeof enterShatterMode === 'function') {
                enterShatterMode();
              } else {
                console.error('enterShatterMode is not defined');
              }
              break;
            case 'gravity':
              if (typeof enterGravityMode === 'function') {
                enterGravityMode();
              } else {
                console.error('enterGravityMode is not defined');
              }
              break;
            case 'bird':
              if (typeof enterBirdMode === 'function') {
                enterBirdMode();
              } else {
                console.error('enterBirdMode is not defined');
              }
              break;
            case 'splash':
              window.location.href = '/splash/';
              break;
            case 'vacuum':
              if (typeof enterVacuumMode === 'function') {
                enterVacuumMode();
              } else {
                console.error('enterVacuumMode is not defined');
              }
              break;
            case 'panic':
              if (typeof enterPanicMode === 'function') {
                enterPanicMode();
              } else {
                console.error('enterPanicMode is not defined');
              }
              break;
            case 'pong':
              if (typeof enterPongMode === 'function') {
                enterPongMode();
              } else {
                console.error('enterPongMode is not defined');
              }
              break;
            default:
              console.error('Unknown mode:', currentMode);
          }
        } catch (e) {
          console.error('Error activating mode:', currentMode, e);
        }
      });

      navList.appendChild(mysteryLi);

      /* DEBUG VERSION: Uncomment to show all five icons for debugging
      // Shatter mode icon (question mark)
      const shatterLi = document.createElement('li');
      shatterLi.className = 'nav-item active';

      const shatterLink = document.createElement('a');
      shatterLink.className = 'nav-link';
      shatterLink.style.cursor = 'pointer';
      shatterLink.href = '#';

      const shatterIcon = document.createElement('i');
      shatterIcon.className = 'fas fa-question-circle';

      shatterLink.appendChild(shatterIcon);
      shatterLi.appendChild(shatterLink);

      shatterLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterShatterMode();
      });

      navList.appendChild(shatterLi);

      // Gravity mode icon (magnet)
      const gravityLi = document.createElement('li');
      gravityLi.className = 'nav-item active';

      const gravityLink = document.createElement('a');
      gravityLink.className = 'nav-link';
      gravityLink.style.cursor = 'pointer';
      gravityLink.href = '#';

      const gravityIcon = document.createElement('i');
      gravityIcon.className = 'fas fa-magnet';

      gravityLink.appendChild(gravityIcon);
      gravityLi.appendChild(gravityLink);

      gravityLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterGravityMode();
      });

      navList.appendChild(gravityLi);

      // Vacuum mode icon (meteor)
      const vacuumLi = document.createElement('li');
      vacuumLi.className = 'nav-item active';

      const vacuumLink = document.createElement('a');
      vacuumLink.className = 'nav-link';
      vacuumLink.style.cursor = 'pointer';
      vacuumLink.href = '#';

      const vacuumIcon = document.createElement('i');
      vacuumIcon.className = 'fas fa-meteor';

      vacuumLink.appendChild(vacuumIcon);
      vacuumLi.appendChild(vacuumLink);

      vacuumLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterVacuumMode();
      });

      navList.appendChild(vacuumLi);

      // Splash page link icon (home)
      const splashLi = document.createElement('li');
      splashLi.className = 'nav-item active';

      const splashLink = document.createElement('a');
      splashLink.className = 'nav-link';
      splashLink.style.cursor = 'pointer';
      splashLink.href = '/splash/';

      const splashIcon = document.createElement('i');
      splashIcon.className = 'fas fa-home';

      splashLink.appendChild(splashIcon);
      splashLi.appendChild(splashLink);

      navList.appendChild(splashLi);

      // Pong mode icon (gamepad)
      const pongLi = document.createElement('li');
      pongLi.className = 'nav-item active';

      const pongLink = document.createElement('a');
      pongLink.className = 'nav-link';
      pongLink.style.cursor = 'pointer';
      pongLink.href = '#';

      const pongIcon = document.createElement('i');
      pongIcon.className = 'fas fa-gamepad';

      pongLink.appendChild(pongIcon);
      pongLi.appendChild(pongLink);

      pongLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterPongMode();
      });

      navList.appendChild(pongLi);
      */
    }
  });
</script>



    <div class="page-content" style="flex: 1 0 auto;">
      <div class="wrapper">
        <div class="container">
  <h1 style="margin-top: 1em;">Level 3</h1>

  <!-- Debug elements (hidden) -->
  <div id="phaseIndicator" style="display: none; font-family: 'Gill Sans', sans-serif; font-size: 20px; font-weight: bold; margin-bottom: 10px; padding: 10px; background: #f0f0f0; border-radius: 5px;">Phase: Initializing...</div>

  <div style="position: relative; width: 100%; max-width: 1200px;">
    <button id="resetButton" style="position: absolute; top: -45px; right: 0; padding: 6px 14px; font-family: 'Gill Sans', sans-serif; font-size: 16px; background-color: white; color: black; border: 2px solid #ccc; border-radius: 4px; cursor: pointer;">reset</button>
    <canvas id="graphCanvas" width="1200" height="800" style="border: 1px solid #ccc; display: block; width: 100%;"></canvas>
  </div>
  <div id="frameCounter" style="display: none; position: absolute; top: 100px; left: 20px; font-family: 'Gill Sans', sans-serif; font-size: 16px; background: rgba(255,255,255,0.7); padding: 5px;">Frame: 0</div>

  <div style="margin-top: 20px;">
    <input type="text" id="guessInput" placeholder="Type a guess and press Enter" style="width: 400px; padding: 10px; font-size: 16px; font-family: 'Gill Sans', sans-serif;">
    <div id="feedback" style="margin-top: 10px; font-size: 16px; font-family: 'Gill Sans', sans-serif;"></div>
  </div>
</div>

<script>
  // Seeded random number generator (mulberry32)
  function createSeededRandom(seed) {
    return function() {
      seed |= 0;
      seed = seed + 0x6D2B79F5 | 0;
      let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  // Box-Muller transform for normal distribution
  function createNormalRandom(randomFunc) {
    let spare = null;
    return function(mean = 0, stddev = 1) {
      if (spare !== null) {
        const result = spare * stddev + mean;
        spare = null;
        return result;
      }
      const u1 = randomFunc();
      const u2 = randomFunc();
      const r = Math.sqrt(-2 * Math.log(u1));
      const theta = 2 * Math.PI * u2;
      spare = r * Math.sin(theta);
      return r * Math.cos(theta) * stddev + mean;
    };
  }

  // Parse the network puzzle data file
  function loadAndDrawGraph() {
    // Embed the file content directly via Jekyll
    const text = `house<-town
house<-full
house->fly
house->keeping
house<->boat
boat<-paper
boat<-tug
boat<-fishing
fly->fishing
fishing->trip
horse->fly
fly->paper
horse<->race
boat->race
paper->clip
paper->plane
rice->paper
horse<-dark
horse->power
race->track
race<-rat

given: [leaves]

random seed: 17

name: Level 3
`;

    // Parse the file
    const lines = text.trim().split('\n');
    const edges = [];
    const nodes = new Set();
    let givenWordsRaw = ''; // Store raw string for processing later
    let randomSeed = 42; // Default seed
    let puzzleName = 'Level 3'; // Default from page front matter
    let gimmick = ''; // Store gimmick type

    lines.forEach(line => {
      const trimmedLine = line.trim();

      // Check if this is the "given:" line
      if (trimmedLine.startsWith('given:')) {
        givenWordsRaw = trimmedLine.substring(6).trim(); // Remove "given:" and store raw
        return;
      }

      // Check if this is the "random seed:" line
      if (trimmedLine.startsWith('random seed:')) {
        const seedString = trimmedLine.substring(12).trim(); // Remove "random seed:"
        randomSeed = parseInt(seedString, 10);
        return;
      }

      // Check if this is the "name:" line (can override page title)
      if (trimmedLine.startsWith('name:')) {
        const nameString = trimmedLine.substring(5).trim(); // Remove "name:"
        puzzleName = nameString;
        return;
      }

      // Check if this is the "gimmick:" line
      if (trimmedLine.startsWith('gimmick:')) {
        gimmick = trimmedLine.substring(8).trim(); // Remove "gimmick:"
        return;
      }

      // Skip empty lines
      if (trimmedLine === '') return;

      // Parse edge with direction indicator
      let word1, word2, direction;

      if (trimmedLine.includes('~')) {
        // Anagram (bidirectional, special drawing)
        const parts = trimmedLine.split('~');
        word1 = parts[0].trim();
        word2 = parts[1].trim();
        direction = 'anagram';
      } else if (trimmedLine.includes('<->')) {
        // Bidirectional
        const parts = trimmedLine.split('<->');
        word1 = parts[0].trim();
        word2 = parts[1].trim();
        direction = 'bidirectional';
      } else if (trimmedLine.includes('->')) {
        // Forward arrow
        const parts = trimmedLine.split('->');
        word1 = parts[0].trim();
        word2 = parts[1].trim();
        direction = 'forward';
      } else if (trimmedLine.includes('<-')) {
        // Backward arrow
        const parts = trimmedLine.split('<-');
        word1 = parts[0].trim();
        word2 = parts[1].trim();
        direction = 'backward';
      } else if (trimmedLine.includes('-')) {
        // Undirected (hyphen separator)
        const parts = trimmedLine.split('-');
        word1 = parts[0].trim();
        word2 = parts[1].trim();
        direction = 'none';
      } else {
        // Undirected (space separator)
        const parts = trimmedLine.split(' ');
        if (parts.length >= 2) {
          let splitIndex = parts.length - 1;
          word1 = parts.slice(0, splitIndex).join(' ');
          word2 = parts[splitIndex];
          direction = 'none';
        } else {
          return; // Invalid format
        }
      }

      if (word1 && word2) {
        nodes.add(word1);
        nodes.add(word2);
        edges.push({ from: word1, to: word2, direction: direction });
      }
    });

    // Create seeded random function
    const seededRandom = createSeededRandom(randomSeed);
    const normalRandom = createNormalRandom(seededRandom);

    // Update page title with puzzle name (if overridden in data file)
    const titleElement = document.querySelector('h1');
    if (titleElement) {
      titleElement.textContent = puzzleName;
    }

    // Convert nodes to array and assign random initial positions
    const nodeArray = Array.from(nodes);
    const nodePositions = {};

    // Build adjacency list for connectedness calculation (needed before checking leaves)
    const adjacencyList = {};
    nodeArray.forEach(node => {
      adjacencyList[node] = new Set();
    });
    edges.forEach(edge => {
      adjacencyList[edge.from].add(edge.to);
      adjacencyList[edge.to].add(edge.from); // Undirected for color purposes
    });

    // Process given words specification
    const guessedWords = new Set();
    let allWordsGiven = false;
    let leavesGiven = false;
    let givenWords = [];

    if (givenWordsRaw === '[all]') {
      // Add all nodes as given words
      allWordsGiven = true;
      nodeArray.forEach(node => guessedWords.add(node));
    } else if (givenWordsRaw === '[leaves]') {
      // Add only leaf nodes (nodes with exactly one connection) as given words
      leavesGiven = true;
      nodeArray.forEach(node => {
        if (adjacencyList[node].size === 1) {
          guessedWords.add(node);
        }
      });
      // Store all given words for isGivenWord checks
      givenWords = Array.from(guessedWords);
    } else if (givenWordsRaw.startsWith('[leaves] +')) {
      // [leaves] plus additional words: "[leaves] + word1, word2, word3"
      leavesGiven = true;
      const additionalPart = givenWordsRaw.substring(11).trim(); // Remove "[leaves] +"
      const additionalWords = additionalPart.split(',').map(w => w.trim());
      const nodeSet = new Set(nodeArray);

      nodeArray.forEach(node => {
        if (adjacencyList[node].size === 1) {
          guessedWords.add(node);
        }
      });

      additionalWords.forEach(word => {
        if (nodeSet.has(word)) {
          guessedWords.add(word);
        }
      });

      // Store all given words for isGivenWord checks
      givenWords = Array.from(guessedWords);
    } else if (givenWordsRaw.startsWith('[all] -')) {
      // [all] minus excluded words: "[all] - word1, word2, word3"
      const excludedPart = givenWordsRaw.substring(7).trim(); // Remove "[all] -"
      const excludedWords = new Set(excludedPart.split(',').map(w => w.trim()));
      nodeArray.forEach(node => {
        if (!excludedWords.has(node)) {
          guessedWords.add(node);
        }
      });
      // Store the actual given words for isGivenWord checks
      givenWords = nodeArray.filter(node => !excludedWords.has(node));
    } else {
      // Parse as comma-separated list of specific words
      givenWords = givenWordsRaw.split(',').map(w => w.trim());
      const nodeSet = new Set(nodeArray);
      givenWords.forEach(word => {
        if (nodeSet.has(word)) {
          guessedWords.add(word);
        }
      });
    }

    // Load saved progress from localStorage
    const STORAGE_KEY = 'network_puzzle_Level 3_guessed';
    try {
      const savedProgress = localStorage.getItem(STORAGE_KEY);
      if (savedProgress) {
        const savedWords = JSON.parse(savedProgress);
        const nodeSet = new Set(nodeArray);
        savedWords.forEach(word => {
          if (nodeSet.has(word)) {
            guessedWords.add(word);
          }
        });
      }
    } catch (e) {
      console.error('Error loading saved progress:', e);
    }

    // Track if puzzle was already complete on page load
    const wasAlreadyComplete = guessedWords.size === nodeArray.length;

    const canvas = document.getElementById('graphCanvas');
    const width = canvas.width;
    const height = canvas.height;
    const margin = 50;

    // Calculate average number of neighbors
    const q = nodeArray.reduce((sum, node) => sum + adjacencyList[node].size, 0) / nodeArray.length;

    // Calculate connectedness factor for each node
    const connectednessFactors = {};
    const neighborCounts = {};
    nodeArray.forEach(node => {
      // Primary neighbors (1-hop)
      const primary = adjacencyList[node];
      const primaryCount = primary.size;

      // Secondary neighbors (2-hop)
      const secondary = new Set();
      primary.forEach(neighbor => {
        adjacencyList[neighbor].forEach(n => {
          if (n !== node && !primary.has(n)) {
            secondary.add(n);
          }
        });
      });
      const secondaryCount = secondary.size;

      // Tertiary neighbors (3-hop)
      const tertiary = new Set();
      secondary.forEach(neighbor => {
        adjacencyList[neighbor].forEach(n => {
          if (n !== node && !primary.has(n) && !secondary.has(n)) {
            tertiary.add(n);
          }
        });
      });
      const tertiaryCount = tertiary.size;

      // Store neighbor counts for debugging
      neighborCounts[node] = {
        primary: primaryCount,
        secondary: secondaryCount,
        tertiary: tertiaryCount
      };

      // Calculate connectedness factor
      connectednessFactors[node] =
        primaryCount / q +
        secondaryCount * 0.5 / (q * q) +
        tertiaryCount * 0.2 / (q * q * q);
    });

    // Normalize connectedness factors to [0, 1]
    const cfValues = Object.values(connectednessFactors);
    const minCF = Math.min(...cfValues);
    const maxCF = Math.max(...cfValues);
    const cfRange = maxCF - minCF;

    const normalizedCF = {};
    nodeArray.forEach(node => {
      normalizedCF[node] = cfRange > 0 ? (connectednessFactors[node] - minCF) / cfRange : 0;
    });

    // HSV to RGB conversion
    function hsvToRgb(h, s, v) {
      const c = v * s;
      const x = c * (1 - Math.abs((h * 6) % 2 - 1));
      const m = v - c;

      let r, g, b;
      if (h < 1/6) { r = c; g = x; b = 0; }
      else if (h < 2/6) { r = x; g = c; b = 0; }
      else if (h < 3/6) { r = 0; g = c; b = x; }
      else if (h < 4/6) { r = 0; g = x; b = c; }
      else if (h < 5/6) { r = x; g = 0; b = c; }
      else { r = c; g = 0; b = x; }

      return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
      };
    }

    // Hash function for strings (simple but deterministic)
    function hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
      }
      return Math.abs(hash);
    }

    // Check if a node is a given word
    function isGivenWord(node) {
      if (allWordsGiven) return true;
      // Check the givenWords array (covers all cases including [leaves] + additions)
      return givenWords.includes(node);
    }

    // Get color for a node
    function getNodeColor(node) {
      // If [all] was given, all words are white
      if (allWordsGiven) {
        return '#ffffff'; // White
      }

      // Check if this word was guessed (and not a given word)
      if (guessedWords.has(node) && !isGivenWord(node)) {
        // Generate deterministic hue from word hash
        const hash = hashString(node);
        const hue = (hash % 360) / 360; // Convert to [0, 1] range
        const rgb = hsvToRgb(hue, 0.3, 1.0); // Pastel: low saturation, high value
        return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
      } else {
        return '#ffffff'; // White
      }
    }

    // Calculate scale factor based on number of words
    const numWords = nodeArray.length;
    let scaleFactor = 1.4;
    if (numWords > 20) {
      scaleFactor = 1.4 * Math.sqrt(20 / numWords);
    }

    // Calculate uniform box size based on longest word and individual sizes
    const ctx = canvas.getContext('2d');
    const baseFontSize = 24;
    const fontSize = Math.round(baseFontSize * scaleFactor);
    ctx.font = `${fontSize}px "Gill Sans", sans-serif`;
    let maxTextWidth = 0;
    const nodeTextWidths = {};
    nodeArray.forEach(node => {
      const textWidth = ctx.measureText(node).width;
      nodeTextWidths[node] = textWidth;
      if (textWidth > maxTextWidth) maxTextWidth = textWidth;
    });
    const BOX_HEIGHT = 36 * scaleFactor;
    const BOX_PADDING = 16 * scaleFactor;
    const UNIFORM_BOX_HEIGHT = BOX_HEIGHT;
    const UNIFORM_BOX_WIDTH = UNIFORM_BOX_HEIGHT * 2.5; // Fixed aspect ratio of 2.5:1

    // Function to get box dimensions for a node
    function getBoxDimensions(node) {
      if (guessedWords.has(node)) {
        return {
          width: nodeTextWidths[node] + BOX_PADDING,
          height: BOX_HEIGHT
        };
      } else {
        return {
          width: UNIFORM_BOX_WIDTH,
          height: UNIFORM_BOX_HEIGHT
        };
      }
    }

    // Function to calculate minimum distance between two rectangles in 3D
    // Rectangles are flat (2D) but embedded in 3D space
    function rectToRectDistance3D(x1, y1, z1, w1, h1, x2, y2, z2, w2, h2) {
      const hw1 = w1 / 2;
      const hh1 = h1 / 2;
      const hw2 = w2 / 2;
      const hh2 = h2 / 2;

      // Distance between edges in 2D plane
      const dx2D = Math.max(0, Math.abs(x2 - x1) - (hw1 + hw2));
      const dy2D = Math.max(0, Math.abs(y2 - y1) - (hh1 + hh2));
      const dist2D = Math.sqrt(dx2D * dx2D + dy2D * dy2D);

      // Add z-distance
      const dz = z2 - z1;

      return Math.sqrt(dist2D * dist2D + dz * dz);
    }

    // Function to calculate line-rectangle intersection
    function lineRectIntersection(fromX, fromY, toX, toY, rectCenterX, rectCenterY, rectWidth, rectHeight) {
      const dx = toX - fromX;
      const dy = toY - fromY;
      const hw = rectWidth / 2;
      const hh = rectHeight / 2;

      let tMin = Infinity;
      let intersectX = toX;
      let intersectY = toY;

      // Check all four edges
      // Left edge
      if (dx !== 0) {
        const t = (rectCenterX - hw - fromX) / dx;
        if (t > 0) {
          const y = fromY + t * dy;
          if (y >= rectCenterY - hh && y <= rectCenterY + hh && t < tMin) {
            tMin = t;
            intersectX = rectCenterX - hw;
            intersectY = y;
          }
        }
      }

      // Right edge
      if (dx !== 0) {
        const t = (rectCenterX + hw - fromX) / dx;
        if (t > 0) {
          const y = fromY + t * dy;
          if (y >= rectCenterY - hh && y <= rectCenterY + hh && t < tMin) {
            tMin = t;
            intersectX = rectCenterX + hw;
            intersectY = y;
          }
        }
      }

      // Top edge
      if (dy !== 0) {
        const t = (rectCenterY - hh - fromY) / dy;
        if (t > 0) {
          const x = fromX + t * dx;
          if (x >= rectCenterX - hw && x <= rectCenterX + hw && t < tMin) {
            tMin = t;
            intersectX = x;
            intersectY = rectCenterY - hh;
          }
        }
      }

      // Bottom edge
      if (dy !== 0) {
        const t = (rectCenterY + hh - fromY) / dy;
        if (t > 0) {
          const x = fromX + t * dx;
          if (x >= rectCenterX - hw && x <= rectCenterX + hw && t < tMin) {
            tMin = t;
            intersectX = x;
            intersectY = rectCenterY + hh;
          }
        }
      }

      return { x: intersectX, y: intersectY };
    }

    // Force-directed layout parameters
    const REPULSION_FACTOR = 0.1;
    const ATTRACTION_FACTOR = .5;
    const LENGTH_SCALE = 80 * scaleFactor;
    const MAX_REPULSION_DISTANCE = 3 * LENGTH_SCALE;
    const DT = 10;
    const DAMPING = 0.05;
    const PHYSICS_STEPS_PER_FRAME = 100;
    const TARGET_FPS = 50;
    const FRAME_INTERVAL = 1000 / TARGET_FPS; // ~33.33ms
    const PHASE_1_STEPS = 2500;  // 0.5 seconds at 50fps * 100 steps/frame = 2500 steps
    const PHASE_2_STEPS = 5000;  // 1 second total (phase 2 is 0.5 seconds)
    const PHASE_3_STEPS = 10000; // 2 seconds total (phase 3 is 1 second - annealing/dancing)
    const PERTURBATION_STDDEV = 0.5;
    const MAX_VELOCITY = 100;

    let currentIteration = 0;
    let physicsStepCount = 0;
    let maxInitialZ = 0;  // Track max |z| for bounding box squeeze
    const frameCounterEl = document.getElementById('frameCounter');
    const phaseIndicatorEl = document.getElementById('phaseIndicator');
    let lastFrameTime = null;
    let lastRenderTime = null;

    // Initialize node positions with random z-coordinates
    nodeArray.forEach(node => {
      const z = (seededRandom() - 0.5) * 2 * LENGTH_SCALE;  // Random z in [-80, 80]
      nodePositions[node] = {
        x: margin + seededRandom() * (width - 2 * margin),
        y: margin + seededRandom() * (height - 2 * margin),
        z: z,
        vx: 0,
        vy: 0,
        vz: 0
      };
      maxInitialZ = Math.max(maxInitialZ, Math.abs(z));
    });

    // Ripple effect
    const JUMP_TIME = 0.2;

    function startRipple(startNode) {
      // Each ripple gets its own visited set
      const visited = new Set();
      visited.add(startNode);

      // Get neighbors and schedule ripple
      const neighbors = Array.from(adjacencyList[startNode] || []);
      neighbors.forEach(neighbor => {
        if (!visited.has(neighbor)) {
          // Random delay between JUMP_TIME/2 and JUMP_TIME
          const delay = (JUMP_TIME / 2 + Math.random() * (JUMP_TIME / 2)) * 1000; // Convert to ms
          setTimeout(() => {
            rippleToNode(neighbor, visited);
          }, delay);
        }
      });
    }

    function rippleToNode(node, visited) {
      // Check if already rippled in this wave (race condition guard)
      if (visited.has(node)) return;

      // Add to this ripple's visited set
      visited.add(node);

      // Apply perturbation (0.25x of original)
      const pos = nodePositions[node];
      const perturbationStddev = PERTURBATION_STDDEV * 0.25;
      const a = perturbationStddev * scaleFactor * Math.sqrt(3);
      pos.vx += (seededRandom() * 2 * a) - a;
      pos.vy += (seededRandom() * 2 * a) - a;

      // Play tone at 1/4 volume (windchimes effect)
      // Only revealed (non-given) words ring during ripple
      if (guessedWords.has(node) && !isGivenWord(node)) {
        playSound(node, 'positive', 0.05); // 1/4 of 0.2
      }
      // Given and unrevealed words stay silent during ripple

      // Propagate to neighbors
      const neighbors = Array.from(adjacencyList[node] || []);
      neighbors.forEach(neighbor => {
        if (!visited.has(neighbor)) {
          const delay = (JUMP_TIME / 2 + Math.random() * (JUMP_TIME / 2)) * 1000;
          setTimeout(() => {
            rippleToNode(neighbor, visited);
          }, delay);
        }
      });
    }

    // Sound system - structured to easily replace with audio files later
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const NEUTRAL_PITCH = 155.56; // Eb3 (change this single value to shift all tones)

    // Get a word's positive tone from its hash
    // Returns one of 11 tones: neutral, 1 octave up, 2 octaves up,
    // or major pentatonic scale (0, 2, 4, 7, 9 semitones) within these
    function getWordPitch(word) {
      const hash = hashString(word);
      const index = hash % 11;

      // Major pentatonic intervals: 0, 2, 4, 7, 9 semitones
      const pentatonicIntervals = [0, 2, 4, 7, 9];

      // Map index to pitch:
      // 0-4: pentatonic at base octave (NEUTRAL_PITCH)
      // 5-9: pentatonic at 1 octave up (NEUTRAL_PITCH * 2)
      // 10: 2 octaves up (NEUTRAL_PITCH * 4)
      if (index < 5) {
        return NEUTRAL_PITCH * Math.pow(2, pentatonicIntervals[index] / 12);
      } else if (index < 10) {
        return NEUTRAL_PITCH * 2 * Math.pow(2, pentatonicIntervals[index - 5] / 12);
      } else {
        return NEUTRAL_PITCH * 4;
      }
    }

    function playSound(word, type = 'neutral', volume = 0.2) {
      // type can be: 'neutral', 'positive', 'negative'
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);

      const startTime = audioContext.currentTime;

      if (type === 'neutral') {
        // Neutral: single tone
        oscillator.frequency.value = NEUTRAL_PITCH;

        gainNode.gain.setValueAtTime(volume, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.15);

        oscillator.start(startTime);
        oscillator.stop(startTime + 0.15);

      } else if (type === 'positive') {
        // Positive: word's unique tone from major pentatonic
        oscillator.frequency.value = getWordPitch(word);

        gainNode.gain.setValueAtTime(volume, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);

        oscillator.start(startTime);
        oscillator.stop(startTime + 0.4);

        /* Perfect fourth positive tone (nice! keeping for reference)
        const endFreq = NEUTRAL_PITCH * 2; // One octave above neutral = 440 Hz
        const startFreq = endFreq / Math.pow(2, 5/12); // Perfect fourth below

        oscillator.frequency.setValueAtTime(startFreq, startTime);
        oscillator.frequency.setValueAtTime(endFreq, startTime + 0.15);

        gainNode.gain.setValueAtTime(volume, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);

        oscillator.start(startTime);
        oscillator.stop(startTime + 0.4);
        */

      } else if (type === 'negative') {
        // Negative: half step above neutral, jump down to neutral after 0.25s
        const startFreq = NEUTRAL_PITCH * Math.pow(2, 1/12); // Half step up
        const endFreq = NEUTRAL_PITCH;

        oscillator.frequency.setValueAtTime(startFreq, startTime);
        oscillator.frequency.setValueAtTime(endFreq, startTime + 0.25);

        gainNode.gain.setValueAtTime(volume, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.5);

        oscillator.start(startTime);
        oscillator.stop(startTime + 0.5);
      }
    }

    // Set up guess input
    const guessInput = document.getElementById('guessInput');
    const feedbackEl = document.getElementById('feedback');

    // Resume AudioContext on first interaction to avoid delay
    // Also play victory music if puzzle was already complete
    const handleFirstInteraction = () => {
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }

      // Play victory music if puzzle was complete on page load
      if (wasAlreadyComplete) {
        const victoryAudio = new Audio('/audio/chopin_nocturne.mp3');
        victoryAudio.volume = 0.5;
        victoryAudio.play().catch(err => console.log('Victory audio play failed:', err));
      }
    };

    // Listen for any click on the document
    document.addEventListener('click', handleFirstInteraction, { once: true });
    guessInput.addEventListener('focus', handleFirstInteraction, { once: true });

    guessInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const guess = guessInput.value.trim().toLowerCase();
        guessInput.value = '';

        if (guess === '') return;

        // Check if guess matches any word
        let found = false;
        let foundNode = null;
        let alreadyRevealed = false;

        nodeArray.forEach(node => {
          if (node.toLowerCase() === guess) {
            foundNode = node;
            if (!guessedWords.has(node)) {
              guessedWords.add(node);
              found = true;
            } else {
              alreadyRevealed = true;
            }
          }
        });

        // Save progress to localStorage (only if newly found)
        if (found) {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(Array.from(guessedWords)));
          } catch (e) {
            console.error('Error saving progress:', e);
          }
        }

        // Add velocity perturbation if the word exists in the graph
        if (foundNode) {
          const pos = nodePositions[foundNode];
          // For uniform distribution with stddev σ, use uniform[-a, a] where a = σ√3
          // Scale perturbation by scaleFactor for larger puzzles
          // Use half perturbation for already-revealed words, 1.5x for new reveals
          const perturbationStddev = alreadyRevealed ? PERTURBATION_STDDEV / 2 : PERTURBATION_STDDEV * 1.5;
          const a = perturbationStddev * scaleFactor * Math.sqrt(3);
          pos.vx += (seededRandom() * 2 * a) - a;
          pos.vy += (seededRandom() * 2 * a) - a;

          // Play sound
          if (alreadyRevealed) {
            // If it's a revealed word that wasn't given, play its positive tone
            if (isGivenWord(foundNode)) {
              playSound(foundNode, 'neutral');
            } else {
              playSound(foundNode, 'positive');
            }
          } else {
            playSound(foundNode, 'positive');
            // Start ripple effect for new reveals
            startRipple(foundNode);
          }

          // Check if all words are now guessed (victory!)
          if (found && guessedWords.size === nodeArray.length) {
            // Play Chopin Nocturne
            const victoryAudio = new Audio('/audio/chopin_nocturne.mp3');
            victoryAudio.volume = 0.5;
            victoryAudio.play().catch(err => console.log('Victory audio play failed:', err));
          }
        } else {
          // Wrong guess - play negative sound
          playSound('', 'negative');
        }

        // Create new feedback message
        const message = document.createElement('div');
        message.style.marginBottom = '5px';

        if (found) {
          message.textContent = `✓ ${guess}`;
          message.style.color = '#2a9d8f';
        } else if (alreadyRevealed) {
          message.textContent = `${guess} (already revealed)`;
          message.style.color = '#888';
        } else {
          message.textContent = `✗ ${guess}`;
          message.style.color = '#e63946';
        }

        feedbackEl.prepend(message);
      }
    });

    // Set up drag functionality
    let draggedNode = null;

    canvas.addEventListener('mousedown', (e) => {
      // Only allow dragging in phase 4
      if (physicsStepCount < PHASE_3_STEPS) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

      // Check if clicking on a box
      for (const node of nodeArray) {
        const pos = nodePositions[node];
        const box = getBoxDimensions(node);

        if (Math.abs(mouseX - pos.x) <= box.width / 2 &&
            Math.abs(mouseY - pos.y) <= box.height / 2) {
          draggedNode = node;
          canvas.style.cursor = 'grabbing';

          // Play sound when clicking on a box
          // Revealed (non-given) words play their positive tone, others play neutral
          if (guessedWords.has(node) && !isGivenWord(node)) {
            playSound(node, 'positive');
          } else {
            playSound(node, 'neutral');
          }

          break;
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      const mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);

      if (draggedNode) {
        // Update dragged node position
        const pos = nodePositions[draggedNode];
        pos.x = mouseX;
        pos.y = mouseY;
      } else {
        // Show grab cursor when hovering over a box in phase 4
        if (physicsStepCount >= PHASE_3_STEPS) {
          let hovering = false;
          for (const node of nodeArray) {
            const pos = nodePositions[node];
            const box = getBoxDimensions(node);

            if (Math.abs(mouseX - pos.x) <= box.width / 2 &&
                Math.abs(mouseY - pos.y) <= box.height / 2) {
              hovering = true;
              break;
            }
          }
          canvas.style.cursor = hovering ? 'grab' : 'default';
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      if (!draggedNode) return;

      // Release with zero velocity
      draggedNode = null;
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('mouseleave', () => {
      if (draggedNode) {
        // Release with zero velocity
        draggedNode = null;
        canvas.style.cursor = 'default';
      }
    });

    // Animation loop
    function animate() {
      const frameStart = performance.now();

      // Throttle to target FPS
      if (lastRenderTime !== null && (frameStart - lastRenderTime) < FRAME_INTERVAL) {
        requestAnimationFrame(animate);
        return;
      }
      lastRenderTime = frameStart;

      let fps = 0;
      if (lastFrameTime !== null) {
        fps = 1000 / (frameStart - lastFrameTime);
      }
      lastFrameTime = frameStart;

      // Update phase indicator
      let currentPhase = 1;
      if (physicsStepCount >= PHASE_3_STEPS) {
        currentPhase = 4;
        phaseIndicatorEl.textContent = 'Phase 4: Steady State';
      } else if (physicsStepCount >= PHASE_2_STEPS) {
        currentPhase = 3;
        phaseIndicatorEl.textContent = 'Phase 3: Annealing';
      } else if (physicsStepCount >= PHASE_1_STEPS) {
        currentPhase = 2;
        phaseIndicatorEl.textContent = 'Phase 2: Squeezing to 2D';
      } else {
        currentPhase = 1;
        phaseIndicatorEl.textContent = 'Phase 1: 3D Dynamics';
      }

      // Determine current phase
      const inPhase1 = physicsStepCount < PHASE_1_STEPS;
      const inPhase2 = physicsStepCount >= PHASE_1_STEPS && physicsStepCount < PHASE_2_STEPS;
      const inPhase3 = physicsStepCount >= PHASE_2_STEPS && physicsStepCount < PHASE_3_STEPS;
      const inPhase4 = physicsStepCount >= PHASE_3_STEPS;

      // Adjust physics steps per frame based on phase (slower in phase 4)
      const stepsThisFrame = inPhase4 ? PHYSICS_STEPS_PER_FRAME / 20 : PHYSICS_STEPS_PER_FRAME;

      // Run multiple physics steps per render frame
      for (let step = 0; step < stepsThisFrame; step++) {
        physicsStepCount++;

        // Reset forces
        nodeArray.forEach(node => {
          nodePositions[node].fx = 0;
          nodePositions[node].fy = 0;
          nodePositions[node].fz = 0;
        });

      // Repulsion between all nodes
      // Energy: U_r = REPULSION_FACTOR * exp(-distance / LENGTH_SCALE) * LENGTH_SCALE / distance
      // Force magnitude: F_r = REPULSION_FACTOR * exp(-distance / LENGTH_SCALE) * (LENGTH_SCALE + distance) / distance²
      // Zero if distance > MAX_REPULSION_DISTANCE
      // Distance is edge-to-edge between rectangles
      for (let i = 0; i < nodeArray.length; i++) {
        for (let j = i + 1; j < nodeArray.length; j++) {
          const node1 = nodeArray[i];
          const node2 = nodeArray[j];
          const pos1 = nodePositions[node1];
          const pos2 = nodePositions[node2];

          // Get box dimensions
          const box1 = getBoxDimensions(node1);
          const box2 = getBoxDimensions(node2);

          // Calculate edge-to-edge distance in 3D
          const edgeDist = rectToRectDistance3D(pos1.x, pos1.y, pos1.z, box1.width, box1.height,
                                                pos2.x, pos2.y, pos2.z, box2.width, box2.height);

          // Direction from center to center in 3D
          const dx = pos2.x - pos1.x;
          const dy = pos2.y - pos1.y;
          const dz = pos2.z - pos1.z;
          const centerDist = Math.sqrt(dx * dx + dy * dy + dz * dz + 0.01);

          // Only apply repulsion if within max distance
          if (edgeDist <= MAX_REPULSION_DISTANCE) {
            let forceMagnitude = REPULSION_FACTOR * Math.exp(-edgeDist / LENGTH_SCALE) * (LENGTH_SCALE + edgeDist) / ((edgeDist + 0.01) * (edgeDist + 0.01));

            // Cap the force to prevent blowup at small distances
            forceMagnitude = Math.min(forceMagnitude, REPULSION_FACTOR);

            const fx = (dx / centerDist) * forceMagnitude;
            const fy = (dy / centerDist) * forceMagnitude;
            const fz = (dz / centerDist) * forceMagnitude;

            pos1.fx -= fx;
            pos1.fy -= fy;
            pos1.fz -= fz;
            pos2.fx += fx;
            pos2.fy += fy;
            pos2.fz += fz;
          }
        }
      }

      // Attraction along edges (in 3D)
      // Energy: U_a = ATTRACTION_FACTOR * (distance / LENGTH_SCALE)^1.5
      // Force magnitude: F_a = 1.5 * ATTRACTION_FACTOR * sqrt(distance) / LENGTH_SCALE^1.5
      edges.forEach(edge => {
        const pos1 = nodePositions[edge.from];
        const pos2 = nodePositions[edge.to];

        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const dz = pos2.z - pos1.z;
        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz + 0.01);

        const forceMagnitude = 1.5 * ATTRACTION_FACTOR * Math.sqrt(dist) / Math.pow(LENGTH_SCALE, 1.5);
        const fx = (dx / dist) * forceMagnitude;
        const fy = (dy / dist) * forceMagnitude;
        const fz = (dz / dist) * forceMagnitude;

        pos1.fx += fx;
        pos1.fy += fy;
        pos1.fz += fz;
        pos2.fx -= fx;
        pos2.fy -= fy;
        pos2.fz -= fz;
      });

        // Update positions
        nodeArray.forEach(node => {
          const pos = nodePositions[node];

          // Skip position update for dragged node (it's controlled by mouse)
          if (node === draggedNode) {
            // Still zero out velocity so it doesn't accumulate
            pos.vx = 0;
            pos.vy = 0;
            return;
          }

          if (inPhase3 || inPhase4) {
            // Phase 3 & 4: Pure 2D, z = 0
            pos.z = 0;
            pos.vz = 0;
            pos.vx = (pos.vx + pos.fx) * (1 - DAMPING);
            pos.vy = (pos.vy + pos.fy) * (1 - DAMPING);

            if (inPhase3) {
              // Phase 3: Annealing - always add dancing perturbation
              const danceStddev = PERTURBATION_STDDEV / 30;
              const aDance = danceStddev * Math.sqrt(3);
              pos.vx += (seededRandom() * 2 * aDance) - aDance;
              pos.vy += (seededRandom() * 2 * aDance) - aDance;
            } else if (inPhase4) {
              // Phase 4: Steady state - only dance if puzzle is complete
              if (guessedWords.size === nodeArray.length) {
                const danceStddev = PERTURBATION_STDDEV / 300;
                const aDance = danceStddev * Math.sqrt(3);
                pos.vx += (seededRandom() * 2 * aDance) - aDance;
                pos.vy += (seededRandom() * 2 * aDance) - aDance;
              }
            }

            // Clamp velocity to max
            const speed = Math.sqrt(pos.vx * pos.vx + pos.vy * pos.vy);
            if (speed > MAX_VELOCITY) {
              pos.vx = (pos.vx / speed) * MAX_VELOCITY;
              pos.vy = (pos.vy / speed) * MAX_VELOCITY;
            }

            pos.x += pos.vx * DT;
            pos.y += pos.vy * DT;
          } else {
            // Phase 1 & 2: 3D dynamics
            pos.vx = (pos.vx + pos.fx) * (1 - DAMPING);
            pos.vy = (pos.vy + pos.fy) * (1 - DAMPING);
            pos.vz = (pos.vz + pos.fz) * (1 - DAMPING);

            // Clamp velocity to max
            const speed = Math.sqrt(pos.vx * pos.vx + pos.vy * pos.vy + pos.vz * pos.vz);
            if (speed > MAX_VELOCITY) {
              pos.vx = (pos.vx / speed) * MAX_VELOCITY;
              pos.vy = (pos.vy / speed) * MAX_VELOCITY;
              pos.vz = (pos.vz / speed) * MAX_VELOCITY;
            }

            pos.x += pos.vx * DT;
            pos.y += pos.vy * DT;
            pos.z += pos.vz * DT;

            // Phase 2: Linear squeeze to 2D
            if (inPhase2) {
              const progress = (physicsStepCount - PHASE_1_STEPS) / (PHASE_2_STEPS - PHASE_1_STEPS);
              const maxZ = maxInitialZ * (1 - progress);

              pos.z = Math.max(-maxZ, Math.min(maxZ, pos.z));

              // If we hit the boundary, zero out z-velocity
              if (Math.abs(pos.z) >= maxZ - 0.01) {
                pos.vz = 0;
              }
            }
          }

          // Keep within bounds (x, y only)
          pos.x = Math.max(margin, Math.min(width - margin, pos.x));
          pos.y = Math.max(margin, Math.min(height - margin, pos.y));
        });

        // Center correction: calculate average position and shift to center
        let avgX = 0;
        let avgY = 0;
        nodeArray.forEach(node => {
          avgX += nodePositions[node].x;
          avgY += nodePositions[node].y;
        });
        avgX /= nodeArray.length;
        avgY /= nodeArray.length;

        // Calculate center of canvas
        const centerX = width / 2;
        const centerY = height / 2;

        // Shift all nodes to center
        const shiftX = centerX - avgX;
        const shiftY = centerY - avgY;
        nodeArray.forEach(node => {
          nodePositions[node].x += shiftX;
          nodePositions[node].y += shiftY;
        });
      } // End physics steps loop

      // Draw the graph (once per frame)
      ctx.clearRect(0, 0, width, height);

      // Draw "annealing..." text if not in steady state
      if (!inPhase4) {
        ctx.font = '20px "Gill Sans", sans-serif';
        ctx.fillStyle = '#888';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('annealing...', 10, 10);
      }

      // Draw edges (arrows)
      ctx.strokeStyle = '#000';
      ctx.fillStyle = '#000';
      ctx.lineWidth = 3;

      edges.forEach(edge => {
        // Check if connection should be visible (for invisible_connections gimmick)
        const invisibleConnections = (gimmick === 'invisible_connections');
        const bothRevealed = guessedWords.has(edge.from) && guessedWords.has(edge.to);

        // Skip drawing line if invisible_connections gimmick and both endpoints not revealed
        if (invisibleConnections && !bothRevealed) {
          return;
        }

        const from = nodePositions[edge.from];
        const to = nodePositions[edge.to];

        // Get box dimensions
        const fromBox = getBoxDimensions(edge.from);
        const toBox = getBoxDimensions(edge.to);

        // Draw line
        if (edge.direction === 'anagram') {
          // Draw red sine wave for anagram edges
          ctx.strokeStyle = '#ff0000';

          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // Sine wave parameters
          const wavelength = LENGTH_SCALE / 4;
          const amplitude = wavelength / 4;

          // Direction vectors
          const dirX = dx / distance;
          const dirY = dy / distance;
          const perpX = -dirY;  // Perpendicular (for wave oscillation)
          const perpY = dirX;

          // Generate all sine wave points
          const numSegments = Math.max(50, Math.floor(distance / 2));
          const points = [];
          for (let i = 0; i <= numSegments; i++) {
            const t = i / numSegments;
            const baseX = from.x + t * dx;
            const baseY = from.y + t * dy;

            // Sine wave offset perpendicular to line
            const phase = (t * distance / wavelength) * 2 * Math.PI;
            const offset = amplitude * Math.sin(phase);

            const x = baseX + offset * perpX;
            const y = baseY + offset * perpY;
            points.push({ x, y });
          }

          // Find first point outside "from" box, then go one more back to connect
          let startIdx = 0;
          for (let i = 0; i < points.length; i++) {
            const p = points[i];
            if (Math.abs(p.x - from.x) > fromBox.width / 2 ||
                Math.abs(p.y - from.y) > fromBox.height / 2) {
              startIdx = Math.max(0, i - 1); // Go one point back
              break;
            }
          }

          // Find last point outside "to" box, then go one more forward to connect
          let endIdx = points.length - 1;
          for (let i = points.length - 1; i >= 0; i--) {
            const p = points[i];
            if (Math.abs(p.x - to.x) > toBox.width / 2 ||
                Math.abs(p.y - to.y) > toBox.height / 2) {
              endIdx = Math.min(points.length - 1, i + 1); // Go one point forward
              break;
            }
          }

          // Draw the trimmed sine wave
          ctx.beginPath();
          for (let i = startIdx; i <= endIdx; i++) {
            if (i === startIdx) {
              ctx.moveTo(points[i].x, points[i].y);
            } else {
              ctx.lineTo(points[i].x, points[i].y);
            }
          }
          ctx.stroke();

          // Reset stroke style for next edges
          ctx.strokeStyle = '#000';
        } else {
          // Draw normal straight line (edge to edge)
          const fromIntersect = lineRectIntersection(from.x, from.y, to.x, to.y, from.x, from.y, fromBox.width, fromBox.height);
          const toIntersect = lineRectIntersection(from.x, from.y, to.x, to.y, to.x, to.y, toBox.width, toBox.height);

          ctx.beginPath();
          ctx.moveTo(fromIntersect.x, fromIntersect.y);
          ctx.lineTo(toIntersect.x, toIntersect.y);
          ctx.stroke();
        }
      });

      // Draw nodes (rectangles)
      ctx.font = `${fontSize}px "Gill Sans", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      nodeArray.forEach(node => {
        const pos = nodePositions[node];
        const box = getBoxDimensions(node);

        // Draw rectangle (colored fill, black outline)
        ctx.fillStyle = getNodeColor(node);
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.fillRect(pos.x - box.width/2, pos.y - box.height/2, box.width, box.height);
        ctx.strokeRect(pos.x - box.width/2, pos.y - box.height/2, box.width, box.height);

        // Draw label if guessed
        if (guessedWords.has(node)) {
          ctx.fillStyle = '#000';
          ctx.fillText(node, pos.x, pos.y);
        }
      });

      // Draw circles on top of everything based on edge direction
      ctx.fillStyle = '#000';
      edges.forEach(edge => {
        // Skip circles for anagram edges
        if (edge.direction === 'anagram') {
          return;
        }

        const from = nodePositions[edge.from];
        const to = nodePositions[edge.to];

        // Get box dimensions
        const fromBox = getBoxDimensions(edge.from);
        const toBox = getBoxDimensions(edge.to);

        // Draw circles based on direction
        if (edge.direction === 'forward' || edge.direction === 'bidirectional') {
          // Draw circle at 'to' end
          const toIntersect = lineRectIntersection(from.x, from.y, to.x, to.y, to.x, to.y, toBox.width, toBox.height);
          ctx.beginPath();
          ctx.arc(toIntersect.x, toIntersect.y, 5, 0, 2 * Math.PI);
          ctx.fill();
        }

        if (edge.direction === 'backward' || edge.direction === 'bidirectional') {
          // Draw circle at 'from' end
          const fromIntersect = lineRectIntersection(to.x, to.y, from.x, from.y, from.x, from.y, fromBox.width, fromBox.height);
          ctx.beginPath();
          ctx.arc(fromIntersect.x, fromIntersect.y, 5, 0, 2 * Math.PI);
          ctx.fill();
        }

        // If direction === 'none', no circles are drawn
      });

      // Draw instruction text in bottom right (only on non-mobile)
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if (!isMobile) {
        ctx.font = '18px "Gill Sans", sans-serif';
        ctx.fillStyle = '#999';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'bottom';
        ctx.fillText('click and drag to adjust the graph', width - 10, height - 10);
      }

      // Draw song name in bottom left when puzzle is complete
      if (guessedWords.size === nodeArray.length) {
        ctx.font = '18px "Gill Sans", sans-serif';
        ctx.fillStyle = '#999';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillText('Chopin - Nocturne in E Flat Major', 10, height - 10);
      }

      currentIteration++;
      const frameEnd = performance.now();
      const frameTime = frameEnd - frameStart;
      frameCounterEl.textContent = `Frame: ${currentIteration} | FPS: ${fps.toFixed(1)} | Time: ${frameTime.toFixed(1)}ms`;

      // Continue animation
      requestAnimationFrame(animate);
    }

    // Start animation
    animate();

    // Set up reset button
    const resetButton = document.getElementById('resetButton');
    resetButton.addEventListener('click', () => {
      if (confirm('delete puzzle progress?')) {
        try {
          localStorage.removeItem(STORAGE_KEY);
          location.reload();
        } catch (e) {
          console.error('Error resetting progress:', e);
        }
      }
    });
  }

  // Load when page is ready
  loadAndDrawGraph();
</script>

      </div>
    </div>

    <div class="text-center p-3" style="background-color: #e8e8e8;">
  <div class="container ">
    <div class="row justify-content-md-center">

      <div class="col-2">
        <p class="text-center">
          <i class="far fa-envelope"></i>
          <a href="mailto:jsi@berkeley.edu">jsi@berkeley.edu</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-github"></i>
          <a href="https://github.com/james-simon">james-simon</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fas fa-graduation-cap"></i>
          <a href=https://scholar.google.com/citations?user=zjGfh3sAAAAJ&hl=en>gScholar</a>
        </p>
      </div>

    </div>
  </div>
</div>
</footer>

  </body>

</html>
