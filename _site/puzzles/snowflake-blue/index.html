<!DOCTYPE html>
<html>

  <head>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: { autoNumber: "AMS" },
        tagSide: "right"
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      }
    });
    MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function () {
      MathJax.InputJax.TeX.Stack.Item.AMSarray.Augment({
        clearTag() {
          if (!this.global.notags) {
            this.super(arguments).clearTag.call(this);
          }
        }
      });
    });
  </script>
  <script type="text/javascript" charset="utf-8"
    src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML">
  </script>


  <!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Snowflake</title>
  <meta name="description" content="A word lives at every node in this tree, and each pair of connected words makes a common compound word or phrase. The dots on the line segments indicate whic...">

  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">

  <!-- <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">
  <script src="/boostrap/js/bootstrap.js"></script> -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">

  <link rel="canonical" href="http://james-simon.github.io/puzzles/snowflake-blue/">
  <link rel="alternate" type="application/rss+xml" title="Jamie Simon" href="http://james-simon.github.io/feed.xml">

  <style>
    body {
      font-family: "et-book", "ETBookOT", "ET Book", Georgia, "Times New Roman", serif !important;
    }

    a:link {
      color: #1a4d8f;
      text-decoration: none;
    }

    a:visited {
      color: #6b2d8f;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>

  

</head>


  <body style="display: flex; flex-direction: column; min-height: 100vh; margin: 0;">

    <!-- <header class="site-header"> -->
    <!-- <a class="site-title" href="/">Jamie Simon</a> -->
<!-- </header> -->

    <style>
      .nav-link {
        transition: all 0.2s ease;
        border-radius: 4px;
        padding: 8px 16px !important;
      }

      .nav-link:hover {
        background-color: #333 !important;
        color: white !important;
      }

      .nav-link:hover i {
        color: white !important;
      }

      /* Hide text on narrow screens, show only icons */
      @media (max-width: 767px) {
        .nav-link .nav-text {
          display: none;
        }
        .nav-link {
          padding: 8px 12px !important;
        }
      }
    </style>

    <nav class="navbar navbar-expand navbar-light" style="background-color: #e8e8e8;">
      <div class = "container">
        <a class="navbar-brand" href="/">Jamie Simon</a></span> </a>
        <div class="navbar-collapse">
          <ul class="nav navbar-nav ml-auto" style="flex-wrap: nowrap;">
            <li class = "nav-item active"><a class="nav-link" href="/research/"><i class="fas fa-cogs"></i><span class="nav-text"> Research</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/blog/"><i class="fas fa-seedling"></i><span class="nav-text"> Blog</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/puzzles/"><i class="fab fa-laravel"></i><span class="nav-text"> Puzzles</span></a></li>
          </ul>
        </div>
      </div>
    </nav>

    <style>
  .char {
    display: inline;
    margin: 0;
    padding: 0;
    border: 0;
    vertical-align: baseline;
    line-height: inherit;
    font: inherit;
    font-size: inherit;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    color: inherit;
    white-space: inherit;
    letter-spacing: inherit;
    word-spacing: inherit;
    text-decoration: inherit;
    text-transform: inherit;
    background: transparent;
  }

  .char-particle {
    position: fixed;
    margin: 0;
    will-change: transform;
    pointer-events: none;
  }

  body.shatter-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.bird-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.panic-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  #shatter-overlay-blocker {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 9999;
    display: none;
  }

  body.shatter-locked #shatter-overlay-blocker {
    display: block;
  }
</style>

<div id="shatter-overlay-blocker"></div>
<audio id="shatter-audio" preload="auto" src="/audio/glass_bottle_breaking.mp3"></audio>
<audio id="pop-1" preload="auto" src="/audio/pop_1.mp3"></audio>
<audio id="pop-2" preload="auto" src="/audio/pop_2.mp3"></audio>
<audio id="pop-3" preload="auto" src="/audio/pop_3.mp3"></audio>
<audio id="pop-4" preload="auto" src="/audio/pop_4.mp3"></audio>
<!-- Bird mode audio -->
<audio id="goose-honk" src="/audio/bird_sounds/goose_honk.mp3" preload="auto"></audio>
<audio id="goose-yell" src="/audio/bird_sounds/goose_yell.mp3" preload="auto"></audio>
<audio id="hawk-call" src="/audio/bird_sounds/hawk_call.mp3" preload="auto"></audio>
<!-- Panic mode audio -->
<audio id="panic-alarm" preload="auto" src="/audio/alarm.mp3"></audio>
<audio id="panic-scream" preload="auto" src="/audio/crowd_scream.mp3"></audio>

<script>
  // ============================================================================
  // SHARED STATE AND UTILITIES FOR INTERACTIVE MODES
  // ============================================================================

  // Global state
  let shatterActive = false;
  let gravityActive = false;
  let vacuumActive = false;
  let pongActive = false;
  let birdModeActive = false;
  let panicActive = false;
  let mouseX = 0;
  let mouseY = 0;
  let prevMouseX = 0;
  let prevMouseY = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function playRandomPop() {
    const popIndex = Math.floor(Math.random() * 4) + 1;
    const audio = document.getElementById(`pop-${popIndex}`);
    if (audio) {
      audio.volume = 0.3; // Quieter pops
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Pop sound failed:', err));
    }
  }

  // Check if a point is close to a line segment
  function distanceToLineSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;

    if (lengthSquared === 0) {
      // Line segment is a point
      const distX = px - x1;
      const distY = py - y1;
      return Math.sqrt(distX * distX + distY * distY);
    }

    // Project point onto line segment
    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t)); // Clamp to [0, 1]

    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;

    const distX = px - closestX;
    const distY = py - closestY;
    return Math.sqrt(distX * distX + distY * distY);
  }

  function wrapTextNodes(node) {
    // Skip script, style, and interactive mode elements
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName;
      const elemId = node.id;

      // Skip these elements entirely
      if (tagName === 'SCRIPT' || tagName === 'STYLE' ||
          tagName === 'CODE' || tagName === 'PRE' ||
          tagName === 'KBD' || tagName === 'SAMP' ||
          tagName === 'TEXTAREA' || tagName === 'INPUT' ||
          tagName === 'SELECT' || tagName === 'BUTTON' ||
          elemId === 'shatter-overlay-blocker' ||
          elemId === 'shatter-audio' ||
          elemId === 'panic-button' ||
          elemId?.startsWith('pop-')) {
        return;
      }

      // Skip fixed/absolute positioned elements (like nav, modals, etc.)
      const style = window.getComputedStyle(node);
      if (style.position === 'fixed' || style.position === 'absolute') {
        return;
      }

      // Skip elements that are hidden
      if (style.display === 'none' || style.visibility === 'hidden') {
        return;
      }
    }

    // If it's a text node, wrap each character
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text.trim().length === 0) return; // Skip whitespace-only nodes

      const fragment = document.createDocumentFragment();
      // Use Array.from to properly handle multi-byte characters like emojis
      const chars = Array.from(text);
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === ' ') {
          // Preserve spaces as regular text nodes
          fragment.appendChild(document.createTextNode(' '));
        } else {
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = char;
          fragment.appendChild(span);
        }
      }
      node.parentNode.replaceChild(fragment, node);
    }
    // Recursively process child nodes
    else if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes);
      children.forEach(child => wrapTextNodes(child));
    }
  }

  // Gaussian random number generator (Box-Muller transform)
  function gaussianRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * stdDev + mean;
  }

  // Track if text has been wrapped
  let textWrapped = false;

  // Wrap text lazily when first mode is activated
  function ensureTextWrapped() {
    if (textWrapped) return;
    textWrapped = true;
    wrapTextNodes(document.body);
  }
</script>

<script>
  // ============================================================================
  // SHATTER MODE
  // ============================================================================

  function enterShatterMode() {
    if (shatterActive) return;
    shatterActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    const particles = [];

    // Helper function to create particle from element
    function createParticle(element, rect, isText = false) {
      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the element
      const clone = element.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(element);

      // For icon elements (i, svg), copy minimal styles to avoid interfering with pseudo-elements
      if (element.tagName === 'I' || element.tagName === 'SVG') {
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.color = computedStyle.color;
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      } else {
        // For other elements, copy full styles
        // Ensure emoji fonts are preserved by adding them to the font stack
        const fontFamily = computedStyle.fontFamily;
        clone.style.fontFamily = fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.fontWeight = computedStyle.fontWeight;
        clone.style.color = computedStyle.color;
        clone.style.backgroundColor = computedStyle.backgroundColor;
        clone.style.border = computedStyle.border;
        clone.style.borderRadius = computedStyle.borderRadius;
        clone.style.padding = computedStyle.padding;

        // Preserve dimensions for all elements to prevent shrinking
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      }

      // Set z-index: text always on top, then smaller elements in front
      if (isText) {
        clone.style.zIndex = '10000';
      } else {
        // Calculate area and set z-index inversely (smaller = higher z)
        const area = rect.width * rect.height;
        // Map area to z-index range 1000-9999 (larger area = lower z)
        const zIndex = Math.max(1000, Math.min(9999, 9999 - Math.floor(area / 10)));
        clone.style.zIndex = zIndex.toString();
      }

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      element.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: rect.width,
        height: rect.height
      });
    }

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();
      createParticle(char, rect, true); // isText = true
    });

    // Collect all other shatterable elements
    const elements = document.querySelectorAll('img, button, .styled-box, h1, h2, h3, h4, h5, h6, blockquote, svg, i, nav span, nav div');
    elements.forEach(el => {
      // Skip if it's the overlay blocker
      if (el.id === 'shatter-overlay-blocker') return;

      // Skip empty elements or elements with no visible content
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return;

      createParticle(el, rect);
    });

    // Collect line breaks and render them as small horizontal lines
    const lineBreaks = document.querySelectorAll('br');
    lineBreaks.forEach(br => {
      const rect = br.getBoundingClientRect();

      // Create a visible line element for the br
      const line = document.createElement('div');
      line.style.width = '20px';
      line.style.height = '2px';
      line.style.backgroundColor = '#999';
      line.style.position = 'fixed';
      line.style.left = rect.left + 'px';
      line.style.top = rect.top + 'px';
      line.classList.add('char-particle');

      // Add to body
      document.body.appendChild(line);

      // Hide original
      br.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: line,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: 20,
        height: 2
      });
    });

    // Play shatter sound after text wrapping and particle collection
    const audio = document.getElementById('shatter-audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Audio play failed:', err));
    }

    // Start animation
    startShatterAnimation(particles);
  }

  function startShatterAnimation(particles) {
    let lastTime = performance.now();
    const gravity = 1000; // Doubled gravity for faster fall
    const damping = 0.6; // More energy loss on bounce

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Apply gravity
        particle.vy += gravity * dt;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // GRAVITY MODE
  // ============================================================================

  function enterGravityMode() {
    if (gravityActive) return;
    gravityActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "GRAVITY ON" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'GRAVITY ON';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00bfff';
    flashMessage.style.textShadow = '0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00bfff';
    flashMessage.style.boxShadow = '0 0 20px #00bfff, inset 0 0 20px rgba(0, 191, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startGravityAnimation(particles);
  }

  function startGravityAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 150; // Falloff distance for exponential potential

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 5000;
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // VACUUM MODE
  // ============================================================================

  function enterVacuumMode() {
    if (vacuumActive) return;
    vacuumActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "VACUUM MODE INITIATED" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'VACUUM MODE INITIATED';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00ff00';
    flashMessage.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00ff00';
    flashMessage.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Keep a history of 15 mouse positions for smoother direction calculation
    const mouseHistory = [];
    const HISTORY_LENGTH = 15;

    // Store vacuumed particles in order for burping
    const vacuumedParticles = [];

    // Track mouse position and update history
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;

      // Only add to history if mouse actually moved
      if (prevMouseX !== null && prevMouseY !== null) {
        const dx = mouseX - prevMouseX;
        const dy = mouseY - prevMouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.1) { // Only count as movement if moved enough
          mouseHistory.push({x: mouseX, y: mouseY});

          // Keep only last 5 positions
          if (mouseHistory.length > HISTORY_LENGTH) {
            mouseHistory.shift();
          }
        }
      }
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport or has no width (e.g., newlines)
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startVacuumAnimation(particles, vacuumedParticles, mouseHistory);
  }

  function startVacuumAnimation(particles, vacuumedParticles, mouseHistory) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 300; // Falloff distance for exponential potential
    const velocityDamping = 0.99; // Per-frame velocity damping
    const WAIT_TIME = 5; // seconds to wait before burp mode
    const V_BURP = 1000; // pixels per second
    const BURP_RATE = 30; // chars per second
    let allParticlesGoneTime = null;
    let burpAudio = null;
    let burpStarted = false;
    const burpedParticles = []; // Active burped particles

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      // Only check for particle removal if we have a valid mouse position
      if (mouseX !== null && mouseY !== null && prevMouseX !== null && prevMouseY !== null) {
        // Filter out particles that should be removed
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];

          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Also check distance to line segment traced by mouse movement
          const distToPath = distanceToLineSegment(centerX, centerY, prevMouseX, prevMouseY, mouseX, mouseY);

          // Effective capture radius is proportional to particle size
          const effectiveRadius = Math.min(particle.width, particle.height) / 2;

          // Remove particle if within effective radius of current mouse position or path
          if (dist < effectiveRadius || distToPath < effectiveRadius) {
            // Store particle info for burping later
            vacuumedParticles.push({
              el: particle.el,
              x: particle.x,
              y: particle.y,
              vx: particle.vx,
              vy: particle.vy,
              width: particle.width,
              height: particle.height
            });

            // Hide but don't remove from DOM yet (we'll reuse it for burping)
            particle.el.style.display = 'none';
            particles.splice(i, 1);
            playRandomPop(); // Play pop sound
            continue;
          }
        }
      }

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ), 30x stronger than base
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 150000; // 30x force
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Apply velocity damping
        particle.vx *= velocityDamping;
        particle.vy *= velocityDamping;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Update previous mouse position for next frame
      prevMouseX = mouseX;
      prevMouseY = mouseY;

      // Check if all particles are gone
      if (particles.length === 0 && allParticlesGoneTime === null) {
        allParticlesGoneTime = currentTime;

        // Create BURP INCOMING flash message
        const burpWarning = document.createElement('div');
        burpWarning.id = 'burp-warning';
        burpWarning.textContent = 'BURP INCOMING';
        burpWarning.style.position = 'fixed';
        burpWarning.style.top = '50%';
        burpWarning.style.left = '50%';
        burpWarning.style.transform = 'translate(-50%, -50%)';
        burpWarning.style.fontSize = '64px';
        burpWarning.style.fontFamily = 'Courier New, monospace';
        burpWarning.style.fontWeight = 'bold';
        burpWarning.style.letterSpacing = '4px';
        burpWarning.style.color = '#00ff00';
        burpWarning.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
        burpWarning.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        burpWarning.style.padding = '30px 50px';
        burpWarning.style.border = '4px solid #00ff00';
        burpWarning.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
        burpWarning.style.zIndex = '100000';
        burpWarning.style.pointerEvents = 'none';
        burpWarning.style.textAlign = 'center';
        burpWarning.style.display = 'none';
        document.body.appendChild(burpWarning);

        // Flash with 0.5s on, 0.5s off starting at 3 seconds (last 2 seconds before burp)
        let flashStartTime = null;

        function flashBurpWarning(time) {
          const elapsed = (time - allParticlesGoneTime) / 1000;

          if (elapsed >= 3 && elapsed < WAIT_TIME) {
            if (flashStartTime === null) flashStartTime = time;
            const flashElapsed = (time - flashStartTime) / 1000;
            const cycleTime = flashElapsed % 1.0; // 1 second cycle

            if (cycleTime < 0.5) {
              burpWarning.style.display = 'block';
            } else {
              burpWarning.style.display = 'none';
            }

            requestAnimationFrame(flashBurpWarning);
          } else if (elapsed >= WAIT_TIME) {
            // Remove warning when burp starts
            burpWarning.remove();
          } else if (elapsed < 3) {
            // Keep flashing until we reach 3 seconds
            requestAnimationFrame(flashBurpWarning);
          }
        }

        requestAnimationFrame(flashBurpWarning);
      }

      // Start burp mode after WAIT_TIME
      if (allParticlesGoneTime !== null && burpAudio === null) {
        const elapsed = (currentTime - allParticlesGoneTime) / 1000;

        if (elapsed >= WAIT_TIME && !burpStarted) {
          burpStarted = true;

          burpAudio = new Audio('/audio/burp_loop.mp3');
          burpAudio.loop = true;
          burpAudio.volume = 0.5;
          burpAudio.play();

          // Start burping particles at BURP_RATE
          let lastBurpTime = currentTime;
          const burpInterval = 1000 / BURP_RATE; // ms between burps

          function burpParticle() {
            if (vacuumedParticles.length > 0) {
              // Get current mouse direction
              let dirX = 0, dirY = 1; // Default down
              if (mouseHistory.length >= 2) {
                const oldest = mouseHistory[0];
                const newest = mouseHistory[mouseHistory.length - 1];
                const histDx = newest.x - oldest.x;
                const histDy = newest.y - oldest.y;
                const histDist = Math.sqrt(histDx * histDx + histDy * histDy);

                if (histDist > 0.01) {
                  // Direction is same as mouse movement
                  dirX = histDx / histDist;
                  dirY = histDy / histDist;
                }
              }

              // Pop from end (reverse order)
              const particle = vacuumedParticles.pop();

              // Reset particle position to mouse (centered on particle)
              particle.x = mouseX - particle.width / 2;
              particle.y = mouseY - particle.height / 2;

              // Add Gaussian angular jitter (mean 0, stdev 3 degrees)
              const jitterAngle = gaussianRandom(0, 3) * Math.PI / 180; // Convert to radians
              const currentAngle = Math.atan2(dirY, dirX);
              const newAngle = currentAngle + jitterAngle;
              const jitteredDirX = Math.cos(newAngle);
              const jitteredDirY = Math.sin(newAngle);

              particle.vx = jitteredDirX * V_BURP;
              particle.vy = jitteredDirY * V_BURP;

              // Show particle again
              particle.el.style.display = 'block';
              particle.el.style.left = particle.x + 'px';
              particle.el.style.top = particle.y + 'px';

              burpedParticles.push(particle);
            }

            // Schedule next burp if more particles remain
            if (vacuumedParticles.length > 0) {
              setTimeout(burpParticle, burpInterval);
            } else {
              // All particles burped out, stop the audio
              if (burpAudio) {
                burpAudio.pause();
                burpAudio.currentTime = 0;
              }
            }
          }

          // Start burping
          burpParticle();
        }
      }

      // Animate burped particles with gravity and bouncing
      if (burpStarted && burpedParticles.length > 0) {
        const gravity = 1000; // Same as shatter mode
        const bounceDamping = 0.6; // Energy loss on bounce

        for (let i = burpedParticles.length - 1; i >= 0; i--) {
          const particle = burpedParticles[i];

          // Apply gravity
          particle.vy += gravity * dt;

          // Update position
          particle.x += particle.vx * dt;
          particle.y += particle.vy * dt;

          // Bounce off edges with energy loss (same as shatter mode)
          const width = window.innerWidth;
          const height = window.innerHeight;

          // Left and right edges
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Top and bottom edges
          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.y + particle.height > height + 7) {
            // Keep character visible - allow a bit past the bottom (7px lower)
            particle.y = height - particle.height + 7;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Update transform
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  function enterPongMode() {
    if (pongActive) return;
    pongActive = true;

    // Play ready set go sound immediately
    const readyAudio = new Audio('/audio/chiptune_ready_set_go.mp3');
    readyAudio.volume = 1.0;
    readyAudio.play().catch(err => console.log('Ready audio play failed:', err));

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "METEOR SHOWER INCOMING" message
    const flashMessage = document.createElement('div');
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#ff00ff';
    flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #ff00ff';
    flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';

    const mainText = document.createElement('div');
    mainText.textContent = 'METEOR SHOWER INCOMING';
    mainText.style.fontSize = '64px';

    const subText = document.createElement('div');
    subText.textContent = '(GAME TO 10)';
    subText.style.fontSize = '32px';
    subText.style.marginTop = '10px';

    flashMessage.appendChild(mainText);
    flashMessage.appendChild(subText);
    document.body.appendChild(flashMessage);

    // Show for 2 seconds, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000);
    }, 2000);

    // Create score displays
    const leftScoreContainer = document.createElement('div');
    leftScoreContainer.style.position = 'fixed';
    leftScoreContainer.style.top = '50px';
    leftScoreContainer.style.left = '50px';
    leftScoreContainer.style.zIndex = '99999';
    leftScoreContainer.style.pointerEvents = 'none';
    leftScoreContainer.style.textAlign = 'center';

    const leftLabel = document.createElement('div');
    leftLabel.textContent = 'THEIR\nSCORE';
    leftLabel.style.fontFamily = 'Courier New, monospace';
    leftLabel.style.fontSize = '24px';
    leftLabel.style.fontWeight = 'bold';
    leftLabel.style.color = '#ff0000';
    leftLabel.style.textShadow = '0 0 10px #ff0000';
    leftLabel.style.marginBottom = '10px';
    leftLabel.style.whiteSpace = 'pre-line';
    leftLabel.style.lineHeight = '1.2';

    const leftScore = document.createElement('div');
    leftScore.textContent = '0';
    leftScore.style.fontFamily = 'Courier New, monospace';
    leftScore.style.fontSize = '72px';
    leftScore.style.fontWeight = 'bold';
    leftScore.style.color = '#ff0000';
    leftScore.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';

    leftScoreContainer.appendChild(leftLabel);
    leftScoreContainer.appendChild(leftScore);
    document.body.appendChild(leftScoreContainer);

    const rightScoreContainer = document.createElement('div');
    rightScoreContainer.style.position = 'fixed';
    rightScoreContainer.style.top = '50px';
    rightScoreContainer.style.right = '50px';
    rightScoreContainer.style.zIndex = '99999';
    rightScoreContainer.style.pointerEvents = 'none';
    rightScoreContainer.style.textAlign = 'center';

    const rightLabel = document.createElement('div');
    rightLabel.textContent = 'YOUR\nSCORE';
    rightLabel.style.fontFamily = 'Courier New, monospace';
    rightLabel.style.fontSize = '24px';
    rightLabel.style.fontWeight = 'bold';
    rightLabel.style.color = '#00ff00';
    rightLabel.style.textShadow = '0 0 10px #00ff00';
    rightLabel.style.marginBottom = '10px';
    rightLabel.style.whiteSpace = 'pre-line';
    rightLabel.style.lineHeight = '1.2';

    const rightScore = document.createElement('div');
    rightScore.textContent = '0';
    rightScore.style.fontFamily = 'Courier New, monospace';
    rightScore.style.fontSize = '72px';
    rightScore.style.fontWeight = 'bold';
    rightScore.style.color = '#00ff00';
    rightScore.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';

    rightScoreContainer.appendChild(rightLabel);
    rightScoreContainer.appendChild(rightScore);
    document.body.appendChild(rightScoreContainer);

    // Create player paddle (right side, green)
    const playerPaddle = document.createElement('div');
    playerPaddle.style.position = 'fixed';
    playerPaddle.style.right = '20px';
    playerPaddle.style.width = '15px';
    playerPaddle.style.height = '200px';
    playerPaddle.style.backgroundColor = '#00ff00';
    playerPaddle.style.boxShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';
    playerPaddle.style.zIndex = '99999';
    playerPaddle.style.pointerEvents = 'none';
    document.body.appendChild(playerPaddle);

    // Create enemy paddle (left side, red, static)
    const enemyPaddle = document.createElement('div');
    enemyPaddle.style.position = 'fixed';
    enemyPaddle.style.left = '20px';
    enemyPaddle.style.width = '15px';
    enemyPaddle.style.height = '200px';
    enemyPaddle.style.backgroundColor = '#ff0000';
    enemyPaddle.style.boxShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';
    enemyPaddle.style.zIndex = '99999';
    enemyPaddle.style.pointerEvents = 'none';
    document.body.appendChild(enemyPaddle);

    // Paddle control state
    let playerPaddleY = window.innerHeight / 2 - 100; // Center paddle
    let enemyPaddleY = window.innerHeight / 2 - 100; // Center enemy paddle (static)
    let lastMouseMoveTime = 0;
    let mouseControlActive = false;
    const paddleSpeed = 800; // px/s for keyboard control

    // Update paddle positions
    playerPaddle.style.top = playerPaddleY + 'px';
    enemyPaddle.style.top = enemyPaddleY + 'px';

    // Mouse control
    document.addEventListener('mousemove', (e) => {
      mouseControlActive = true;
      lastMouseMoveTime = Date.now();
      playerPaddleY = Math.max(0, Math.min(window.innerHeight - 200, e.clientY - 100));
    });

    // Keyboard control
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    let themScore = 0;
    let youScore = 0;

    const particles = [];

    // Collect all text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height,
        active: false,
        trail: [] // Store last 15 positions for comet tail
      });
    });

    // Activate one random letter every 2 seconds, starting after 3.5 second delay
    let activationInterval;
    setTimeout(() => {
      activationInterval = setInterval(() => {
        // Find all inactive particles
        const inactiveParticles = particles.filter(p => !p.active);

        if (inactiveParticles.length === 0) {
          clearInterval(activationInterval);
          return;
        }

        // Pick a random inactive particle
        const randomParticle = inactiveParticles[Math.floor(Math.random() * inactiveParticles.length)];

        // Give it velocity with guaranteed horizontal movement
        const minVx = 200; // Minimum horizontal speed
        const vxSign = Math.random() < 0.5 ? -1 : 1;
        randomParticle.vx = vxSign * (minVx + Math.random() * 400); // 200-600 px/s
        randomParticle.vy = (Math.random() - 0.5) * 600;
        randomParticle.active = true;

        // Create whitish-orange burst at launch position
        const launchX = randomParticle.x + randomParticle.width / 2;
        const launchY = randomParticle.y + randomParticle.height / 2;
        createLaunchBurst(launchX, launchY);

        // Play letter release buzz - create new Audio instance each time
        const letterBuzz = new Audio('/audio/chiptune_buzz.wav');
        letterBuzz.volume = 0.35;
        letterBuzz.play().catch(err => console.log('Letter buzz play failed:', err));
      }, 2000);
    }, 3500);

    // Game state
    let blackHoleActive = false;
    let blackHoleEl = null;
    let gameOver = false;

    // Start animation
    startPongAnimation(particles, leftScore, rightScore, playerPaddle, enemyPaddle, () => playerPaddleY, (newY) => { playerPaddleY = newY; }, (newY) => { enemyPaddleY = newY; }, keys, () => mouseControlActive, () => blackHoleActive, (active) => { blackHoleActive = active; }, () => gameOver, (over) => { gameOver = over; });
  }

  function createBurst(x, y, color) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '80px';
    burst.style.height = '80px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = color;
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.8';
    burst.style.boxShadow = `0 0 40px ${color}, 0 0 80px ${color}`;
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.3s, transform 0.3s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.5)';
      setTimeout(() => {
        burst.remove();
      }, 300);
    }, 50);
  }

  function flashPaddle(paddleEl) {
    let flashCount = 0;
    const maxFlashes = 6; // 3 full on/off cycles
    const flashInterval = setInterval(() => {
      paddleEl.style.opacity = paddleEl.style.opacity === '0' ? '1' : '0';
      flashCount++;
      if (flashCount >= maxFlashes) {
        clearInterval(flashInterval);
        paddleEl.style.opacity = '1'; // Ensure it ends visible
      }
    }, 80); // Flash every 80ms
  }

  function createLaunchBurst(x, y) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '50px';
    burst.style.height = '50px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = '#ffcc88'; // Whitish-orange
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.7';
    burst.style.boxShadow = '0 0 20px #ffcc88, 0 0 40px #ffcc88';
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.25s, transform 0.25s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.3)';
      setTimeout(() => {
        burst.remove();
      }, 250);
    }, 50);
  }

  function startPongAnimation(particles, leftScoreEl, rightScoreEl, playerPaddleEl, enemyPaddleEl, getPlayerPaddleY, setPlayerPaddleY, setEnemyPaddleY, keys, getMouseActive, getBlackHoleActive, setBlackHoleActive, getGameOver, setGameOver) {
    let lastTime = performance.now();
    let themScore = 0;
    let youScore = 0;
    const paddleSpeed = 1152; // 20% faster than 960
    let enemyPaddleSpeed = 540; // Slower than player
    let enemyPaddleY = window.innerHeight / 2 - 100;
    let blackHoleEl = null;
    const paddleWidth = 15;
    const paddleHeight = 200;
    const leftPaddleX = 20;
    const rightPaddleX = window.innerWidth - 20 - paddleWidth;

    // Audio elements for paddle hits and game events
    const blip1Audio = new Audio('/audio/pong_blip_1.mp3'); // YOU paddle
    const blip2Audio = new Audio('/audio/pong_blip_2.mp3'); // THEM paddle
    const damage1Audio = new Audio('/audio/chiptune_damage_1.mp3'); // YOU damaged
    const damage2Audio = new Audio('/audio/chiptune_damage_2.mp3'); // THEM damaged
    const victoryAudio = new Audio('/audio/chiptune_victory.mp3'); // Victory
    const defeatAudio = new Audio('/audio/chiptune_defeat.mp3'); // Defeat

    // AI state
    const aiReactionDelay = 280; // ms
    const aiRandomOffset = 35; // px
    let lastAIUpdate = 0;
    let aiTargetY = enemyPaddleY;

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Update player paddle position with keyboard if mouse hasn't moved recently
      if (Date.now() - performance.now() > 100 || !getMouseActive()) {
        let paddleY = getPlayerPaddleY();
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
          paddleY -= paddleSpeed * dt;
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
          paddleY += paddleSpeed * dt;
        }
        paddleY = Math.max(0, Math.min(height - paddleHeight, paddleY));
        setPlayerPaddleY(paddleY);
      }

      // Update enemy AI paddle
      if (currentTime - lastAIUpdate > aiReactionDelay) {
        lastAIUpdate = currentTime;

        // Find the nearest threatening letter (moving left towards enemy paddle)
        let closestThreat = null;
        let minTime = Infinity;

        particles.forEach(particle => {
          if (particle.vx < 0 && particle.active) { // Moving left
            const timeToReach = (particle.x - (leftPaddleX + paddleWidth)) / -particle.vx;
            if (timeToReach > 0 && timeToReach < minTime) {
              minTime = timeToReach;
              // Predict where it will be
              let predictedY = particle.y + particle.vy * timeToReach;

              // Account for bounces off top/bottom
              while (predictedY < 0 || predictedY + particle.height > height) {
                if (predictedY < 0) {
                  predictedY = -predictedY;
                } else if (predictedY + particle.height > height) {
                  predictedY = 2 * (height - particle.height) - predictedY;
                }
              }

              closestThreat = predictedY + particle.height / 2; // Center of letter
            }
          }
        });

        if (closestThreat !== null) {
          // Add random offset for imperfection
          aiTargetY = closestThreat - paddleHeight / 2 + (Math.random() - 0.5) * aiRandomOffset;
        } else {
          // No threats, drift toward center
          aiTargetY = height / 2 - paddleHeight / 2;
        }
      }

      // Move enemy paddle smoothly towards target
      if (enemyPaddleY < aiTargetY) {
        enemyPaddleY = Math.min(aiTargetY, enemyPaddleY + enemyPaddleSpeed * dt);
      } else if (enemyPaddleY > aiTargetY) {
        enemyPaddleY = Math.max(aiTargetY, enemyPaddleY - enemyPaddleSpeed * dt);
      }
      enemyPaddleY = Math.max(0, Math.min(height - paddleHeight, enemyPaddleY));
      setEnemyPaddleY(enemyPaddleY);

      // Update paddle element positions
      playerPaddleEl.style.top = getPlayerPaddleY() + 'px';
      enemyPaddleEl.style.top = enemyPaddleY + 'px';

      // Update particles and check for scoring
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Apply black hole gravity if particle is active and black hole is active
        if (particle.active && getBlackHoleActive()) {
          const blackHoleX = width / 2;
          const blackHoleY = height / 2;
          const blackHoleLambda = 250;
          const blackHoleForce = 750000; // 5x stronger than before

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = blackHoleX - centerX;
          const dy = blackHoleY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            const forceMagnitude = (1 / blackHoleLambda) * Math.exp(-dist / blackHoleLambda) * blackHoleForce;
            let fx = (dx / dist) * forceMagnitude;
            let fy = (dy / dist) * forceMagnitude;

            // Non-conservative in x-coordinate: if moving away from black hole in x, reduce force to 75%
            if (particle.vx * dx < 0) { // Moving away in x (opposite signs)
              fx *= 0.75;
            }
            // Y-component remains conservative (no adjustment)

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Check for player paddle collision (right side)
        const playerPaddleY = getPlayerPaddleY();
        if (particle.vx > 0 && // Moving right
            particle.x + particle.width > rightPaddleX &&
            particle.x < rightPaddleX + paddleWidth &&
            particle.y + particle.height > playerPaddleY &&
            particle.y < playerPaddleY + paddleHeight) {

          // Play YOU paddle blip sound
          blip1Audio.currentTime = 0;
          blip1Audio.play().catch(err => console.log('Blip1 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - playerPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = rightPaddleX - particle.width;
        }

        // Check for enemy paddle collision (left side)
        if (particle.vx < 0 && // Moving left
            particle.x < leftPaddleX + paddleWidth &&
            particle.x + particle.width > leftPaddleX &&
            particle.y + particle.height > enemyPaddleY &&
            particle.y < enemyPaddleY + paddleHeight) {

          // Play THEM paddle blip sound
          blip2Audio.currentTime = 0;
          blip2Audio.play().catch(err => console.log('Blip2 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - enemyPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = leftPaddleX + paddleWidth;
        }

        // Check for left edge (YOU score - enemy missed)
        if (particle.x + particle.width < 0) {
          // Create red burst at contact point (you scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(0, contactY, '#ff0000');

          // Play THEM damage sound
          damage2Audio.currentTime = 0;
          damage2Audio.play().catch(err => console.log('Damage2 play failed:', err));

          // Flash enemy paddle
          flashPaddle(enemyPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            youScore++;
            rightScoreEl.textContent = youScore.toString();

            // Check for YOU reaching 10
            if (youScore === 10 && !getBlackHoleActive()) {
              activateBlackHole();
            } else if (youScore === 20) {
              endGame(true); // YOU win
            }
          }
          continue;
        }

        // Check for right edge (THEM score - player missed)
        if (particle.x > width) {
          // Create green burst at contact point (they scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(width, contactY, '#00ff00');

          // Play YOU damage sound
          damage1Audio.currentTime = 0;
          damage1Audio.play().catch(err => console.log('Damage1 play failed:', err));

          // Flash player paddle
          flashPaddle(playerPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            themScore++;
            leftScoreEl.textContent = themScore.toString();

            // Check for THEM reaching 10
            if (themScore === 10 && !getBlackHoleActive()) {
              endGame(false); // YOU lose
            } else if (themScore === 20) {
              endGame(false); // YOU lose
            }
          }
          continue;
        }

        // Bounce off top and bottom
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height) {
          particle.y = height - particle.height;
          particle.vy = -particle.vy;
        }

        // Update trail (store last 15 positions)
        if (particle.active) {
          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 15) {
            // Remove oldest trail element if it exists
            const oldest = particle.trail.shift();
            if (oldest.el) {
              oldest.el.remove();
            }
          }

          // Create/update trail elements
          particle.trail.forEach((trailPos, idx) => {
            if (!trailPos.el) {
              // Create new trail element
              const trailEl = particle.el.cloneNode(true);
              trailEl.style.pointerEvents = 'none';
              document.body.appendChild(trailEl);
              trailPos.el = trailEl;
            }

            // Update trail element position and style
            const age = particle.trail.length - idx - 1; // 0 = newest, 14 = oldest
            const opacity = 1 - (age + 1) / 16; // Fade from 0.94 to 0.06
            const scale = 1 - (age + 1) * 0.05; // Scale from 0.95 to 0.25

            trailPos.el.style.opacity = opacity.toString();
            trailPos.el.style.transform = `translate(${trailPos.x - parseFloat(particle.el.style.left)}px, ${trailPos.y - parseFloat(particle.el.style.top)}px) scale(${scale})`;
            trailPos.el.style.zIndex = (10000 - age - 1).toString(); // Behind main letter
          });
        }

        // Apply transform to main particle
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      }

      requestAnimationFrame(animate);
    }

    // Helper function to activate black hole
    function activateBlackHole() {
      setBlackHoleActive(true);

      // Increase AI speed
      enemyPaddleSpeed = 700;

      // Create black hole element
      const width = window.innerWidth;
      const height = window.innerHeight;
      blackHoleEl = document.createElement('div');
      blackHoleEl.style.position = 'fixed';
      blackHoleEl.style.left = (width / 2) + 'px';
      blackHoleEl.style.top = (height / 2) + 'px';
      blackHoleEl.style.width = '50px';
      blackHoleEl.style.height = '50px';
      blackHoleEl.style.marginLeft = '-25px';
      blackHoleEl.style.marginTop = '-25px';
      blackHoleEl.style.borderRadius = '50%';
      blackHoleEl.style.backgroundColor = '#000000';
      blackHoleEl.style.boxShadow = '0 0 30px 10px rgba(0, 0, 0, 0.8)';
      blackHoleEl.style.zIndex = '9999';
      blackHoleEl.style.pointerEvents = 'none';
      document.body.appendChild(blackHoleEl);

      // Animate the pulsing
      let pulseTime = 0;
      function pulseBlackHole() {
        if (!getBlackHoleActive() || !blackHoleEl) return;
        pulseTime += 0.05;
        const size = 40 + 10 * Math.sin(pulseTime);
        blackHoleEl.style.width = size + 'px';
        blackHoleEl.style.height = size + 'px';
        blackHoleEl.style.marginLeft = (-size / 2) + 'px';
        blackHoleEl.style.marginTop = (-size / 2) + 'px';
        requestAnimationFrame(pulseBlackHole);
      }
      pulseBlackHole();

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '20%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s ease-out';

      const mainText = document.createElement('div');
      mainText.textContent = 'BLACK HOLE ACTIVATED';
      mainText.style.fontSize = '64px';

      const subText = document.createElement('div');
      subText.textContent = '(GAME TO 20)';
      subText.style.fontSize = '32px';
      subText.style.marginTop = '10px';

      flashMessage.appendChild(mainText);
      flashMessage.appendChild(subText);
      document.body.appendChild(flashMessage);

      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => flashMessage.remove(), 2000);
      }, 4000);
    }

    // Helper function to end the game
    function endGame(playerWon) {
      setGameOver(true);

      // Play victory or defeat sound
      if (playerWon) {
        victoryAudio.currentTime = 0;
        victoryAudio.play().catch(err => console.log('Victory play failed:', err));
      } else {
        defeatAudio.currentTime = 0;
        defeatAudio.play().catch(err => console.log('Defeat play failed:', err));
      }

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontSize = '96px';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.whiteSpace = 'nowrap';
      flashMessage.textContent = playerWon ? 'VICTORY' : 'DEFEATED';
      document.body.appendChild(flashMessage);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // BIRD MODE
  // ============================================================================

</script>

<script>
  // ============================================================================
  // BIRD MODE DEBUG SETTINGS
  // ============================================================================
  const DRAW_FORCES = false;  // Set to false to disable force visualization

  function enterBirdMode() {
    if (birdModeActive) return;
    birdModeActive = true;

    try {
      console.log('Starting bird mode...');

      // Disable clicks on mystery button (but keep it visible so it can become a bird)
      const mysteryIcon = document.querySelector('.fa-question-circle');
      if (mysteryIcon) {
        const mysteryLink = mysteryIcon.closest('a.nav-link');
        if (mysteryLink) {
          mysteryLink.style.pointerEvents = 'none';
        }
      }

      // Create flashy "BIRD MODE ACTIVATED" message FIRST (before laggy operations)
      const flashMessage = document.createElement('div');
      flashMessage.textContent = 'BIRD MODE ACTIVATED';
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontSize = '64px';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff6b9d';
      flashMessage.style.textShadow = '0 0 10px #ff6b9d, 0 0 20px #ff6b9d, 0 0 30px #ff6b9d, 0 0 40px #ff6b9d';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff6b9d';
      flashMessage.style.boxShadow = '0 0 20px #ff6b9d, inset 0 0 20px rgba(255, 107, 157, 0.2)';
      flashMessage.style.zIndex = '100000';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s';
      document.body.appendChild(flashMessage);

      // Show for 1 second, then fade out over 2 seconds
      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => {
          flashMessage.remove();
        }, 2000);
      }, 1000);

      // Wait 50ms to ensure banner renders before starting laggy operations
      setTimeout(() => {
        // Wrap text
        ensureTextWrapped();

        // Lock body
        const scrollY = window.scrollY;
        document.body.classList.add('bird-locked');
        document.body.style.top = `-${scrollY}px`;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        });

        const particles = [];
        const MAX_BIRD_COUNT = 1000;

        // Find header characters to make them hawks (h1, or h2, or h3 if no h1)
        let headerElement = document.querySelector('h1');
        if (!headerElement) {
          headerElement = document.querySelector('h2');
        }
        if (!headerElement) {
          headerElement = document.querySelector('h3');
        }
        let h1Chars = [];
        if (headerElement) {
          h1Chars = Array.from(headerElement.querySelectorAll('.char'));
        }

        // Collect all character and glyph elements with their data
        // Separate hawks (always keep) from non-hawks (randomly select)
        const hawkElements = [];
        const nonHawkElements = [];

        // Collect all characters
        const chars = document.querySelectorAll('.char');
        chars.forEach(char => {
          const rect = char.getBoundingClientRect();

          // Skip if outside viewport
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth) {
            return;
          }

          const hawkIndex = h1Chars.indexOf(char);
          const isHawk = hawkIndex !== -1;

          const elem = {
            original: char,
            rect: rect,
            isChar: true,
            isHawk: isHawk,
            hawkIndex: hawkIndex,
            randomOrder: Math.random()  // For shuffling
          };

          if (isHawk) {
            hawkElements.push(elem);
          } else {
            nonHawkElements.push(elem);
          }
        });

        // Also collect glyphs and icons (all non-hawks)
        const glyphs = document.querySelectorAll('i, svg');
        glyphs.forEach(glyph => {
          const rect = glyph.getBoundingClientRect();

          // Skip if outside viewport or has no size
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth ||
              rect.width === 0 || rect.height === 0) {
            return;
          }

          nonHawkElements.push({
            original: glyph,
            rect: rect,
            isChar: false,
            isHawk: false,
            hawkIndex: -1,
            randomOrder: Math.random()  // For shuffling
          });
        });

        // Randomly shuffle non-hawks
        nonHawkElements.sort((a, b) => a.randomOrder - b.randomOrder);

        // Select non-hawks up to MAX_BIRD_COUNT - number of hawks
        const maxNonHawks = MAX_BIRD_COUNT - hawkElements.length;
        const selectedNonHawks = nonHawkElements.slice(0, maxNonHawks);
        const fadedNonHawks = nonHawkElements.slice(maxNonHawks);

        // Combine: all hawks + selected non-hawks become birds
        const birdElements = [...hawkElements, ...selectedNonHawks];

        // Process bird elements (become birds)
        birdElements.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Add to particles array (all bird elements become birds)
          particles.push({
            el: clone,
            x: rect.left,
            y: rect.top,
            vx: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,  // Hawks get tiny random velocity
            vy: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,
            width: rect.width,
            height: rect.height,
            isHawk: elem.isHawk,
            hawkIndex: elem.hawkIndex,  // -1 for non-hawks, 0+ for hawks
            isActive: !elem.isHawk,  // Hawks start dormant, boids start active
            originalX: rect.left,  // Store original position for dormant hawks
            originalY: rect.top
          });
        });

        // Process faded elements (fade out smoothly)
        fadedNonHawks.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Fade out this element smoothly
          clone.style.transition = 'opacity 3s ease-out';
          setTimeout(() => {
            clone.style.opacity = '0';
            setTimeout(() => {
              clone.remove();
            }, 3000);
          }, 10);
        });

        // Start animation
        // Create trajectory ray for hawk
        const trajectoryRay = document.createElement('div');
        trajectoryRay.id = 'hawk-trajectory-ray';
        trajectoryRay.style.position = 'fixed';
        trajectoryRay.style.height = '2px';
        trajectoryRay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        trajectoryRay.style.transformOrigin = '0 0';
        trajectoryRay.style.pointerEvents = 'none';
        trajectoryRay.style.zIndex = '9998';
        trajectoryRay.style.display = 'none';
        document.body.appendChild(trajectoryRay);

        // Create perpendicular lines container (SVG for efficient line drawing)
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'fear-lines-svg';
        svg.style.position = 'fixed';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '9997';
        document.body.appendChild(svg);

        // Create force vectors SVG overlay (for debug visualization)
        const forceVectorsSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        forceVectorsSvg.id = 'force-vectors-svg';
        forceVectorsSvg.style.position = 'fixed';
        forceVectorsSvg.style.top = '0';
        forceVectorsSvg.style.left = '0';
        forceVectorsSvg.style.width = '100%';
        forceVectorsSvg.style.height = '100%';
        forceVectorsSvg.style.pointerEvents = 'none';
        forceVectorsSvg.style.zIndex = '9999';
        forceVectorsSvg.style.display = DRAW_FORCES ? 'block' : 'none';
        document.body.appendChild(forceVectorsSvg);

        // Create force legend (for debug visualization)
        if (DRAW_FORCES) {
          const legend = document.createElement('div');
          legend.id = 'force-legend';
          legend.style.position = 'fixed';
          legend.style.top = '10px';
          legend.style.right = '10px';
          legend.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          legend.style.color = 'white';
          legend.style.padding = '10px';
          legend.style.fontFamily = 'monospace';
          legend.style.fontSize = '12px';
          legend.style.zIndex = '100001';
          legend.style.borderRadius = '5px';
          legend.style.lineHeight = '1.5';
          legend.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">FORCE LEGEND</div>
            <div><span style="color: #ff0000;">■</span> Repulsion (boid-boid)</div>
            <div><span style="color: #0000ff;">■</span> Cohesion</div>
            <div><span style="color: #00ff00;">■</span> Alignment</div>
            <div><span style="color: #00ffff;">■</span> Speed Stabilization</div>
            <div><span style="color: #ff8800;">■</span> Wall Repulsion</div>
            <div><span style="color: #ff00ff;">■</span> Fear</div>
            <div><span style="color: #ffff00;">■</span> Boid Attraction (hawks)</div>
            <div><span style="color: #ff69b4;">■</span> Hawk-Hawk Repulsion</div>
          `;
          document.body.appendChild(legend);
        }

        console.log('Starting animation with', particles.length, 'particles');
        startBirdAnimation(particles, trajectoryRay, svg, forceVectorsSvg);
      }, 50);  // End of 50ms setTimeout
    } catch (error) {
      console.error('Error in enterBirdMode:', error);
      birdModeActive = false;
      alert('Error starting bird mode: ' + error.message);
    }
  }

  function startBirdAnimation(particles, trajectoryRay, fearLinesSvg, forceVectorsSvg) {
    let lastTime = performance.now();
    let hawkInfos = [];  // Store all active hawks' positions and velocities for fear calculations

    const FORCE_MULTIPLIER = 25;  // Global force multiplication factor
    const MAX_SPEED = 400;   // Maximum speed
    const F_MAX = 10;  // Maximum force magnitude before clamping
    const FORCE_ARROW_SCALE = 20;  // Scale factor for visualizing force arrows

    // Repulsion parameters
    const LENGTH_SCALE = 20;  // px
    const R_REPULSION = 1 * LENGTH_SCALE;  // 20px
    const F_REPULSION = 5;  // Repulsion strength

    // Speed stabilization parameters
    const TARGET_SPEED = 15;  // px/s
    const TARGET_SPEED_HAWK = 50;  // px/s
    const F_SPEEDSTABILITY = 5;
    const F_SPEEDSTABILITY_HAWK = 2;

    // Alignment parameters
    const F_ALIGN = 2;

    // Wall repulsion parameters
    const WALL_REPULSION_DIST = 5 * LENGTH_SCALE;  // 100px
    const F_WALL_REPULSION = 4;

    // Hawk-specific wall repulsion (2x distance and magnitude)
    const WALL_REPULSION_DIST_HAWK = 1 * WALL_REPULSION_DIST;  // 200px
    const F_WALL_REPULSION_HAWK = .5 * F_WALL_REPULSION;  // 8

    // Hawk attraction parameters
    const F_ATTR_HAWK = 0.3;

    // Fear parameters
    const F_FEAR = 3;
    const FEAR_DIST = 15 * LENGTH_SCALE;  // 300px

    // Spatial grid parameters
    const CELL_SIZE = 2 * LENGTH_SCALE;  // 60px

    // Hawk release tracking
    let nextHawkIndex = 0;
    let nextHawkReleaseTime = 20.0;  // First hawk at 20 seconds (wall time)
    let elapsedTime = 0;  // Wall time in seconds

    function releaseHawk(hawk) {
      hawk.isActive = true;
      hawk.releaseTime = elapsedTime;  // Track when hawk was released

      // Play hawk call at 30% volume
      const hawkAudio = document.getElementById('hawk-call');
      if (hawkAudio) {
        hawkAudio.volume = 0.3;
        hawkAudio.currentTime = 0;
        hawkAudio.play().catch(e => console.log('Audio play failed:', e));
      }

      // Create big brown burst
      const burstX = hawk.x + hawk.width / 2;
      const burstY = hawk.y + hawk.height / 2;
      const burst = document.createElement('div');

      burst.style.position = 'fixed';
      burst.style.left = burstX + 'px';
      burst.style.top = burstY + 'px';
      burst.style.width = '0px';
      burst.style.height = '0px';
      burst.style.borderRadius = '50%';
      burst.style.backgroundColor = 'rgba(139, 69, 19, 0.6)';  // Brown color
      burst.style.transform = 'translate(-50%, -50%)';
      burst.style.pointerEvents = 'none';
      burst.style.zIndex = '9999';
      document.body.appendChild(burst);

      // Animate burst (much bigger)
      setTimeout(() => {
        burst.style.transition = 'all 0.6s ease-out';
        burst.style.width = '200px';
        burst.style.height = '200px';
        burst.style.backgroundColor = 'rgba(139, 69, 19, 0)';
      }, 10);

      setTimeout(() => burst.remove(), 650);
    }

    // Helper function to draw a force arrow in SVG
    function createArrow(x, y, fx, fy, color) {
      const length = Math.sqrt(fx * fx + fy * fy);
      if (length < 0.01) return null;  // Skip tiny forces

      const endX = x + fx * FORCE_ARROW_SCALE;
      const endY = y + fy * FORCE_ARROW_SCALE;

      // Create line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x);
      line.setAttribute('y1', y);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('opacity', '0.7');

      // Create arrowhead
      const arrowSize = 5;
      const angle = Math.atan2(fy, fx);
      const arrowX1 = endX - arrowSize * Math.cos(angle - Math.PI / 6);
      const arrowY1 = endY - arrowSize * Math.sin(angle - Math.PI / 6);
      const arrowX2 = endX - arrowSize * Math.cos(angle + Math.PI / 6);
      const arrowY2 = endY - arrowSize * Math.sin(angle + Math.PI / 6);

      const arrowhead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      arrowhead.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
      arrowhead.setAttribute('fill', color);
      arrowhead.setAttribute('opacity', '0.7');

      return { line, arrowhead };
    }

    function animate(currentTime) {
      if (!birdModeActive) return;

      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      // Update elapsed time (wall time in real seconds)
      elapsedTime += dt;

      // Simulation runs at 4x speed
      const simulationDt = dt * 4;

      // Clear hawk infos from previous frame
      hawkInfos = [];

      // Check if it's time to release the next hawk
      if (elapsedTime >= nextHawkReleaseTime) {
        // Find the hawk with hawkIndex === nextHawkIndex
        const hawkToRelease = particles.find(p => p.hawkIndex === nextHawkIndex);
        if (hawkToRelease && !hawkToRelease.isActive) {
          releaseHawk(hawkToRelease);
          nextHawkIndex++;
          // First hawk at 20s, then every 60s thereafter
          nextHawkReleaseTime += 60.0;
        }
      }

      // Build spatial grid (only for active, non-hawk particles)
      const grid = new Map();
      particles.forEach((particle, i) => {
        if (!particle.isActive || particle.isHawk) return;

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);
        const key = `${cellX},${cellY}`;

        if (!grid.has(key)) {
          grid.set(key, []);
        }
        grid.get(key).push(i);
      });

      // Check for hawk overlaps and hide captured particles
      particles.forEach((hawk, i) => {
        if (!hawk.isHawk || !hawk.isActive) return;

        // Hawks can't capture during their 2-second frozen period
        const timeSinceRelease = elapsedTime - (hawk.releaseTime || 0);
        if (timeSinceRelease < 2.0) return;

        particles.forEach((boid, j) => {
          if (i === j || !boid.isActive || boid.isHawk) return;

          // Check bounding box overlap
          if (hawk.x < boid.x + boid.width &&
              hawk.x + hawk.width > boid.x &&
              hawk.y < boid.y + boid.height &&
              hawk.y + hawk.height > boid.y) {
            // Overlap! Hide boid and create burst
            boid.isActive = false;
            boid.el.remove();

            // Play goose sound (75% honk, 25% yell)
            const soundId = Math.random() < 0.75 ? 'goose-honk' : 'goose-yell';
            const audio = document.getElementById(soundId);
            if (audio) {
              audio.currentTime = 0;
              audio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Create colorful burst
            const burstX = boid.x + boid.width / 2;
            const burstY = boid.y + boid.height / 2;
            const burst = document.createElement('div');

            // Random hue, high saturation, high lightness
            const hue = Math.floor(Math.random() * 360);
            const saturation = 70 + Math.floor(Math.random() * 20); // 70-90%
            const lightness = 60; // Medium-bright

            burst.style.position = 'fixed';
            burst.style.left = burstX + 'px';
            burst.style.top = burstY + 'px';
            burst.style.width = '0px';
            burst.style.height = '0px';
            burst.style.borderRadius = '50%';
            burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.6)`;
            burst.style.transform = 'translate(-50%, -50%)';
            burst.style.pointerEvents = 'none';
            burst.style.zIndex = '9999';
            document.body.appendChild(burst);

            // Animate burst
            setTimeout(() => {
              burst.style.transition = 'all 0.4s ease-out';
              burst.style.width = '60px';
              burst.style.height = '60px';
              burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`;
            }, 10);

            setTimeout(() => burst.remove(), 450);
          }
        });
      });

      // Apply forces to each particle
      particles.forEach((particle, i) => {
        if (!particle.isActive) return;  // Skip inactive particles

        // Initialize force tracking for debug visualization
        particle.forces = {
          speedStab: { x: 0, y: 0 },
          boidAttr: { x: 0, y: 0 },
          hawkRepulsion: { x: 0, y: 0 },
          wallRepulsion: { x: 0, y: 0 },
          repulsion: { x: 0, y: 0 },
          cohesion: { x: 0, y: 0 },
          alignment: { x: 0, y: 0 },
          fear: { x: 0, y: 0 }
        };

        // Hawks have their own forces
        if (particle.isHawk) {
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Keep hawk stationary for 2 seconds after release (for suspense)
          const timeSinceRelease = elapsedTime - (particle.releaseTime || 0);
          if (timeSinceRelease < 2.0) {
            // Hawk is frozen - keep it in place
            particle.vx = 0;
            particle.vy = 0;
            particle.x = particle.originalX;
            particle.y = particle.originalY;
            particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

            // Still store hawk info for fear calculations
            hawkInfos.push({
              x: centerX,
              y: centerY,
              vx: 0,
              vy: 0,
              speed: 0
            });
            return;  // Skip rest of hawk physics
          }

          let hawkForceX = 0;
          let hawkForceY = 0;

          // Speed stabilization force (weaker than boids, higher target speed)
          const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
          if (currentSpeed > 0) {
            const speedRatio = 1 - currentSpeed / TARGET_SPEED_HAWK;
            const speedForceMag = F_SPEEDSTABILITY_HAWK * Math.pow(speedRatio, 3);
            particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
            particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
            hawkForceX += particle.forces.speedStab.x;
            hawkForceY += particle.forces.speedStab.y;
          }

          // Attraction to nearest boid
          let nearestBoid = null;
          let nearestDist = Infinity;
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestBoid = { x: otherCenterX, y: otherCenterY, dist: dist };
            }
          });

          if (nearestBoid && nearestBoid.dist > 0) {
            const dx = nearestBoid.x - centerX;
            const dy = nearestBoid.y - centerY;
            particle.forces.boidAttr.x = (dx / nearestBoid.dist) * F_ATTR_HAWK;
            particle.forces.boidAttr.y = (dy / nearestBoid.dist) * F_ATTR_HAWK;
            hawkForceX += particle.forces.boidAttr.x;
            hawkForceY += particle.forces.boidAttr.y;
          }

          // Repulsion from nearest k hawks
          const K_HAWKS = 3;
          const HAWK_REPULSION_DIST = 50;  // px
          const F_HAWK_REPULSION = 0.5;  // Mild repulsion strength

          // Find all other active hawks
          const otherHawks = [];
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || !other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < HAWK_REPULSION_DIST) {
              otherHawks.push({ x: otherCenterX, y: otherCenterY, dist: dist });
            }
          });

          if (otherHawks.length > 0) {
            // Sort by distance and take k nearest
            otherHawks.sort((a, b) => a.dist - b.dist);
            const nearestKHawks = otherHawks.slice(0, K_HAWKS);

            // Calculate average position
            let avgHawkX = 0, avgHawkY = 0;
            nearestKHawks.forEach(h => {
              avgHawkX += h.x;
              avgHawkY += h.y;
            });
            avgHawkX /= nearestKHawks.length;
            avgHawkY /= nearestKHawks.length;

            // Calculate average distance
            let avgDist = 0;
            nearestKHawks.forEach(h => avgDist += h.dist);
            avgDist /= nearestKHawks.length;

            // Apply repulsive force (drops off linearly)
            if (avgDist > 0) {
              const repulsionStrength = F_HAWK_REPULSION * (1 - avgDist / HAWK_REPULSION_DIST);
              const dx = centerX - avgHawkX;
              const dy = centerY - avgHawkY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                particle.forces.hawkRepulsion.x = (dx / dist) * repulsionStrength;
                particle.forces.hawkRepulsion.y = (dy / dist) * repulsionStrength;
                hawkForceX += particle.forces.hawkRepulsion.x;
                hawkForceY += particle.forces.hawkRepulsion.y;
              }
            }
          }

          // Wall repulsion forces (stronger and longer range for hawks)
          const width = window.innerWidth;
          const height = window.innerHeight;

          let wallForceX = 0;
          let wallForceY = 0;

          // Left wall
          const distLeft = centerX;
          if (distLeft < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distLeft / WALL_REPULSION_DIST_HAWK);
            wallForceX += wallForceMag;  // Push right
          }

          // Right wall
          const distRight = width - centerX;
          if (distRight < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distRight / WALL_REPULSION_DIST_HAWK);
            wallForceX -= wallForceMag;  // Push left
          }

          // Top wall
          const distTop = centerY;
          if (distTop < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distTop / WALL_REPULSION_DIST_HAWK);
            wallForceY += wallForceMag;  // Push down
          }

          // Bottom wall
          const distBottom = height - centerY;
          if (distBottom < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distBottom / WALL_REPULSION_DIST_HAWK);
            wallForceY -= wallForceMag;  // Push up
          }

          particle.forces.wallRepulsion.x = wallForceX;
          particle.forces.wallRepulsion.y = wallForceY;
          hawkForceX += wallForceX;
          hawkForceY += wallForceY;

          // Clamp force to F_MAX
          const hawkForceMag = Math.sqrt(hawkForceX * hawkForceX + hawkForceY * hawkForceY);
          if (hawkForceMag > F_MAX) {
            hawkForceX = (hawkForceX / hawkForceMag) * F_MAX;
            hawkForceY = (hawkForceY / hawkForceMag) * F_MAX;
          }

          // Apply forces
          particle.vx += hawkForceX * FORCE_MULTIPLIER * simulationDt;
          particle.vy += hawkForceY * FORCE_MULTIPLIER * simulationDt;

          // Update position
          particle.x += particle.vx * simulationDt;
          particle.y += particle.vy * simulationDt;

          // Bounce off walls (width and height already declared above)
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx;
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx;
          }

          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy;
          } else if (particle.y + particle.height > height) {
            particle.y = height - particle.height;
            particle.vy = -particle.vy;
          }

          // Update visual position
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

          // Store hawk info for fear calculations
          hawkInfos.push({
            x: centerX,
            y: centerY,
            vx: particle.vx,
            vy: particle.vy,
            speed: currentSpeed
          });

          return;  // Skip boid forces
        }

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;

        // Accumulate total force
        let totalForceX = 0;
        let totalForceY = 0;

        // Fear force from all hawks
        let isFearful = false;
        hawkInfos.forEach(hawkInfo => {
          if (hawkInfo.speed > 0) {
            const toHawkX = hawkInfo.x - centerX;
            const toHawkY = hawkInfo.y - centerY;
            const distToHawk = Math.sqrt(toHawkX * toHawkX + toHawkY * toHawkY);

            // Check if boid is in front of hawk (dot product > 0)
            const toBoidX = centerX - hawkInfo.x;
            const toBoidY = centerY - hawkInfo.y;
            const dotProduct = toBoidX * hawkInfo.vx + toBoidY * hawkInfo.vy;

            if (distToHawk < FEAR_DIST && dotProduct > 0) {
              // Boid feels fear!
              isFearful = true;

              // Calculate perpendicular direction away from ray
              const dirX = hawkInfo.vx / hawkInfo.speed;
              const dirY = hawkInfo.vy / hawkInfo.speed;

              // Project boid position onto ray
              const projection = toBoidX * dirX + toBoidY * dirY;
              const rayPointX = hawkInfo.x + projection * dirX;
              const rayPointY = hawkInfo.y + projection * dirY;

              // Direction from ray to boid (perpendicular escape direction)
              const perpX = centerX - rayPointX;
              const perpY = centerY - rayPointY;
              const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

              if (perpDist > 0) {
                const fearMagnitude = F_FEAR * (1 - distToHawk / FEAR_DIST);

                // Blend perpendicular direction with "away from hawk" for 70 degree angle
                const perpNormX = perpX / perpDist;
                const perpNormY = perpY / perpDist;
                const awayNormX = -dirX;  // Opposite of hawk direction
                const awayNormY = -dirY;

                // sin(70°) ≈ 0.94, cos(70°) ≈ 0.34
                const fearDirX = 0.94 * perpNormX + 0.34 * awayNormX;
                const fearDirY = 0.94 * perpNormY + 0.34 * awayNormY;

                // Normalize the blended direction
                const fearDirMag = Math.sqrt(fearDirX * fearDirX + fearDirY * fearDirY);
                if (fearDirMag > 0) {
                  particle.forces.fear.x += (fearDirX / fearDirMag) * fearMagnitude;
                  particle.forces.fear.y += (fearDirY / fearDirMag) * fearMagnitude;
                  totalForceX += (fearDirX / fearDirMag) * fearMagnitude;
                  totalForceY += (fearDirY / fearDirMag) * fearMagnitude;
                }
              }
            }
          }
        });

        // Get particle's grid cell
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);

        // Find distances to particles in nearby cells (3x3 neighborhood)
        const distances = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${cellX + dx},${cellY + dy}`;
            const cellParticles = grid.get(key);
            if (!cellParticles) continue;

            cellParticles.forEach(j => {
              if (i === j) return;

              const other = particles[j];
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              const deltaX = otherCenterX - centerX;
              const deltaY = otherCenterY - centerY;
              const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

              distances.push({
                index: j,
                dist: dist,
                dx: deltaX,
                dy: deltaY,
                x: otherCenterX,
                y: otherCenterY
              });

              // Repulsion force (only for close neighbors) - 1/r form with offset
              if (dist <= R_REPULSION && dist > 0) {
                const normalizedDist = dist / LENGTH_SCALE;
                const repulsionMag = F_REPULSION * (1 - normalizedDist);
                particle.forces.repulsion.x -= (deltaX / dist) * repulsionMag;  // Negative = repulsion
                particle.forces.repulsion.y -= (deltaY / dist) * repulsionMag;
                totalForceX -= (deltaX / dist) * repulsionMag;
                totalForceY -= (deltaY / dist) * repulsionMag;
              }
            });
          }
        }

        // Sort by distance and take 5 nearest
        distances.sort((a, b) => a.dist - b.dist);
        const nearest5 = distances.slice(0, 5);

        // Calculate average position of 5 nearest neighbors
        let avgX = 0, avgY = 0;
        nearest5.forEach(n => {
          avgX += n.x;
          avgY += n.y;
        });
        avgX /= nearest5.length;
        avgY /= nearest5.length;

        // Cohesion force: magnitude 1 towards average position
        const dx = avgX - centerX;
        const dy = avgY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          particle.forces.cohesion.x = (dx / dist) * 1.0;
          particle.forces.cohesion.y = (dy / dist) * 1.0;
          totalForceX += particle.forces.cohesion.x;
          totalForceY += particle.forces.cohesion.y;
        }

        // Alignment force: magnitude F_ALIGN in direction of average velocity
        let avgVx = 0, avgVy = 0;
        nearest5.forEach(n => {
          const neighbor = particles[n.index];
          avgVx += neighbor.vx;
          avgVy += neighbor.vy;
        });
        avgVx /= nearest5.length;
        avgVy /= nearest5.length;

        const avgVelMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
        if (avgVelMag > 0) {
          particle.forces.alignment.x = (avgVx / avgVelMag) * F_ALIGN;
          particle.forces.alignment.y = (avgVy / avgVelMag) * F_ALIGN;
          totalForceX += particle.forces.alignment.x;
          totalForceY += particle.forces.alignment.y;
        }

        // Speed stabilization force
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (currentSpeed > 0) {
          const speedRatio = 1 - currentSpeed / TARGET_SPEED;
          const speedForceMag = F_SPEEDSTABILITY * Math.pow(speedRatio, 3);
          particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
          particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
          totalForceX += particle.forces.speedStab.x;
          totalForceY += particle.forces.speedStab.y;
        }

        // Wall repulsion forces
        const width = window.innerWidth;
        const height = window.innerHeight;

        let wallForceX = 0;
        let wallForceY = 0;

        // Left wall
        const distLeft = centerX;
        if (distLeft < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distLeft / WALL_REPULSION_DIST);
          wallForceX += wallForceMag;  // Push right
        }

        // Right wall
        const distRight = width - centerX;
        if (distRight < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distRight / WALL_REPULSION_DIST);
          wallForceX -= wallForceMag;  // Push left
        }

        // Top wall
        const distTop = centerY;
        if (distTop < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distTop / WALL_REPULSION_DIST);
          wallForceY += wallForceMag;  // Push down
        }

        // Bottom wall
        const distBottom = height - centerY;
        if (distBottom < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distBottom / WALL_REPULSION_DIST);
          wallForceY -= wallForceMag;  // Push up
        }

        particle.forces.wallRepulsion.x = wallForceX;
        particle.forces.wallRepulsion.y = wallForceY;
        totalForceX += wallForceX;
        totalForceY += wallForceY;

        // Clamp force to F_MAX
        const totalForceMag = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
        if (totalForceMag > F_MAX) {
          totalForceX = (totalForceX / totalForceMag) * F_MAX;
          totalForceY = (totalForceY / totalForceMag) * F_MAX;
        }

        // Apply total force with global multiplier
        particle.vx += totalForceX * FORCE_MULTIPLIER * simulationDt;
        particle.vy += totalForceY * FORCE_MULTIPLIER * simulationDt;

        // Limit speed
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed > MAX_SPEED) {
          particle.vx = (particle.vx / speed) * MAX_SPEED;
          particle.vy = (particle.vy / speed) * MAX_SPEED;
        }

        // Update position
        particle.x += particle.vx * simulationDt;
        particle.y += particle.vy * simulationDt;

        // Bounce off edges with perfect reflection (no energy loss)
        // (width and height already declared above for wall repulsion)

        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx;
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx;
        }

        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height + 7) {
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy;
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Keep dormant hawks at their original position
      particles.forEach(particle => {
        if (particle.isHawk && !particle.isActive) {
          particle.x = particle.originalX;
          particle.y = particle.originalY;
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      });

      // Draw force vectors for debug visualization
      if (DRAW_FORCES) {
        // Clear previous arrows
        while (forceVectorsSvg.firstChild) {
          forceVectorsSvg.removeChild(forceVectorsSvg.firstChild);
        }

        // Draw force vectors for each active particle
        particles.forEach(particle => {
          if (!particle.isActive || !particle.forces) return;

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Define force colors
          const forceColors = {
            repulsion: '#ff0000',       // Red (boid-boid repulsion)
            cohesion: '#0000ff',        // Blue
            alignment: '#00ff00',       // Green
            speedStab: '#00ffff',       // Cyan
            wallRepulsion: '#ff8800',   // Orange
            fear: '#ff00ff',            // Magenta
            boidAttr: '#ffff00',        // Yellow (hawk attraction to boids)
            hawkRepulsion: '#ff69b4'    // Pink (hawk-hawk repulsion)
          };

          // Draw each force type
          Object.entries(particle.forces).forEach(([forceType, force]) => {
            if (!forceColors[forceType]) return;

            const arrow = createArrow(centerX, centerY, force.x, force.y, forceColors[forceType]);
            if (arrow) {
              forceVectorsSvg.appendChild(arrow.line);
              forceVectorsSvg.appendChild(arrow.arrowhead);
            }
          });
        });
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // INITIALIZATION
  // ============================================================================
</script>

<script>
  // ============================================================================
  // PANIC MODE
  // ============================================================================

  let panicTextWrapped = false;
  let alarmAudio = null;
  let screamAudio = null;

  function enterPanicMode() {
    if (panicActive) return;
    panicActive = true;

    // Wrap text if not already wrapped by other modes
    if (!textWrapped && !panicTextWrapped) {
      panicTextWrapped = true;
      wrapTextNodes(document.body);
    }

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('panic-locked');
    document.body.style.top = `-${scrollY}px`;

    // Start alarm sound immediately
    const alarm = document.getElementById('panic-alarm');
    if (alarm) {
      alarmAudio = alarm;
      alarmAudio.loop = true;
      alarmAudio.currentTime = 0;
      alarmAudio.play();
    }

    // Start crowd scream after 2 seconds (when movement begins)
    setTimeout(() => {
      if (panicActive) {
        const scream = document.getElementById('panic-scream');
        if (scream) {
          screamAudio = scream;
          screamAudio.loop = true;
          screamAudio.currentTime = 0;
          screamAudio.play();
        }
      }
    }, 2000);

    // Create persistent flashing "PANIC MODE" text
    const panicLabel = document.createElement('div');
    panicLabel.id = 'panic-mode-label';
    panicLabel.textContent = 'PANIC MODE';
    panicLabel.style.position = 'fixed';
    panicLabel.style.top = '50%';
    panicLabel.style.left = '50%';
    panicLabel.style.transform = 'translate(-50%, -50%)';
    panicLabel.style.fontSize = '48px';
    panicLabel.style.fontFamily = 'Courier New, monospace';
    panicLabel.style.fontWeight = 'bold';
    panicLabel.style.letterSpacing = '4px';
    panicLabel.style.color = '#ff0000';
    panicLabel.style.textShadow = '0 0 10px #ff0000, 0 0 20px #ff0000';
    panicLabel.style.zIndex = '99999';
    panicLabel.style.pointerEvents = 'none';
    panicLabel.style.textAlign = 'center';
    document.body.appendChild(panicLabel);

    // Flash on/off every 0.51 seconds
    const flashInterval = setInterval(() => {
      if (!panicActive) {
        clearInterval(flashInterval);
        panicLabel.remove();
        return;
      }
      panicLabel.style.visibility = panicLabel.style.visibility === 'hidden' ? 'visible' : 'hidden';
    }, 510);

    const particles = [];

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startPanicAnimation(particles, scrollY);
  }

  function startPanicAnimation(particles, originalScrollY) {
    const DELAY_TIME = 2000; // 2 seconds delay before movement
    const MOVEMENT_TIME = 7800; // 7.8 seconds of movement
    const TOTAL_TIME = DELAY_TIME + MOVEMENT_TIME; // 9.8 seconds total
    const startTime = performance.now();

    function animate(currentTime) {
      if (!panicActive) return;

      // Calculate elapsed time in milliseconds
      const elapsed = currentTime - startTime;

      // Check if 9.8 seconds have elapsed
      if (elapsed >= TOTAL_TIME) {
        exitPanicMode(particles, originalScrollY);
        return;
      }

      // Calculate t as fraction of movement time (0 to 1)
      // During the first 2 seconds (delay), t = 0 (no movement)
      let t = 0;
      if (elapsed > DELAY_TIME) {
        t = (elapsed - DELAY_TIME) / MOVEMENT_TIME;
      }

      particles.forEach(particle => {
        // Epicycle parameterization: sum of circles at different frequencies
        // x(t) = sum_j r_j * cos(2π * j * t + theta_j) - offset_x
        // y(t) = sum_j r_j * sin(2π * j * t + theta_j) - offset_y
        let dx = 0;
        let dy = 0;

        for (let j = 0; j < particle.radii.length; j++) {
          const freq = j + 1; // Frequency is 1, 2, 3, ...
          const angle = 2 * Math.PI * freq * t * particle.signs[j] + particle.thetas[j];
          dx += particle.radii[j] * Math.cos(angle);
          dy += particle.radii[j] * Math.sin(angle);
        }

        // Subtract offsets to ensure path starts at origin
        dx -= particle.offset_x;
        dy -= particle.offset_y;

        // Apply radial coefficient to make letters drift farther over time
        // radial_coeff = max(1, elapsed_in_seconds + 2 - TOTAL_TIME_in_seconds)
        const elapsed_seconds = elapsed / 1000;
        const total_seconds = TOTAL_TIME / 1000;
        const radial_coeff = Math.max(1, elapsed_seconds + 2 - total_seconds);
        dx *= radial_coeff;
        dy *= radial_coeff;

        // Calculate current position (original position + offset)
        const x = particle.x0 + dx;
        const y = particle.y0 + dy;

        // Apply transform (relative to the element's original left/top)
        particle.el.style.transform = `translate(${x - parseFloat(particle.el.style.left)}px, ${y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  function exitPanicMode(particles, originalScrollY) {
    panicActive = false;

    // Stop and clean up audio
    if (alarmAudio) {
      alarmAudio.pause();
      alarmAudio.currentTime = 0;
      alarmAudio = null;
    }
    if (screamAudio) {
      screamAudio.pause();
      screamAudio.currentTime = 0;
      screamAudio = null;
    }

    // Remove all particles
    particles.forEach(particle => {
      particle.el.remove();
    });

    // Remove flashing label
    const panicLabel = document.getElementById('panic-mode-label');
    if (panicLabel) {
      panicLabel.remove();
    }

    // Restore original characters
    document.querySelectorAll('.char').forEach(char => {
      char.style.visibility = '';
    });

    // Restore original glyphs
    document.querySelectorAll('i, svg').forEach(glyph => {
      glyph.style.visibility = '';
    });

    // Unlock body
    document.body.classList.remove('panic-locked');
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.left = '';
    document.body.style.right = '';
    document.body.style.overflow = '';
    document.body.style.width = '';
    window.scrollTo(0, originalScrollY);
  }
</script>

<script>
  // ============================================================================
  // NAVIGATION AND MYSTERY BUTTON LOGIC
  // ============================================================================

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    // Add mysterious glyphs to navbar
    const navList = document.querySelector('nav ul.navbar-nav');
    if (navList) {
      // Single question mark icon that randomly picks a mode
      const mysteryLi = document.createElement('li');
      mysteryLi.className = 'nav-item active';

      const mysteryLink = document.createElement('a');
      mysteryLink.className = 'nav-link';
      mysteryLink.style.cursor = 'pointer';
      mysteryLink.href = '#';

      const mysteryIcon = document.createElement('i');
      mysteryIcon.className = 'fas fa-question-circle';

      mysteryLink.appendChild(mysteryIcon);
      mysteryLi.appendChild(mysteryLink);

      mysteryLink.addEventListener('click', (e) => {
        e.preventDefault();

        // Check localStorage for click count
        let clickCount = parseInt(localStorage.getItem('mysteryButtonClicks') || '0');

        // If user hasn't clicked 3 times yet, show warning and increment
        if (clickCount < 3) {
          const messages = ["Hey, stop that!", "Can't you read?", "I'm serious!"];
          alert(messages[clickCount]);
          clickCount++;
          localStorage.setItem('mysteryButtonClicks', clickCount.toString());
          return; // Don't activate mode
        }

        // After 3 clicks, cycle through modes sequentially
        // Define the rotation order
        const modeSequence = ['shatter', 'gravity', 'bird', 'splash', 'vacuum', 'panic', 'pong'];

        // Get current mode index with error handling
        let modeIndex = 0;
        try {
          const storedIndex = localStorage.getItem('mysteryModeIndex');
          if (storedIndex !== null) {
            const parsed = parseInt(storedIndex);
            // Validate the index is within bounds
            if (!isNaN(parsed) && parsed >= 0 && parsed < modeSequence.length) {
              modeIndex = parsed;
            } else {
              // Invalid index, reset to 0
              console.warn('Invalid mysteryModeIndex, resetting to 0');
              modeIndex = 0;
            }
          }
        } catch (e) {
          console.error('Error reading mysteryModeIndex:', e);
          modeIndex = 0;
        }

        // Get the current mode
        const currentMode = modeSequence[modeIndex];

        // Increment and save the next index (with wraparound)
        const nextIndex = (modeIndex + 1) % modeSequence.length;
        try {
          localStorage.setItem('mysteryModeIndex', nextIndex.toString());
        } catch (e) {
          console.error('Error saving mysteryModeIndex:', e);
        }

        // Reset button appearance (remove hover state)
        mysteryLink.blur();
        mysteryLink.style.setProperty('background-color', '', 'important');
        mysteryLink.style.setProperty('color', '', 'important');
        mysteryIcon.style.setProperty('color', 'black', 'important');

        // Activate the selected mode with error handling
        try {
          switch(currentMode) {
            case 'shatter':
              if (typeof enterShatterMode === 'function') {
                enterShatterMode();
              } else {
                console.error('enterShatterMode is not defined');
              }
              break;
            case 'gravity':
              if (typeof enterGravityMode === 'function') {
                enterGravityMode();
              } else {
                console.error('enterGravityMode is not defined');
              }
              break;
            case 'bird':
              if (typeof enterBirdMode === 'function') {
                enterBirdMode();
              } else {
                console.error('enterBirdMode is not defined');
              }
              break;
            case 'splash':
              window.location.href = '/splash/';
              break;
            case 'vacuum':
              if (typeof enterVacuumMode === 'function') {
                enterVacuumMode();
              } else {
                console.error('enterVacuumMode is not defined');
              }
              break;
            case 'panic':
              if (typeof enterPanicMode === 'function') {
                enterPanicMode();
              } else {
                console.error('enterPanicMode is not defined');
              }
              break;
            case 'pong':
              if (typeof enterPongMode === 'function') {
                enterPongMode();
              } else {
                console.error('enterPongMode is not defined');
              }
              break;
            default:
              console.error('Unknown mode:', currentMode);
          }
        } catch (e) {
          console.error('Error activating mode:', currentMode, e);
        }
      });

      navList.appendChild(mysteryLi);

      /* DEBUG VERSION: Uncomment to show all five icons for debugging
      // Shatter mode icon (question mark)
      const shatterLi = document.createElement('li');
      shatterLi.className = 'nav-item active';

      const shatterLink = document.createElement('a');
      shatterLink.className = 'nav-link';
      shatterLink.style.cursor = 'pointer';
      shatterLink.href = '#';

      const shatterIcon = document.createElement('i');
      shatterIcon.className = 'fas fa-question-circle';

      shatterLink.appendChild(shatterIcon);
      shatterLi.appendChild(shatterLink);

      shatterLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterShatterMode();
      });

      navList.appendChild(shatterLi);

      // Gravity mode icon (magnet)
      const gravityLi = document.createElement('li');
      gravityLi.className = 'nav-item active';

      const gravityLink = document.createElement('a');
      gravityLink.className = 'nav-link';
      gravityLink.style.cursor = 'pointer';
      gravityLink.href = '#';

      const gravityIcon = document.createElement('i');
      gravityIcon.className = 'fas fa-magnet';

      gravityLink.appendChild(gravityIcon);
      gravityLi.appendChild(gravityLink);

      gravityLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterGravityMode();
      });

      navList.appendChild(gravityLi);

      // Vacuum mode icon (meteor)
      const vacuumLi = document.createElement('li');
      vacuumLi.className = 'nav-item active';

      const vacuumLink = document.createElement('a');
      vacuumLink.className = 'nav-link';
      vacuumLink.style.cursor = 'pointer';
      vacuumLink.href = '#';

      const vacuumIcon = document.createElement('i');
      vacuumIcon.className = 'fas fa-meteor';

      vacuumLink.appendChild(vacuumIcon);
      vacuumLi.appendChild(vacuumLink);

      vacuumLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterVacuumMode();
      });

      navList.appendChild(vacuumLi);

      // Splash page link icon (home)
      const splashLi = document.createElement('li');
      splashLi.className = 'nav-item active';

      const splashLink = document.createElement('a');
      splashLink.className = 'nav-link';
      splashLink.style.cursor = 'pointer';
      splashLink.href = '/splash/';

      const splashIcon = document.createElement('i');
      splashIcon.className = 'fas fa-home';

      splashLink.appendChild(splashIcon);
      splashLi.appendChild(splashLink);

      navList.appendChild(splashLi);

      // Pong mode icon (gamepad)
      const pongLi = document.createElement('li');
      pongLi.className = 'nav-item active';

      const pongLink = document.createElement('a');
      pongLink.className = 'nav-link';
      pongLink.style.cursor = 'pointer';
      pongLink.href = '#';

      const pongIcon = document.createElement('i');
      pongIcon.className = 'fas fa-gamepad';

      pongLink.appendChild(pongIcon);
      pongLi.appendChild(pongLink);

      pongLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterPongMode();
      });

      navList.appendChild(pongLi);
      */
    }
  });
</script>



    <div class="page-content" style="flex: 1 0 auto;">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title" style="text-align:center">Snowflake</h1>
  </header>
<!--     <p style="text-align:center;font-size:200%;"></p> -->
  
<div class="container">

  <hr class="featurette-divider">
  
  <div class="post-content">
    <p>A word lives at every node in this tree, and each pair of connected words makes a common compound word or phrase. The dots on the line segments indicate which word comes second in the compound word or phrase. The word in the middle – and the puzzle’s answer – is BLUE.</p>

<p><br /></p>

<p align="center">
  <img src="/img/snowflake/snowflakesol.png" width="70%" />
</p>

  </div>
  
  <hr class="featurette-divider">
  
  <p style="text-align:center"> <a href="/puzzles/snowflake/" style="font-size:16px">back to puzzle</a></p>

</div>

</article>

      </div>
    </div>

    <div class="text-center p-3" style="background-color: #e8e8e8;">
  <div class="container ">
    <div class="row justify-content-md-center">

      <div class="col-2">
        <p class="text-center">
          <i class="far fa-envelope"></i>
          <a href="mailto:jsi@berkeley.edu">jsi@berkeley.edu</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-github"></i>
          <a href="https://github.com/james-simon">james-simon</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fas fa-graduation-cap"></i>
          <a href=https://scholar.google.com/citations?user=zjGfh3sAAAAJ&hl=en>gScholar</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-instagram"></i>
          <a href="https://instagram.com/sam.simon17">sam.simon17</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          SSN: 314-15-9265
        </p>
      </div>

    </div>
  </div>
</div>
</footer>

  </body>

</html>
