<!DOCTYPE html>
<html>

  <head>
  
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: { autoNumber: "AMS" },
        tagSide: "right"
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      }
    });
    MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function () {
      MathJax.InputJax.TeX.Stack.Item.AMSarray.Augment({
        clearTag() {
          if (!this.global.notags) {
            this.super(arguments).clearTag.call(this);
          }
        }
      });
    });
  </script>
  <script type="text/javascript" charset="utf-8"
    src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML">
  </script>


  <!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Reflections on introductory neuroscience reading</title>
  <meta name="description" content="Have you ever lived in a neighborhood for years and realized, as you prepare to move out, that you never got to know the guy who lives next door? For me, tha...">

  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">

  <!-- <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">
  <script src="/boostrap/js/bootstrap.js"></script> -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">

  <link rel="canonical" href="http://james-simon.github.io/blog/neuro-learnings/">
  <link rel="alternate" type="application/rss+xml" title="Jamie Simon" href="http://james-simon.github.io/feed.xml">

  <style>
    body {
      font-family: "et-book", "ETBookOT", "ET Book", Georgia, "Times New Roman", serif !important;
    }

    a:link {
      color: #1a4d8f;
      text-decoration: none;
    }

    a:visited {
      color: #6b2d8f;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>

  

</head>


  <body style="display: flex; flex-direction: column; min-height: 100vh; margin: 0;">

    <!-- <header class="site-header"> -->
    <!-- <a class="site-title" href="/">Jamie Simon</a> -->
<!-- </header> -->

    <style>
      .nav-link {
        transition: all 0.2s ease;
        border-radius: 4px;
        padding: 8px 16px !important;
      }

      .nav-link:hover {
        background-color: #333 !important;
        color: white !important;
      }

      .nav-link:hover i {
        color: white !important;
      }

      /* Hide text on narrow screens, show only icons */
      @media (max-width: 767px) {
        .nav-link .nav-text {
          display: none;
        }
        .nav-link {
          padding: 8px 12px !important;
        }
      }
    </style>

    <nav class="navbar navbar-expand navbar-light" style="background-color: #e8e8e8;">
      <div class = "container">
        <a class="navbar-brand" href="/">Jamie Simon</a></span> </a>
        <div class="navbar-collapse">
          <ul class="nav navbar-nav ml-auto" style="flex-wrap: nowrap;">
            <li class = "nav-item active"><a class="nav-link" href="/research/"><i class="fas fa-cogs"></i><span class="nav-text"> Research</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/blog/"><i class="fas fa-seedling"></i><span class="nav-text"> Blog</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/puzzles/"><i class="fab fa-laravel"></i><span class="nav-text"> Puzzles</span></a></li>
          </ul>
        </div>
      </div>
    </nav>

    <style>
  .char {
    display: inline;
    margin: 0;
    padding: 0;
    border: 0;
    vertical-align: baseline;
    line-height: inherit;
    font: inherit;
    font-size: inherit;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    color: inherit;
    white-space: inherit;
    letter-spacing: inherit;
    word-spacing: inherit;
    text-decoration: inherit;
    text-transform: inherit;
    background: transparent;
  }

  .char-particle {
    position: fixed;
    margin: 0;
    will-change: transform;
    pointer-events: none;
  }

  body.shatter-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.bird-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.panic-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  #shatter-overlay-blocker {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 9999;
    display: none;
  }

  body.shatter-locked #shatter-overlay-blocker {
    display: block;
  }
</style>

<div id="shatter-overlay-blocker"></div>
<audio id="shatter-audio" preload="auto" src="/audio/glass_bottle_breaking.mp3"></audio>
<audio id="pop-1" preload="auto" src="/audio/pop_1.mp3"></audio>
<audio id="pop-2" preload="auto" src="/audio/pop_2.mp3"></audio>
<audio id="pop-3" preload="auto" src="/audio/pop_3.mp3"></audio>
<audio id="pop-4" preload="auto" src="/audio/pop_4.mp3"></audio>
<!-- Bird mode audio -->
<audio id="goose-honk" src="/audio/bird_sounds/goose_honk.mp3" preload="auto"></audio>
<audio id="goose-yell" src="/audio/bird_sounds/goose_yell.mp3" preload="auto"></audio>
<audio id="hawk-call" src="/audio/bird_sounds/hawk_call.mp3" preload="auto"></audio>
<!-- Panic mode audio -->
<audio id="panic-alarm" preload="auto" src="/audio/alarm.mp3"></audio>
<audio id="panic-scream" preload="auto" src="/audio/crowd_scream.mp3"></audio>

<script>
  // ============================================================================
  // SHARED STATE AND UTILITIES FOR INTERACTIVE MODES
  // ============================================================================

  // Global state
  let shatterActive = false;
  let gravityActive = false;
  let vacuumActive = false;
  let pongActive = false;
  let birdModeActive = false;
  let panicActive = false;
  let mouseX = 0;
  let mouseY = 0;
  let prevMouseX = 0;
  let prevMouseY = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function playRandomPop() {
    const popIndex = Math.floor(Math.random() * 4) + 1;
    const audio = document.getElementById(`pop-${popIndex}`);
    if (audio) {
      audio.volume = 0.3; // Quieter pops
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Pop sound failed:', err));
    }
  }

  // Check if a point is close to a line segment
  function distanceToLineSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;

    if (lengthSquared === 0) {
      // Line segment is a point
      const distX = px - x1;
      const distY = py - y1;
      return Math.sqrt(distX * distX + distY * distY);
    }

    // Project point onto line segment
    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t)); // Clamp to [0, 1]

    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;

    const distX = px - closestX;
    const distY = py - closestY;
    return Math.sqrt(distX * distX + distY * distY);
  }

  function wrapTextNodes(node) {
    // Skip script, style, and interactive mode elements
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName;
      const elemId = node.id;

      // Skip these elements entirely
      if (tagName === 'SCRIPT' || tagName === 'STYLE' ||
          tagName === 'CODE' || tagName === 'PRE' ||
          tagName === 'KBD' || tagName === 'SAMP' ||
          tagName === 'TEXTAREA' || tagName === 'INPUT' ||
          tagName === 'SELECT' || tagName === 'BUTTON' ||
          elemId === 'shatter-overlay-blocker' ||
          elemId === 'shatter-audio' ||
          elemId === 'panic-button' ||
          elemId?.startsWith('pop-')) {
        return;
      }

      // Skip fixed/absolute positioned elements (like nav, modals, etc.)
      const style = window.getComputedStyle(node);
      if (style.position === 'fixed' || style.position === 'absolute') {
        return;
      }

      // Skip elements that are hidden
      if (style.display === 'none' || style.visibility === 'hidden') {
        return;
      }
    }

    // If it's a text node, wrap each character
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text.trim().length === 0) return; // Skip whitespace-only nodes

      const fragment = document.createDocumentFragment();
      // Use Array.from to properly handle multi-byte characters like emojis
      const chars = Array.from(text);
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === ' ') {
          // Preserve spaces as regular text nodes
          fragment.appendChild(document.createTextNode(' '));
        } else {
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = char;
          fragment.appendChild(span);
        }
      }
      node.parentNode.replaceChild(fragment, node);
    }
    // Recursively process child nodes
    else if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes);
      children.forEach(child => wrapTextNodes(child));
    }
  }

  // Gaussian random number generator (Box-Muller transform)
  function gaussianRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * stdDev + mean;
  }

  // Track if text has been wrapped
  let textWrapped = false;

  // Wrap text lazily when first mode is activated
  function ensureTextWrapped() {
    if (textWrapped) return;
    textWrapped = true;
    wrapTextNodes(document.body);
  }
</script>

<script>
  // ============================================================================
  // SHATTER MODE
  // ============================================================================

  function enterShatterMode() {
    if (shatterActive) return;
    shatterActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    const particles = [];

    // Helper function to create particle from element
    function createParticle(element, rect, isText = false) {
      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the element
      const clone = element.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(element);

      // For icon elements (i, svg), copy minimal styles to avoid interfering with pseudo-elements
      if (element.tagName === 'I' || element.tagName === 'SVG') {
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.color = computedStyle.color;
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      } else {
        // For other elements, copy full styles
        // Ensure emoji fonts are preserved by adding them to the font stack
        const fontFamily = computedStyle.fontFamily;
        clone.style.fontFamily = fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.fontWeight = computedStyle.fontWeight;
        clone.style.color = computedStyle.color;
        clone.style.backgroundColor = computedStyle.backgroundColor;
        clone.style.border = computedStyle.border;
        clone.style.borderRadius = computedStyle.borderRadius;
        clone.style.padding = computedStyle.padding;

        // Preserve dimensions for all elements to prevent shrinking
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      }

      // Set z-index: text always on top, then smaller elements in front
      if (isText) {
        clone.style.zIndex = '10000';
      } else {
        // Calculate area and set z-index inversely (smaller = higher z)
        const area = rect.width * rect.height;
        // Map area to z-index range 1000-9999 (larger area = lower z)
        const zIndex = Math.max(1000, Math.min(9999, 9999 - Math.floor(area / 10)));
        clone.style.zIndex = zIndex.toString();
      }

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      element.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: rect.width,
        height: rect.height
      });
    }

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();
      createParticle(char, rect, true); // isText = true
    });

    // Collect all other shatterable elements
    const elements = document.querySelectorAll('img, button, .styled-box, h1, h2, h3, h4, h5, h6, blockquote, svg, i, nav span, nav div');
    elements.forEach(el => {
      // Skip if it's the overlay blocker
      if (el.id === 'shatter-overlay-blocker') return;

      // Skip empty elements or elements with no visible content
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return;

      createParticle(el, rect);
    });

    // Collect line breaks and render them as small horizontal lines
    const lineBreaks = document.querySelectorAll('br');
    lineBreaks.forEach(br => {
      const rect = br.getBoundingClientRect();

      // Create a visible line element for the br
      const line = document.createElement('div');
      line.style.width = '20px';
      line.style.height = '2px';
      line.style.backgroundColor = '#999';
      line.style.position = 'fixed';
      line.style.left = rect.left + 'px';
      line.style.top = rect.top + 'px';
      line.classList.add('char-particle');

      // Add to body
      document.body.appendChild(line);

      // Hide original
      br.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: line,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: 20,
        height: 2
      });
    });

    // Play shatter sound after text wrapping and particle collection
    const audio = document.getElementById('shatter-audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Audio play failed:', err));
    }

    // Start animation
    startShatterAnimation(particles);
  }

  function startShatterAnimation(particles) {
    let lastTime = performance.now();
    const gravity = 1000; // Doubled gravity for faster fall
    const damping = 0.6; // More energy loss on bounce

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Apply gravity
        particle.vy += gravity * dt;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // GRAVITY MODE
  // ============================================================================

  function enterGravityMode() {
    if (gravityActive) return;
    gravityActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "GRAVITY ON" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'GRAVITY ON';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00bfff';
    flashMessage.style.textShadow = '0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00bfff';
    flashMessage.style.boxShadow = '0 0 20px #00bfff, inset 0 0 20px rgba(0, 191, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startGravityAnimation(particles);
  }

  function startGravityAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 150; // Falloff distance for exponential potential

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 5000;
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  // ============================================================================
  // VACUUM MODE
  // ============================================================================

  function enterVacuumMode() {
    if (vacuumActive) return;
    vacuumActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "VACUUM MODE INITIATED" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'VACUUM MODE INITIATED';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00ff00';
    flashMessage.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00ff00';
    flashMessage.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Keep a history of 15 mouse positions for smoother direction calculation
    const mouseHistory = [];
    const HISTORY_LENGTH = 15;

    // Store vacuumed particles in order for burping
    const vacuumedParticles = [];

    // Track mouse position and update history
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;

      // Only add to history if mouse actually moved
      if (prevMouseX !== null && prevMouseY !== null) {
        const dx = mouseX - prevMouseX;
        const dy = mouseY - prevMouseY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.1) { // Only count as movement if moved enough
          mouseHistory.push({x: mouseX, y: mouseY});

          // Keep only last 5 positions
          if (mouseHistory.length > HISTORY_LENGTH) {
            mouseHistory.shift();
          }
        }
      }
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport or has no width (e.g., newlines)
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startVacuumAnimation(particles, vacuumedParticles, mouseHistory);
  }

  function startVacuumAnimation(particles, vacuumedParticles, mouseHistory) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 300; // Falloff distance for exponential potential
    const velocityDamping = 0.99; // Per-frame velocity damping
    const WAIT_TIME = 5; // seconds to wait before burp mode
    const V_BURP = 1000; // pixels per second
    const BURP_RATE = 30; // chars per second
    let allParticlesGoneTime = null;
    let burpAudio = null;
    let burpStarted = false;
    const burpedParticles = []; // Active burped particles

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      // Only check for particle removal if we have a valid mouse position
      if (mouseX !== null && mouseY !== null && prevMouseX !== null && prevMouseY !== null) {
        // Filter out particles that should be removed
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];

          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Also check distance to line segment traced by mouse movement
          const distToPath = distanceToLineSegment(centerX, centerY, prevMouseX, prevMouseY, mouseX, mouseY);

          // Effective capture radius is proportional to particle size
          const effectiveRadius = Math.min(particle.width, particle.height) / 2;

          // Remove particle if within effective radius of current mouse position or path
          if (dist < effectiveRadius || distToPath < effectiveRadius) {
            // Store particle info for burping later
            vacuumedParticles.push({
              el: particle.el,
              x: particle.x,
              y: particle.y,
              vx: particle.vx,
              vy: particle.vy,
              width: particle.width,
              height: particle.height
            });

            // Hide but don't remove from DOM yet (we'll reuse it for burping)
            particle.el.style.display = 'none';
            particles.splice(i, 1);
            playRandomPop(); // Play pop sound
            continue;
          }
        }
      }

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ), 30x stronger than base
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 150000; // 30x force
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Apply velocity damping
        particle.vx *= velocityDamping;
        particle.vy *= velocityDamping;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Update previous mouse position for next frame
      prevMouseX = mouseX;
      prevMouseY = mouseY;

      // Check if all particles are gone
      if (particles.length === 0 && allParticlesGoneTime === null) {
        allParticlesGoneTime = currentTime;

        // Create BURP INCOMING flash message
        const burpWarning = document.createElement('div');
        burpWarning.id = 'burp-warning';
        burpWarning.textContent = 'BURP INCOMING';
        burpWarning.style.position = 'fixed';
        burpWarning.style.top = '50%';
        burpWarning.style.left = '50%';
        burpWarning.style.transform = 'translate(-50%, -50%)';
        burpWarning.style.fontSize = '64px';
        burpWarning.style.fontFamily = 'Courier New, monospace';
        burpWarning.style.fontWeight = 'bold';
        burpWarning.style.letterSpacing = '4px';
        burpWarning.style.color = '#00ff00';
        burpWarning.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
        burpWarning.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        burpWarning.style.padding = '30px 50px';
        burpWarning.style.border = '4px solid #00ff00';
        burpWarning.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
        burpWarning.style.zIndex = '100000';
        burpWarning.style.pointerEvents = 'none';
        burpWarning.style.textAlign = 'center';
        burpWarning.style.display = 'none';
        document.body.appendChild(burpWarning);

        // Flash with 0.5s on, 0.5s off starting at 3 seconds (last 2 seconds before burp)
        let flashStartTime = null;

        function flashBurpWarning(time) {
          const elapsed = (time - allParticlesGoneTime) / 1000;

          if (elapsed >= 3 && elapsed < WAIT_TIME) {
            if (flashStartTime === null) flashStartTime = time;
            const flashElapsed = (time - flashStartTime) / 1000;
            const cycleTime = flashElapsed % 1.0; // 1 second cycle

            if (cycleTime < 0.5) {
              burpWarning.style.display = 'block';
            } else {
              burpWarning.style.display = 'none';
            }

            requestAnimationFrame(flashBurpWarning);
          } else if (elapsed >= WAIT_TIME) {
            // Remove warning when burp starts
            burpWarning.remove();
          } else if (elapsed < 3) {
            // Keep flashing until we reach 3 seconds
            requestAnimationFrame(flashBurpWarning);
          }
        }

        requestAnimationFrame(flashBurpWarning);
      }

      // Start burp mode after WAIT_TIME
      if (allParticlesGoneTime !== null && burpAudio === null) {
        const elapsed = (currentTime - allParticlesGoneTime) / 1000;

        if (elapsed >= WAIT_TIME && !burpStarted) {
          burpStarted = true;

          burpAudio = new Audio('/audio/burp_loop.mp3');
          burpAudio.loop = true;
          burpAudio.volume = 0.5;
          burpAudio.play();

          // Start burping particles at BURP_RATE
          let lastBurpTime = currentTime;
          const burpInterval = 1000 / BURP_RATE; // ms between burps

          function burpParticle() {
            if (vacuumedParticles.length > 0) {
              // Get current mouse direction
              let dirX = 0, dirY = 1; // Default down
              if (mouseHistory.length >= 2) {
                const oldest = mouseHistory[0];
                const newest = mouseHistory[mouseHistory.length - 1];
                const histDx = newest.x - oldest.x;
                const histDy = newest.y - oldest.y;
                const histDist = Math.sqrt(histDx * histDx + histDy * histDy);

                if (histDist > 0.01) {
                  // Direction is same as mouse movement
                  dirX = histDx / histDist;
                  dirY = histDy / histDist;
                }
              }

              // Pop from end (reverse order)
              const particle = vacuumedParticles.pop();

              // Reset particle position to mouse (centered on particle)
              particle.x = mouseX - particle.width / 2;
              particle.y = mouseY - particle.height / 2;

              // Add Gaussian angular jitter (mean 0, stdev 3 degrees)
              const jitterAngle = gaussianRandom(0, 3) * Math.PI / 180; // Convert to radians
              const currentAngle = Math.atan2(dirY, dirX);
              const newAngle = currentAngle + jitterAngle;
              const jitteredDirX = Math.cos(newAngle);
              const jitteredDirY = Math.sin(newAngle);

              particle.vx = jitteredDirX * V_BURP;
              particle.vy = jitteredDirY * V_BURP;

              // Show particle again
              particle.el.style.display = 'block';
              particle.el.style.left = particle.x + 'px';
              particle.el.style.top = particle.y + 'px';

              burpedParticles.push(particle);
            }

            // Schedule next burp if more particles remain
            if (vacuumedParticles.length > 0) {
              setTimeout(burpParticle, burpInterval);
            } else {
              // All particles burped out, stop the audio
              if (burpAudio) {
                burpAudio.pause();
                burpAudio.currentTime = 0;
              }
            }
          }

          // Start burping
          burpParticle();
        }
      }

      // Animate burped particles with gravity and bouncing
      if (burpStarted && burpedParticles.length > 0) {
        const gravity = 1000; // Same as shatter mode
        const bounceDamping = 0.6; // Energy loss on bounce

        for (let i = burpedParticles.length - 1; i >= 0; i--) {
          const particle = burpedParticles[i];

          // Apply gravity
          particle.vy += gravity * dt;

          // Update position
          particle.x += particle.vx * dt;
          particle.y += particle.vy * dt;

          // Bounce off edges with energy loss (same as shatter mode)
          const width = window.innerWidth;
          const height = window.innerHeight;

          // Left and right edges
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Top and bottom edges
          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          } else if (particle.y + particle.height > height + 7) {
            // Keep character visible - allow a bit past the bottom (7px lower)
            particle.y = height - particle.height + 7;
            particle.vy = -particle.vy * bounceDamping;
            particle.vx *= 0.97; // Apply friction
          }

          // Update transform
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }
</script>

<script>
  function enterPongMode() {
    if (pongActive) return;
    pongActive = true;

    // Play ready set go sound immediately
    const readyAudio = new Audio('/audio/chiptune_ready_set_go.mp3');
    readyAudio.volume = 1.0;
    readyAudio.play().catch(err => console.log('Ready audio play failed:', err));

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "METEOR SHOWER INCOMING" message
    const flashMessage = document.createElement('div');
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#ff00ff';
    flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #ff00ff';
    flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';

    const mainText = document.createElement('div');
    mainText.textContent = 'METEOR SHOWER INCOMING';
    mainText.style.fontSize = '64px';

    const subText = document.createElement('div');
    subText.textContent = '(GAME TO 10)';
    subText.style.fontSize = '32px';
    subText.style.marginTop = '10px';

    flashMessage.appendChild(mainText);
    flashMessage.appendChild(subText);
    document.body.appendChild(flashMessage);

    // Show for 2 seconds, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000);
    }, 2000);

    // Create score displays
    const leftScoreContainer = document.createElement('div');
    leftScoreContainer.style.position = 'fixed';
    leftScoreContainer.style.top = '50px';
    leftScoreContainer.style.left = '50px';
    leftScoreContainer.style.zIndex = '99999';
    leftScoreContainer.style.pointerEvents = 'none';
    leftScoreContainer.style.textAlign = 'center';

    const leftLabel = document.createElement('div');
    leftLabel.textContent = 'THEIR\nSCORE';
    leftLabel.style.fontFamily = 'Courier New, monospace';
    leftLabel.style.fontSize = '24px';
    leftLabel.style.fontWeight = 'bold';
    leftLabel.style.color = '#ff0000';
    leftLabel.style.textShadow = '0 0 10px #ff0000';
    leftLabel.style.marginBottom = '10px';
    leftLabel.style.whiteSpace = 'pre-line';
    leftLabel.style.lineHeight = '1.2';

    const leftScore = document.createElement('div');
    leftScore.textContent = '0';
    leftScore.style.fontFamily = 'Courier New, monospace';
    leftScore.style.fontSize = '72px';
    leftScore.style.fontWeight = 'bold';
    leftScore.style.color = '#ff0000';
    leftScore.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';

    leftScoreContainer.appendChild(leftLabel);
    leftScoreContainer.appendChild(leftScore);
    document.body.appendChild(leftScoreContainer);

    const rightScoreContainer = document.createElement('div');
    rightScoreContainer.style.position = 'fixed';
    rightScoreContainer.style.top = '50px';
    rightScoreContainer.style.right = '50px';
    rightScoreContainer.style.zIndex = '99999';
    rightScoreContainer.style.pointerEvents = 'none';
    rightScoreContainer.style.textAlign = 'center';

    const rightLabel = document.createElement('div');
    rightLabel.textContent = 'YOUR\nSCORE';
    rightLabel.style.fontFamily = 'Courier New, monospace';
    rightLabel.style.fontSize = '24px';
    rightLabel.style.fontWeight = 'bold';
    rightLabel.style.color = '#00ff00';
    rightLabel.style.textShadow = '0 0 10px #00ff00';
    rightLabel.style.marginBottom = '10px';
    rightLabel.style.whiteSpace = 'pre-line';
    rightLabel.style.lineHeight = '1.2';

    const rightScore = document.createElement('div');
    rightScore.textContent = '0';
    rightScore.style.fontFamily = 'Courier New, monospace';
    rightScore.style.fontSize = '72px';
    rightScore.style.fontWeight = 'bold';
    rightScore.style.color = '#00ff00';
    rightScore.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';

    rightScoreContainer.appendChild(rightLabel);
    rightScoreContainer.appendChild(rightScore);
    document.body.appendChild(rightScoreContainer);

    // Create player paddle (right side, green)
    const playerPaddle = document.createElement('div');
    playerPaddle.style.position = 'fixed';
    playerPaddle.style.right = '20px';
    playerPaddle.style.width = '15px';
    playerPaddle.style.height = '200px';
    playerPaddle.style.backgroundColor = '#00ff00';
    playerPaddle.style.boxShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';
    playerPaddle.style.zIndex = '99999';
    playerPaddle.style.pointerEvents = 'none';
    document.body.appendChild(playerPaddle);

    // Create enemy paddle (left side, red, static)
    const enemyPaddle = document.createElement('div');
    enemyPaddle.style.position = 'fixed';
    enemyPaddle.style.left = '20px';
    enemyPaddle.style.width = '15px';
    enemyPaddle.style.height = '200px';
    enemyPaddle.style.backgroundColor = '#ff0000';
    enemyPaddle.style.boxShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';
    enemyPaddle.style.zIndex = '99999';
    enemyPaddle.style.pointerEvents = 'none';
    document.body.appendChild(enemyPaddle);

    // Paddle control state
    let playerPaddleY = window.innerHeight / 2 - 100; // Center paddle
    let enemyPaddleY = window.innerHeight / 2 - 100; // Center enemy paddle (static)
    let lastMouseMoveTime = 0;
    let mouseControlActive = false;
    const paddleSpeed = 800; // px/s for keyboard control

    // Update paddle positions
    playerPaddle.style.top = playerPaddleY + 'px';
    enemyPaddle.style.top = enemyPaddleY + 'px';

    // Mouse control
    document.addEventListener('mousemove', (e) => {
      mouseControlActive = true;
      lastMouseMoveTime = Date.now();
      playerPaddleY = Math.max(0, Math.min(window.innerHeight - 200, e.clientY - 100));
    });

    // Keyboard control
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    let themScore = 0;
    let youScore = 0;

    const particles = [];

    // Collect all text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height,
        active: false,
        trail: [] // Store last 15 positions for comet tail
      });
    });

    // Activate one random letter every 2 seconds, starting after 3.5 second delay
    let activationInterval;
    setTimeout(() => {
      activationInterval = setInterval(() => {
        // Find all inactive particles
        const inactiveParticles = particles.filter(p => !p.active);

        if (inactiveParticles.length === 0) {
          clearInterval(activationInterval);
          return;
        }

        // Pick a random inactive particle
        const randomParticle = inactiveParticles[Math.floor(Math.random() * inactiveParticles.length)];

        // Give it velocity with guaranteed horizontal movement
        const minVx = 200; // Minimum horizontal speed
        const vxSign = Math.random() < 0.5 ? -1 : 1;
        randomParticle.vx = vxSign * (minVx + Math.random() * 400); // 200-600 px/s
        randomParticle.vy = (Math.random() - 0.5) * 600;
        randomParticle.active = true;

        // Create whitish-orange burst at launch position
        const launchX = randomParticle.x + randomParticle.width / 2;
        const launchY = randomParticle.y + randomParticle.height / 2;
        createLaunchBurst(launchX, launchY);

        // Play letter release buzz - create new Audio instance each time
        const letterBuzz = new Audio('/audio/chiptune_buzz.wav');
        letterBuzz.volume = 0.35;
        letterBuzz.play().catch(err => console.log('Letter buzz play failed:', err));
      }, 2000);
    }, 3500);

    // Game state
    let blackHoleActive = false;
    let blackHoleEl = null;
    let gameOver = false;

    // Start animation
    startPongAnimation(particles, leftScore, rightScore, playerPaddle, enemyPaddle, () => playerPaddleY, (newY) => { playerPaddleY = newY; }, (newY) => { enemyPaddleY = newY; }, keys, () => mouseControlActive, () => blackHoleActive, (active) => { blackHoleActive = active; }, () => gameOver, (over) => { gameOver = over; });
  }

  function createBurst(x, y, color) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '80px';
    burst.style.height = '80px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = color;
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.8';
    burst.style.boxShadow = `0 0 40px ${color}, 0 0 80px ${color}`;
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.3s, transform 0.3s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.5)';
      setTimeout(() => {
        burst.remove();
      }, 300);
    }, 50);
  }

  function flashPaddle(paddleEl) {
    let flashCount = 0;
    const maxFlashes = 6; // 3 full on/off cycles
    const flashInterval = setInterval(() => {
      paddleEl.style.opacity = paddleEl.style.opacity === '0' ? '1' : '0';
      flashCount++;
      if (flashCount >= maxFlashes) {
        clearInterval(flashInterval);
        paddleEl.style.opacity = '1'; // Ensure it ends visible
      }
    }, 80); // Flash every 80ms
  }

  function createLaunchBurst(x, y) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '50px';
    burst.style.height = '50px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = '#ffcc88'; // Whitish-orange
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.7';
    burst.style.boxShadow = '0 0 20px #ffcc88, 0 0 40px #ffcc88';
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.25s, transform 0.25s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.3)';
      setTimeout(() => {
        burst.remove();
      }, 250);
    }, 50);
  }

  function startPongAnimation(particles, leftScoreEl, rightScoreEl, playerPaddleEl, enemyPaddleEl, getPlayerPaddleY, setPlayerPaddleY, setEnemyPaddleY, keys, getMouseActive, getBlackHoleActive, setBlackHoleActive, getGameOver, setGameOver) {
    let lastTime = performance.now();
    let themScore = 0;
    let youScore = 0;
    const paddleSpeed = 1152; // 20% faster than 960
    let enemyPaddleSpeed = 540; // Slower than player
    let enemyPaddleY = window.innerHeight / 2 - 100;
    let blackHoleEl = null;
    const paddleWidth = 15;
    const paddleHeight = 200;
    const leftPaddleX = 20;
    const rightPaddleX = window.innerWidth - 20 - paddleWidth;

    // Audio elements for paddle hits and game events
    const blip1Audio = new Audio('/audio/pong_blip_1.mp3'); // YOU paddle
    const blip2Audio = new Audio('/audio/pong_blip_2.mp3'); // THEM paddle
    const damage1Audio = new Audio('/audio/chiptune_damage_1.mp3'); // YOU damaged
    const damage2Audio = new Audio('/audio/chiptune_damage_2.mp3'); // THEM damaged
    const victoryAudio = new Audio('/audio/chiptune_victory.mp3'); // Victory
    const defeatAudio = new Audio('/audio/chiptune_defeat.mp3'); // Defeat

    // AI state
    const aiReactionDelay = 280; // ms
    const aiRandomOffset = 35; // px
    let lastAIUpdate = 0;
    let aiTargetY = enemyPaddleY;

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Update player paddle position with keyboard if mouse hasn't moved recently
      if (Date.now() - performance.now() > 100 || !getMouseActive()) {
        let paddleY = getPlayerPaddleY();
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
          paddleY -= paddleSpeed * dt;
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
          paddleY += paddleSpeed * dt;
        }
        paddleY = Math.max(0, Math.min(height - paddleHeight, paddleY));
        setPlayerPaddleY(paddleY);
      }

      // Update enemy AI paddle
      if (currentTime - lastAIUpdate > aiReactionDelay) {
        lastAIUpdate = currentTime;

        // Find the nearest threatening letter (moving left towards enemy paddle)
        let closestThreat = null;
        let minTime = Infinity;

        particles.forEach(particle => {
          if (particle.vx < 0 && particle.active) { // Moving left
            const timeToReach = (particle.x - (leftPaddleX + paddleWidth)) / -particle.vx;
            if (timeToReach > 0 && timeToReach < minTime) {
              minTime = timeToReach;
              // Predict where it will be
              let predictedY = particle.y + particle.vy * timeToReach;

              // Account for bounces off top/bottom
              while (predictedY < 0 || predictedY + particle.height > height) {
                if (predictedY < 0) {
                  predictedY = -predictedY;
                } else if (predictedY + particle.height > height) {
                  predictedY = 2 * (height - particle.height) - predictedY;
                }
              }

              closestThreat = predictedY + particle.height / 2; // Center of letter
            }
          }
        });

        if (closestThreat !== null) {
          // Add random offset for imperfection
          aiTargetY = closestThreat - paddleHeight / 2 + (Math.random() - 0.5) * aiRandomOffset;
        } else {
          // No threats, drift toward center
          aiTargetY = height / 2 - paddleHeight / 2;
        }
      }

      // Move enemy paddle smoothly towards target
      if (enemyPaddleY < aiTargetY) {
        enemyPaddleY = Math.min(aiTargetY, enemyPaddleY + enemyPaddleSpeed * dt);
      } else if (enemyPaddleY > aiTargetY) {
        enemyPaddleY = Math.max(aiTargetY, enemyPaddleY - enemyPaddleSpeed * dt);
      }
      enemyPaddleY = Math.max(0, Math.min(height - paddleHeight, enemyPaddleY));
      setEnemyPaddleY(enemyPaddleY);

      // Update paddle element positions
      playerPaddleEl.style.top = getPlayerPaddleY() + 'px';
      enemyPaddleEl.style.top = enemyPaddleY + 'px';

      // Update particles and check for scoring
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Apply black hole gravity if particle is active and black hole is active
        if (particle.active && getBlackHoleActive()) {
          const blackHoleX = width / 2;
          const blackHoleY = height / 2;
          const blackHoleLambda = 250;
          const blackHoleForce = 750000; // 5x stronger than before

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = blackHoleX - centerX;
          const dy = blackHoleY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            const forceMagnitude = (1 / blackHoleLambda) * Math.exp(-dist / blackHoleLambda) * blackHoleForce;
            let fx = (dx / dist) * forceMagnitude;
            let fy = (dy / dist) * forceMagnitude;

            // Non-conservative in x-coordinate: if moving away from black hole in x, reduce force to 75%
            if (particle.vx * dx < 0) { // Moving away in x (opposite signs)
              fx *= 0.75;
            }
            // Y-component remains conservative (no adjustment)

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Check for player paddle collision (right side)
        const playerPaddleY = getPlayerPaddleY();
        if (particle.vx > 0 && // Moving right
            particle.x + particle.width > rightPaddleX &&
            particle.x < rightPaddleX + paddleWidth &&
            particle.y + particle.height > playerPaddleY &&
            particle.y < playerPaddleY + paddleHeight) {

          // Play YOU paddle blip sound
          blip1Audio.currentTime = 0;
          blip1Audio.play().catch(err => console.log('Blip1 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - playerPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = rightPaddleX - particle.width;
        }

        // Check for enemy paddle collision (left side)
        if (particle.vx < 0 && // Moving left
            particle.x < leftPaddleX + paddleWidth &&
            particle.x + particle.width > leftPaddleX &&
            particle.y + particle.height > enemyPaddleY &&
            particle.y < enemyPaddleY + paddleHeight) {

          // Play THEM paddle blip sound
          blip2Audio.currentTime = 0;
          blip2Audio.play().catch(err => console.log('Blip2 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - enemyPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = leftPaddleX + paddleWidth;
        }

        // Check for left edge (YOU score - enemy missed)
        if (particle.x + particle.width < 0) {
          // Create red burst at contact point (you scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(0, contactY, '#ff0000');

          // Play THEM damage sound
          damage2Audio.currentTime = 0;
          damage2Audio.play().catch(err => console.log('Damage2 play failed:', err));

          // Flash enemy paddle
          flashPaddle(enemyPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            youScore++;
            rightScoreEl.textContent = youScore.toString();

            // Check for YOU reaching 10
            if (youScore === 10 && !getBlackHoleActive()) {
              activateBlackHole();
            } else if (youScore === 20) {
              endGame(true); // YOU win
            }
          }
          continue;
        }

        // Check for right edge (THEM score - player missed)
        if (particle.x > width) {
          // Create green burst at contact point (they scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(width, contactY, '#00ff00');

          // Play YOU damage sound
          damage1Audio.currentTime = 0;
          damage1Audio.play().catch(err => console.log('Damage1 play failed:', err));

          // Flash player paddle
          flashPaddle(playerPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            themScore++;
            leftScoreEl.textContent = themScore.toString();

            // Check for THEM reaching 10
            if (themScore === 10 && !getBlackHoleActive()) {
              endGame(false); // YOU lose
            } else if (themScore === 20) {
              endGame(false); // YOU lose
            }
          }
          continue;
        }

        // Bounce off top and bottom
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height) {
          particle.y = height - particle.height;
          particle.vy = -particle.vy;
        }

        // Update trail (store last 15 positions)
        if (particle.active) {
          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 15) {
            // Remove oldest trail element if it exists
            const oldest = particle.trail.shift();
            if (oldest.el) {
              oldest.el.remove();
            }
          }

          // Create/update trail elements
          particle.trail.forEach((trailPos, idx) => {
            if (!trailPos.el) {
              // Create new trail element
              const trailEl = particle.el.cloneNode(true);
              trailEl.style.pointerEvents = 'none';
              document.body.appendChild(trailEl);
              trailPos.el = trailEl;
            }

            // Update trail element position and style
            const age = particle.trail.length - idx - 1; // 0 = newest, 14 = oldest
            const opacity = 1 - (age + 1) / 16; // Fade from 0.94 to 0.06
            const scale = 1 - (age + 1) * 0.05; // Scale from 0.95 to 0.25

            trailPos.el.style.opacity = opacity.toString();
            trailPos.el.style.transform = `translate(${trailPos.x - parseFloat(particle.el.style.left)}px, ${trailPos.y - parseFloat(particle.el.style.top)}px) scale(${scale})`;
            trailPos.el.style.zIndex = (10000 - age - 1).toString(); // Behind main letter
          });
        }

        // Apply transform to main particle
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      }

      requestAnimationFrame(animate);
    }

    // Helper function to activate black hole
    function activateBlackHole() {
      setBlackHoleActive(true);

      // Increase AI speed
      enemyPaddleSpeed = 700;

      // Create black hole element
      const width = window.innerWidth;
      const height = window.innerHeight;
      blackHoleEl = document.createElement('div');
      blackHoleEl.style.position = 'fixed';
      blackHoleEl.style.left = (width / 2) + 'px';
      blackHoleEl.style.top = (height / 2) + 'px';
      blackHoleEl.style.width = '50px';
      blackHoleEl.style.height = '50px';
      blackHoleEl.style.marginLeft = '-25px';
      blackHoleEl.style.marginTop = '-25px';
      blackHoleEl.style.borderRadius = '50%';
      blackHoleEl.style.backgroundColor = '#000000';
      blackHoleEl.style.boxShadow = '0 0 30px 10px rgba(0, 0, 0, 0.8)';
      blackHoleEl.style.zIndex = '9999';
      blackHoleEl.style.pointerEvents = 'none';
      document.body.appendChild(blackHoleEl);

      // Animate the pulsing
      let pulseTime = 0;
      function pulseBlackHole() {
        if (!getBlackHoleActive() || !blackHoleEl) return;
        pulseTime += 0.05;
        const size = 40 + 10 * Math.sin(pulseTime);
        blackHoleEl.style.width = size + 'px';
        blackHoleEl.style.height = size + 'px';
        blackHoleEl.style.marginLeft = (-size / 2) + 'px';
        blackHoleEl.style.marginTop = (-size / 2) + 'px';
        requestAnimationFrame(pulseBlackHole);
      }
      pulseBlackHole();

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '20%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s ease-out';

      const mainText = document.createElement('div');
      mainText.textContent = 'BLACK HOLE ACTIVATED';
      mainText.style.fontSize = '64px';

      const subText = document.createElement('div');
      subText.textContent = '(GAME TO 20)';
      subText.style.fontSize = '32px';
      subText.style.marginTop = '10px';

      flashMessage.appendChild(mainText);
      flashMessage.appendChild(subText);
      document.body.appendChild(flashMessage);

      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => flashMessage.remove(), 2000);
      }, 4000);
    }

    // Helper function to end the game
    function endGame(playerWon) {
      setGameOver(true);

      // Play victory or defeat sound
      if (playerWon) {
        victoryAudio.currentTime = 0;
        victoryAudio.play().catch(err => console.log('Victory play failed:', err));
      } else {
        defeatAudio.currentTime = 0;
        defeatAudio.play().catch(err => console.log('Defeat play failed:', err));
      }

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontSize = '96px';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.whiteSpace = 'nowrap';
      flashMessage.textContent = playerWon ? 'VICTORY' : 'DEFEATED';
      document.body.appendChild(flashMessage);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // BIRD MODE
  // ============================================================================

</script>

<script>
  // ============================================================================
  // BIRD MODE DEBUG SETTINGS
  // ============================================================================
  const DRAW_FORCES = false;  // Set to false to disable force visualization

  function enterBirdMode() {
    if (birdModeActive) return;
    birdModeActive = true;

    try {
      console.log('Starting bird mode...');

      // Disable clicks on mystery button (but keep it visible so it can become a bird)
      const mysteryIcon = document.querySelector('.fa-question-circle');
      if (mysteryIcon) {
        const mysteryLink = mysteryIcon.closest('a.nav-link');
        if (mysteryLink) {
          mysteryLink.style.pointerEvents = 'none';
        }
      }

      // Create flashy "BIRD MODE ACTIVATED" message FIRST (before laggy operations)
      const flashMessage = document.createElement('div');
      flashMessage.textContent = 'BIRD MODE ACTIVATED';
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontSize = '64px';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff6b9d';
      flashMessage.style.textShadow = '0 0 10px #ff6b9d, 0 0 20px #ff6b9d, 0 0 30px #ff6b9d, 0 0 40px #ff6b9d';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff6b9d';
      flashMessage.style.boxShadow = '0 0 20px #ff6b9d, inset 0 0 20px rgba(255, 107, 157, 0.2)';
      flashMessage.style.zIndex = '100000';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s';
      document.body.appendChild(flashMessage);

      // Show for 1 second, then fade out over 2 seconds
      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => {
          flashMessage.remove();
        }, 2000);
      }, 1000);

      // Wait 50ms to ensure banner renders before starting laggy operations
      setTimeout(() => {
        // Wrap text
        ensureTextWrapped();

        // Lock body
        const scrollY = window.scrollY;
        document.body.classList.add('bird-locked');
        document.body.style.top = `-${scrollY}px`;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        });

        const particles = [];
        const MAX_BIRD_COUNT = 1000;

        // Find header characters to make them hawks (h1, or h2, or h3 if no h1)
        let headerElement = document.querySelector('h1');
        if (!headerElement) {
          headerElement = document.querySelector('h2');
        }
        if (!headerElement) {
          headerElement = document.querySelector('h3');
        }
        let h1Chars = [];
        if (headerElement) {
          h1Chars = Array.from(headerElement.querySelectorAll('.char'));
        }

        // Collect all character and glyph elements with their data
        // Separate hawks (always keep) from non-hawks (randomly select)
        const hawkElements = [];
        const nonHawkElements = [];

        // Collect all characters
        const chars = document.querySelectorAll('.char');
        chars.forEach(char => {
          const rect = char.getBoundingClientRect();

          // Skip if outside viewport
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth) {
            return;
          }

          const hawkIndex = h1Chars.indexOf(char);
          const isHawk = hawkIndex !== -1;

          const elem = {
            original: char,
            rect: rect,
            isChar: true,
            isHawk: isHawk,
            hawkIndex: hawkIndex,
            randomOrder: Math.random()  // For shuffling
          };

          if (isHawk) {
            hawkElements.push(elem);
          } else {
            nonHawkElements.push(elem);
          }
        });

        // Also collect glyphs and icons (all non-hawks)
        const glyphs = document.querySelectorAll('i, svg');
        glyphs.forEach(glyph => {
          const rect = glyph.getBoundingClientRect();

          // Skip if outside viewport or has no size
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth ||
              rect.width === 0 || rect.height === 0) {
            return;
          }

          nonHawkElements.push({
            original: glyph,
            rect: rect,
            isChar: false,
            isHawk: false,
            hawkIndex: -1,
            randomOrder: Math.random()  // For shuffling
          });
        });

        // Randomly shuffle non-hawks
        nonHawkElements.sort((a, b) => a.randomOrder - b.randomOrder);

        // Select non-hawks up to MAX_BIRD_COUNT - number of hawks
        const maxNonHawks = MAX_BIRD_COUNT - hawkElements.length;
        const selectedNonHawks = nonHawkElements.slice(0, maxNonHawks);
        const fadedNonHawks = nonHawkElements.slice(maxNonHawks);

        // Combine: all hawks + selected non-hawks become birds
        const birdElements = [...hawkElements, ...selectedNonHawks];

        // Process bird elements (become birds)
        birdElements.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Add to particles array (all bird elements become birds)
          particles.push({
            el: clone,
            x: rect.left,
            y: rect.top,
            vx: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,  // Hawks get tiny random velocity
            vy: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,
            width: rect.width,
            height: rect.height,
            isHawk: elem.isHawk,
            hawkIndex: elem.hawkIndex,  // -1 for non-hawks, 0+ for hawks
            isActive: !elem.isHawk,  // Hawks start dormant, boids start active
            originalX: rect.left,  // Store original position for dormant hawks
            originalY: rect.top
          });
        });

        // Process faded elements (fade out smoothly)
        fadedNonHawks.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Fade out this element smoothly
          clone.style.transition = 'opacity 3s ease-out';
          setTimeout(() => {
            clone.style.opacity = '0';
            setTimeout(() => {
              clone.remove();
            }, 3000);
          }, 10);
        });

        // Start animation
        // Create trajectory ray for hawk
        const trajectoryRay = document.createElement('div');
        trajectoryRay.id = 'hawk-trajectory-ray';
        trajectoryRay.style.position = 'fixed';
        trajectoryRay.style.height = '2px';
        trajectoryRay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        trajectoryRay.style.transformOrigin = '0 0';
        trajectoryRay.style.pointerEvents = 'none';
        trajectoryRay.style.zIndex = '9998';
        trajectoryRay.style.display = 'none';
        document.body.appendChild(trajectoryRay);

        // Create perpendicular lines container (SVG for efficient line drawing)
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'fear-lines-svg';
        svg.style.position = 'fixed';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '9997';
        document.body.appendChild(svg);

        // Create force vectors SVG overlay (for debug visualization)
        const forceVectorsSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        forceVectorsSvg.id = 'force-vectors-svg';
        forceVectorsSvg.style.position = 'fixed';
        forceVectorsSvg.style.top = '0';
        forceVectorsSvg.style.left = '0';
        forceVectorsSvg.style.width = '100%';
        forceVectorsSvg.style.height = '100%';
        forceVectorsSvg.style.pointerEvents = 'none';
        forceVectorsSvg.style.zIndex = '9999';
        forceVectorsSvg.style.display = DRAW_FORCES ? 'block' : 'none';
        document.body.appendChild(forceVectorsSvg);

        // Create force legend (for debug visualization)
        if (DRAW_FORCES) {
          const legend = document.createElement('div');
          legend.id = 'force-legend';
          legend.style.position = 'fixed';
          legend.style.top = '10px';
          legend.style.right = '10px';
          legend.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
          legend.style.color = 'white';
          legend.style.padding = '10px';
          legend.style.fontFamily = 'monospace';
          legend.style.fontSize = '12px';
          legend.style.zIndex = '100001';
          legend.style.borderRadius = '5px';
          legend.style.lineHeight = '1.5';
          legend.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">FORCE LEGEND</div>
            <div><span style="color: #ff0000;">■</span> Repulsion (boid-boid)</div>
            <div><span style="color: #0000ff;">■</span> Cohesion</div>
            <div><span style="color: #00ff00;">■</span> Alignment</div>
            <div><span style="color: #00ffff;">■</span> Speed Stabilization</div>
            <div><span style="color: #ff8800;">■</span> Wall Repulsion</div>
            <div><span style="color: #ff00ff;">■</span> Fear</div>
            <div><span style="color: #ffff00;">■</span> Boid Attraction (hawks)</div>
            <div><span style="color: #ff69b4;">■</span> Hawk-Hawk Repulsion</div>
          `;
          document.body.appendChild(legend);
        }

        console.log('Starting animation with', particles.length, 'particles');
        startBirdAnimation(particles, trajectoryRay, svg, forceVectorsSvg);
      }, 50);  // End of 50ms setTimeout
    } catch (error) {
      console.error('Error in enterBirdMode:', error);
      birdModeActive = false;
      alert('Error starting bird mode: ' + error.message);
    }
  }

  function startBirdAnimation(particles, trajectoryRay, fearLinesSvg, forceVectorsSvg) {
    let lastTime = performance.now();
    let hawkInfos = [];  // Store all active hawks' positions and velocities for fear calculations

    const FORCE_MULTIPLIER = 25;  // Global force multiplication factor
    const MAX_SPEED = 400;   // Maximum speed
    const F_MAX = 10;  // Maximum force magnitude before clamping
    const FORCE_ARROW_SCALE = 20;  // Scale factor for visualizing force arrows

    // Repulsion parameters
    const LENGTH_SCALE = 20;  // px
    const R_REPULSION = 1 * LENGTH_SCALE;  // 20px
    const F_REPULSION = 5;  // Repulsion strength

    // Speed stabilization parameters
    const TARGET_SPEED = 15;  // px/s
    const TARGET_SPEED_HAWK = 50;  // px/s
    const F_SPEEDSTABILITY = 5;
    const F_SPEEDSTABILITY_HAWK = 2;

    // Alignment parameters
    const F_ALIGN = 2;

    // Wall repulsion parameters
    const WALL_REPULSION_DIST = 5 * LENGTH_SCALE;  // 100px
    const F_WALL_REPULSION = 4;

    // Hawk-specific wall repulsion (2x distance and magnitude)
    const WALL_REPULSION_DIST_HAWK = 1 * WALL_REPULSION_DIST;  // 200px
    const F_WALL_REPULSION_HAWK = .5 * F_WALL_REPULSION;  // 8

    // Hawk attraction parameters
    const F_ATTR_HAWK = 0.3;

    // Fear parameters
    const F_FEAR = 3;
    const FEAR_DIST = 15 * LENGTH_SCALE;  // 300px

    // Spatial grid parameters
    const CELL_SIZE = 2 * LENGTH_SCALE;  // 60px

    // Hawk release tracking
    let nextHawkIndex = 0;
    let nextHawkReleaseTime = 20.0;  // First hawk at 20 seconds (wall time)
    let elapsedTime = 0;  // Wall time in seconds

    function releaseHawk(hawk) {
      hawk.isActive = true;
      hawk.releaseTime = elapsedTime;  // Track when hawk was released

      // Play hawk call at 30% volume
      const hawkAudio = document.getElementById('hawk-call');
      if (hawkAudio) {
        hawkAudio.volume = 0.3;
        hawkAudio.currentTime = 0;
        hawkAudio.play().catch(e => console.log('Audio play failed:', e));
      }

      // Create big brown burst
      const burstX = hawk.x + hawk.width / 2;
      const burstY = hawk.y + hawk.height / 2;
      const burst = document.createElement('div');

      burst.style.position = 'fixed';
      burst.style.left = burstX + 'px';
      burst.style.top = burstY + 'px';
      burst.style.width = '0px';
      burst.style.height = '0px';
      burst.style.borderRadius = '50%';
      burst.style.backgroundColor = 'rgba(139, 69, 19, 0.6)';  // Brown color
      burst.style.transform = 'translate(-50%, -50%)';
      burst.style.pointerEvents = 'none';
      burst.style.zIndex = '9999';
      document.body.appendChild(burst);

      // Animate burst (much bigger)
      setTimeout(() => {
        burst.style.transition = 'all 0.6s ease-out';
        burst.style.width = '200px';
        burst.style.height = '200px';
        burst.style.backgroundColor = 'rgba(139, 69, 19, 0)';
      }, 10);

      setTimeout(() => burst.remove(), 650);
    }

    // Helper function to draw a force arrow in SVG
    function createArrow(x, y, fx, fy, color) {
      const length = Math.sqrt(fx * fx + fy * fy);
      if (length < 0.01) return null;  // Skip tiny forces

      const endX = x + fx * FORCE_ARROW_SCALE;
      const endY = y + fy * FORCE_ARROW_SCALE;

      // Create line
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x);
      line.setAttribute('y1', y);
      line.setAttribute('x2', endX);
      line.setAttribute('y2', endY);
      line.setAttribute('stroke', color);
      line.setAttribute('stroke-width', '1.5');
      line.setAttribute('opacity', '0.7');

      // Create arrowhead
      const arrowSize = 5;
      const angle = Math.atan2(fy, fx);
      const arrowX1 = endX - arrowSize * Math.cos(angle - Math.PI / 6);
      const arrowY1 = endY - arrowSize * Math.sin(angle - Math.PI / 6);
      const arrowX2 = endX - arrowSize * Math.cos(angle + Math.PI / 6);
      const arrowY2 = endY - arrowSize * Math.sin(angle + Math.PI / 6);

      const arrowhead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      arrowhead.setAttribute('points', `${endX},${endY} ${arrowX1},${arrowY1} ${arrowX2},${arrowY2}`);
      arrowhead.setAttribute('fill', color);
      arrowhead.setAttribute('opacity', '0.7');

      return { line, arrowhead };
    }

    function animate(currentTime) {
      if (!birdModeActive) return;

      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      // Update elapsed time (wall time in real seconds)
      elapsedTime += dt;

      // Simulation runs at 4x speed
      const simulationDt = dt * 4;

      // Clear hawk infos from previous frame
      hawkInfos = [];

      // Check if it's time to release the next hawk
      if (elapsedTime >= nextHawkReleaseTime) {
        // Find the hawk with hawkIndex === nextHawkIndex
        const hawkToRelease = particles.find(p => p.hawkIndex === nextHawkIndex);
        if (hawkToRelease && !hawkToRelease.isActive) {
          releaseHawk(hawkToRelease);
          nextHawkIndex++;
          // First hawk at 20s, then every 60s thereafter
          nextHawkReleaseTime += 60.0;
        }
      }

      // Build spatial grid (only for active, non-hawk particles)
      const grid = new Map();
      particles.forEach((particle, i) => {
        if (!particle.isActive || particle.isHawk) return;

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);
        const key = `${cellX},${cellY}`;

        if (!grid.has(key)) {
          grid.set(key, []);
        }
        grid.get(key).push(i);
      });

      // Check for hawk overlaps and hide captured particles
      particles.forEach((hawk, i) => {
        if (!hawk.isHawk || !hawk.isActive) return;

        // Hawks can't capture during their 2-second frozen period
        const timeSinceRelease = elapsedTime - (hawk.releaseTime || 0);
        if (timeSinceRelease < 2.0) return;

        particles.forEach((boid, j) => {
          if (i === j || !boid.isActive || boid.isHawk) return;

          // Check bounding box overlap
          if (hawk.x < boid.x + boid.width &&
              hawk.x + hawk.width > boid.x &&
              hawk.y < boid.y + boid.height &&
              hawk.y + hawk.height > boid.y) {
            // Overlap! Hide boid and create burst
            boid.isActive = false;
            boid.el.remove();

            // Play goose sound (75% honk, 25% yell)
            const soundId = Math.random() < 0.75 ? 'goose-honk' : 'goose-yell';
            const audio = document.getElementById(soundId);
            if (audio) {
              audio.currentTime = 0;
              audio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Create colorful burst
            const burstX = boid.x + boid.width / 2;
            const burstY = boid.y + boid.height / 2;
            const burst = document.createElement('div');

            // Random hue, high saturation, high lightness
            const hue = Math.floor(Math.random() * 360);
            const saturation = 70 + Math.floor(Math.random() * 20); // 70-90%
            const lightness = 60; // Medium-bright

            burst.style.position = 'fixed';
            burst.style.left = burstX + 'px';
            burst.style.top = burstY + 'px';
            burst.style.width = '0px';
            burst.style.height = '0px';
            burst.style.borderRadius = '50%';
            burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.6)`;
            burst.style.transform = 'translate(-50%, -50%)';
            burst.style.pointerEvents = 'none';
            burst.style.zIndex = '9999';
            document.body.appendChild(burst);

            // Animate burst
            setTimeout(() => {
              burst.style.transition = 'all 0.4s ease-out';
              burst.style.width = '60px';
              burst.style.height = '60px';
              burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`;
            }, 10);

            setTimeout(() => burst.remove(), 450);
          }
        });
      });

      // Apply forces to each particle
      particles.forEach((particle, i) => {
        if (!particle.isActive) return;  // Skip inactive particles

        // Initialize force tracking for debug visualization
        particle.forces = {
          speedStab: { x: 0, y: 0 },
          boidAttr: { x: 0, y: 0 },
          hawkRepulsion: { x: 0, y: 0 },
          wallRepulsion: { x: 0, y: 0 },
          repulsion: { x: 0, y: 0 },
          cohesion: { x: 0, y: 0 },
          alignment: { x: 0, y: 0 },
          fear: { x: 0, y: 0 }
        };

        // Hawks have their own forces
        if (particle.isHawk) {
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Keep hawk stationary for 2 seconds after release (for suspense)
          const timeSinceRelease = elapsedTime - (particle.releaseTime || 0);
          if (timeSinceRelease < 2.0) {
            // Hawk is frozen - keep it in place
            particle.vx = 0;
            particle.vy = 0;
            particle.x = particle.originalX;
            particle.y = particle.originalY;
            particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

            // Still store hawk info for fear calculations
            hawkInfos.push({
              x: centerX,
              y: centerY,
              vx: 0,
              vy: 0,
              speed: 0
            });
            return;  // Skip rest of hawk physics
          }

          let hawkForceX = 0;
          let hawkForceY = 0;

          // Speed stabilization force (weaker than boids, higher target speed)
          const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
          if (currentSpeed > 0) {
            const speedRatio = 1 - currentSpeed / TARGET_SPEED_HAWK;
            const speedForceMag = F_SPEEDSTABILITY_HAWK * Math.pow(speedRatio, 3);
            particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
            particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
            hawkForceX += particle.forces.speedStab.x;
            hawkForceY += particle.forces.speedStab.y;
          }

          // Attraction to nearest boid
          let nearestBoid = null;
          let nearestDist = Infinity;
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestBoid = { x: otherCenterX, y: otherCenterY, dist: dist };
            }
          });

          if (nearestBoid && nearestBoid.dist > 0) {
            const dx = nearestBoid.x - centerX;
            const dy = nearestBoid.y - centerY;
            particle.forces.boidAttr.x = (dx / nearestBoid.dist) * F_ATTR_HAWK;
            particle.forces.boidAttr.y = (dy / nearestBoid.dist) * F_ATTR_HAWK;
            hawkForceX += particle.forces.boidAttr.x;
            hawkForceY += particle.forces.boidAttr.y;
          }

          // Repulsion from nearest k hawks
          const K_HAWKS = 3;
          const HAWK_REPULSION_DIST = 50;  // px
          const F_HAWK_REPULSION = 0.5;  // Mild repulsion strength

          // Find all other active hawks
          const otherHawks = [];
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || !other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < HAWK_REPULSION_DIST) {
              otherHawks.push({ x: otherCenterX, y: otherCenterY, dist: dist });
            }
          });

          if (otherHawks.length > 0) {
            // Sort by distance and take k nearest
            otherHawks.sort((a, b) => a.dist - b.dist);
            const nearestKHawks = otherHawks.slice(0, K_HAWKS);

            // Calculate average position
            let avgHawkX = 0, avgHawkY = 0;
            nearestKHawks.forEach(h => {
              avgHawkX += h.x;
              avgHawkY += h.y;
            });
            avgHawkX /= nearestKHawks.length;
            avgHawkY /= nearestKHawks.length;

            // Calculate average distance
            let avgDist = 0;
            nearestKHawks.forEach(h => avgDist += h.dist);
            avgDist /= nearestKHawks.length;

            // Apply repulsive force (drops off linearly)
            if (avgDist > 0) {
              const repulsionStrength = F_HAWK_REPULSION * (1 - avgDist / HAWK_REPULSION_DIST);
              const dx = centerX - avgHawkX;
              const dy = centerY - avgHawkY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                particle.forces.hawkRepulsion.x = (dx / dist) * repulsionStrength;
                particle.forces.hawkRepulsion.y = (dy / dist) * repulsionStrength;
                hawkForceX += particle.forces.hawkRepulsion.x;
                hawkForceY += particle.forces.hawkRepulsion.y;
              }
            }
          }

          // Wall repulsion forces (stronger and longer range for hawks)
          const width = window.innerWidth;
          const height = window.innerHeight;

          let wallForceX = 0;
          let wallForceY = 0;

          // Left wall
          const distLeft = centerX;
          if (distLeft < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distLeft / WALL_REPULSION_DIST_HAWK);
            wallForceX += wallForceMag;  // Push right
          }

          // Right wall
          const distRight = width - centerX;
          if (distRight < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distRight / WALL_REPULSION_DIST_HAWK);
            wallForceX -= wallForceMag;  // Push left
          }

          // Top wall
          const distTop = centerY;
          if (distTop < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distTop / WALL_REPULSION_DIST_HAWK);
            wallForceY += wallForceMag;  // Push down
          }

          // Bottom wall
          const distBottom = height - centerY;
          if (distBottom < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distBottom / WALL_REPULSION_DIST_HAWK);
            wallForceY -= wallForceMag;  // Push up
          }

          particle.forces.wallRepulsion.x = wallForceX;
          particle.forces.wallRepulsion.y = wallForceY;
          hawkForceX += wallForceX;
          hawkForceY += wallForceY;

          // Clamp force to F_MAX
          const hawkForceMag = Math.sqrt(hawkForceX * hawkForceX + hawkForceY * hawkForceY);
          if (hawkForceMag > F_MAX) {
            hawkForceX = (hawkForceX / hawkForceMag) * F_MAX;
            hawkForceY = (hawkForceY / hawkForceMag) * F_MAX;
          }

          // Apply forces
          particle.vx += hawkForceX * FORCE_MULTIPLIER * simulationDt;
          particle.vy += hawkForceY * FORCE_MULTIPLIER * simulationDt;

          // Update position
          particle.x += particle.vx * simulationDt;
          particle.y += particle.vy * simulationDt;

          // Bounce off walls (width and height already declared above)
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx;
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx;
          }

          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy;
          } else if (particle.y + particle.height > height) {
            particle.y = height - particle.height;
            particle.vy = -particle.vy;
          }

          // Update visual position
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

          // Store hawk info for fear calculations
          hawkInfos.push({
            x: centerX,
            y: centerY,
            vx: particle.vx,
            vy: particle.vy,
            speed: currentSpeed
          });

          return;  // Skip boid forces
        }

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;

        // Accumulate total force
        let totalForceX = 0;
        let totalForceY = 0;

        // Fear force from all hawks
        let isFearful = false;
        hawkInfos.forEach(hawkInfo => {
          if (hawkInfo.speed > 0) {
            const toHawkX = hawkInfo.x - centerX;
            const toHawkY = hawkInfo.y - centerY;
            const distToHawk = Math.sqrt(toHawkX * toHawkX + toHawkY * toHawkY);

            // Check if boid is in front of hawk (dot product > 0)
            const toBoidX = centerX - hawkInfo.x;
            const toBoidY = centerY - hawkInfo.y;
            const dotProduct = toBoidX * hawkInfo.vx + toBoidY * hawkInfo.vy;

            if (distToHawk < FEAR_DIST && dotProduct > 0) {
              // Boid feels fear!
              isFearful = true;

              // Calculate perpendicular direction away from ray
              const dirX = hawkInfo.vx / hawkInfo.speed;
              const dirY = hawkInfo.vy / hawkInfo.speed;

              // Project boid position onto ray
              const projection = toBoidX * dirX + toBoidY * dirY;
              const rayPointX = hawkInfo.x + projection * dirX;
              const rayPointY = hawkInfo.y + projection * dirY;

              // Direction from ray to boid (perpendicular escape direction)
              const perpX = centerX - rayPointX;
              const perpY = centerY - rayPointY;
              const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

              if (perpDist > 0) {
                const fearMagnitude = F_FEAR * (1 - distToHawk / FEAR_DIST);

                // Blend perpendicular direction with "away from hawk" for 70 degree angle
                const perpNormX = perpX / perpDist;
                const perpNormY = perpY / perpDist;
                const awayNormX = -dirX;  // Opposite of hawk direction
                const awayNormY = -dirY;

                // sin(70°) ≈ 0.94, cos(70°) ≈ 0.34
                const fearDirX = 0.94 * perpNormX + 0.34 * awayNormX;
                const fearDirY = 0.94 * perpNormY + 0.34 * awayNormY;

                // Normalize the blended direction
                const fearDirMag = Math.sqrt(fearDirX * fearDirX + fearDirY * fearDirY);
                if (fearDirMag > 0) {
                  particle.forces.fear.x += (fearDirX / fearDirMag) * fearMagnitude;
                  particle.forces.fear.y += (fearDirY / fearDirMag) * fearMagnitude;
                  totalForceX += (fearDirX / fearDirMag) * fearMagnitude;
                  totalForceY += (fearDirY / fearDirMag) * fearMagnitude;
                }
              }
            }
          }
        });

        // Get particle's grid cell
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);

        // Find distances to particles in nearby cells (3x3 neighborhood)
        const distances = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${cellX + dx},${cellY + dy}`;
            const cellParticles = grid.get(key);
            if (!cellParticles) continue;

            cellParticles.forEach(j => {
              if (i === j) return;

              const other = particles[j];
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              const deltaX = otherCenterX - centerX;
              const deltaY = otherCenterY - centerY;
              const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

              distances.push({
                index: j,
                dist: dist,
                dx: deltaX,
                dy: deltaY,
                x: otherCenterX,
                y: otherCenterY
              });

              // Repulsion force (only for close neighbors) - 1/r form with offset
              if (dist <= R_REPULSION && dist > 0) {
                const normalizedDist = dist / LENGTH_SCALE;
                const repulsionMag = F_REPULSION * (1 - normalizedDist);
                particle.forces.repulsion.x -= (deltaX / dist) * repulsionMag;  // Negative = repulsion
                particle.forces.repulsion.y -= (deltaY / dist) * repulsionMag;
                totalForceX -= (deltaX / dist) * repulsionMag;
                totalForceY -= (deltaY / dist) * repulsionMag;
              }
            });
          }
        }

        // Sort by distance and take 5 nearest
        distances.sort((a, b) => a.dist - b.dist);
        const nearest5 = distances.slice(0, 5);

        // Calculate average position of 5 nearest neighbors
        let avgX = 0, avgY = 0;
        nearest5.forEach(n => {
          avgX += n.x;
          avgY += n.y;
        });
        avgX /= nearest5.length;
        avgY /= nearest5.length;

        // Cohesion force: magnitude 1 towards average position
        const dx = avgX - centerX;
        const dy = avgY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          particle.forces.cohesion.x = (dx / dist) * 1.0;
          particle.forces.cohesion.y = (dy / dist) * 1.0;
          totalForceX += particle.forces.cohesion.x;
          totalForceY += particle.forces.cohesion.y;
        }

        // Alignment force: magnitude F_ALIGN in direction of average velocity
        let avgVx = 0, avgVy = 0;
        nearest5.forEach(n => {
          const neighbor = particles[n.index];
          avgVx += neighbor.vx;
          avgVy += neighbor.vy;
        });
        avgVx /= nearest5.length;
        avgVy /= nearest5.length;

        const avgVelMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
        if (avgVelMag > 0) {
          particle.forces.alignment.x = (avgVx / avgVelMag) * F_ALIGN;
          particle.forces.alignment.y = (avgVy / avgVelMag) * F_ALIGN;
          totalForceX += particle.forces.alignment.x;
          totalForceY += particle.forces.alignment.y;
        }

        // Speed stabilization force
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (currentSpeed > 0) {
          const speedRatio = 1 - currentSpeed / TARGET_SPEED;
          const speedForceMag = F_SPEEDSTABILITY * Math.pow(speedRatio, 3);
          particle.forces.speedStab.x = (particle.vx / currentSpeed) * speedForceMag;
          particle.forces.speedStab.y = (particle.vy / currentSpeed) * speedForceMag;
          totalForceX += particle.forces.speedStab.x;
          totalForceY += particle.forces.speedStab.y;
        }

        // Wall repulsion forces
        const width = window.innerWidth;
        const height = window.innerHeight;

        let wallForceX = 0;
        let wallForceY = 0;

        // Left wall
        const distLeft = centerX;
        if (distLeft < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distLeft / WALL_REPULSION_DIST);
          wallForceX += wallForceMag;  // Push right
        }

        // Right wall
        const distRight = width - centerX;
        if (distRight < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distRight / WALL_REPULSION_DIST);
          wallForceX -= wallForceMag;  // Push left
        }

        // Top wall
        const distTop = centerY;
        if (distTop < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distTop / WALL_REPULSION_DIST);
          wallForceY += wallForceMag;  // Push down
        }

        // Bottom wall
        const distBottom = height - centerY;
        if (distBottom < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distBottom / WALL_REPULSION_DIST);
          wallForceY -= wallForceMag;  // Push up
        }

        particle.forces.wallRepulsion.x = wallForceX;
        particle.forces.wallRepulsion.y = wallForceY;
        totalForceX += wallForceX;
        totalForceY += wallForceY;

        // Clamp force to F_MAX
        const totalForceMag = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
        if (totalForceMag > F_MAX) {
          totalForceX = (totalForceX / totalForceMag) * F_MAX;
          totalForceY = (totalForceY / totalForceMag) * F_MAX;
        }

        // Apply total force with global multiplier
        particle.vx += totalForceX * FORCE_MULTIPLIER * simulationDt;
        particle.vy += totalForceY * FORCE_MULTIPLIER * simulationDt;

        // Limit speed
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed > MAX_SPEED) {
          particle.vx = (particle.vx / speed) * MAX_SPEED;
          particle.vy = (particle.vy / speed) * MAX_SPEED;
        }

        // Update position
        particle.x += particle.vx * simulationDt;
        particle.y += particle.vy * simulationDt;

        // Bounce off edges with perfect reflection (no energy loss)
        // (width and height already declared above for wall repulsion)

        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx;
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx;
        }

        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height + 7) {
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy;
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Keep dormant hawks at their original position
      particles.forEach(particle => {
        if (particle.isHawk && !particle.isActive) {
          particle.x = particle.originalX;
          particle.y = particle.originalY;
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      });

      // Draw force vectors for debug visualization
      if (DRAW_FORCES) {
        // Clear previous arrows
        while (forceVectorsSvg.firstChild) {
          forceVectorsSvg.removeChild(forceVectorsSvg.firstChild);
        }

        // Draw force vectors for each active particle
        particles.forEach(particle => {
          if (!particle.isActive || !particle.forces) return;

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Define force colors
          const forceColors = {
            repulsion: '#ff0000',       // Red (boid-boid repulsion)
            cohesion: '#0000ff',        // Blue
            alignment: '#00ff00',       // Green
            speedStab: '#00ffff',       // Cyan
            wallRepulsion: '#ff8800',   // Orange
            fear: '#ff00ff',            // Magenta
            boidAttr: '#ffff00',        // Yellow (hawk attraction to boids)
            hawkRepulsion: '#ff69b4'    // Pink (hawk-hawk repulsion)
          };

          // Draw each force type
          Object.entries(particle.forces).forEach(([forceType, force]) => {
            if (!forceColors[forceType]) return;

            const arrow = createArrow(centerX, centerY, force.x, force.y, forceColors[forceType]);
            if (arrow) {
              forceVectorsSvg.appendChild(arrow.line);
              forceVectorsSvg.appendChild(arrow.arrowhead);
            }
          });
        });
      }

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // INITIALIZATION
  // ============================================================================
</script>

<script>
  // ============================================================================
  // PANIC MODE
  // ============================================================================

  let panicTextWrapped = false;
  let alarmAudio = null;
  let screamAudio = null;

  function enterPanicMode() {
    if (panicActive) return;
    panicActive = true;

    // Wrap text if not already wrapped by other modes
    if (!textWrapped && !panicTextWrapped) {
      panicTextWrapped = true;
      wrapTextNodes(document.body);
    }

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('panic-locked');
    document.body.style.top = `-${scrollY}px`;

    // Start alarm sound immediately
    const alarm = document.getElementById('panic-alarm');
    if (alarm) {
      alarmAudio = alarm;
      alarmAudio.loop = true;
      alarmAudio.currentTime = 0;
      alarmAudio.play();
    }

    // Start crowd scream after 2 seconds (when movement begins)
    setTimeout(() => {
      if (panicActive) {
        const scream = document.getElementById('panic-scream');
        if (scream) {
          screamAudio = scream;
          screamAudio.loop = true;
          screamAudio.currentTime = 0;
          screamAudio.play();
        }
      }
    }, 2000);

    // Create persistent flashing "PANIC MODE" text
    const panicLabel = document.createElement('div');
    panicLabel.id = 'panic-mode-label';
    panicLabel.textContent = 'PANIC MODE';
    panicLabel.style.position = 'fixed';
    panicLabel.style.top = '50%';
    panicLabel.style.left = '50%';
    panicLabel.style.transform = 'translate(-50%, -50%)';
    panicLabel.style.fontSize = '48px';
    panicLabel.style.fontFamily = 'Courier New, monospace';
    panicLabel.style.fontWeight = 'bold';
    panicLabel.style.letterSpacing = '4px';
    panicLabel.style.color = '#ff0000';
    panicLabel.style.textShadow = '0 0 10px #ff0000, 0 0 20px #ff0000';
    panicLabel.style.zIndex = '99999';
    panicLabel.style.pointerEvents = 'none';
    panicLabel.style.textAlign = 'center';
    document.body.appendChild(panicLabel);

    // Flash on/off every 0.51 seconds
    const flashInterval = setInterval(() => {
      if (!panicActive) {
        clearInterval(flashInterval);
        panicLabel.remove();
        return;
      }
      panicLabel.style.visibility = panicLabel.style.visibility === 'hidden' ? 'visible' : 'hidden';
    }, 510);

    const particles = [];

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.position = 'fixed';
      clone.style.margin = '0';
      clone.style.willChange = 'transform';
      clone.style.pointerEvents = 'none';
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Sample epicycle parameters
      const PATH_LENGTH_SCALE = 200; // px
      const MAX_FREQ = 10;
      const radii = [];
      const thetas = [];
      const signs = []; // Random ±1 for each frequency component
      let offset_x = 0;
      let offset_y = 0;

      for (let j = 1; j <= MAX_FREQ; j++) {
        const r_j = Math.abs(gaussianRandom(0, PATH_LENGTH_SCALE / j));
        const theta_j = Math.random() * 2 * Math.PI;
        const sign_j = Math.random() < 0.5 ? 1 : -1;
        radii.push(r_j);
        thetas.push(theta_j);
        signs.push(sign_j);

        // Accumulate offsets so path starts at origin
        offset_x += r_j * Math.cos(theta_j);
        offset_y += r_j * Math.sin(theta_j);
      }

      // Add to particles array with epicycle parameters
      particles.push({
        el: clone,
        x0: rect.left,  // Original x position
        y0: rect.top,   // Original y position
        radii: radii,
        thetas: thetas,
        signs: signs,   // Rotation direction for each component
        offset_x: offset_x,
        offset_y: offset_y,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startPanicAnimation(particles, scrollY);
  }

  function startPanicAnimation(particles, originalScrollY) {
    const DELAY_TIME = 2000; // 2 seconds delay before movement
    const MOVEMENT_TIME = 7800; // 7.8 seconds of movement
    const TOTAL_TIME = DELAY_TIME + MOVEMENT_TIME; // 9.8 seconds total
    const startTime = performance.now();

    function animate(currentTime) {
      if (!panicActive) return;

      // Calculate elapsed time in milliseconds
      const elapsed = currentTime - startTime;

      // Check if 9.8 seconds have elapsed
      if (elapsed >= TOTAL_TIME) {
        exitPanicMode(particles, originalScrollY);
        return;
      }

      // Calculate t as fraction of movement time (0 to 1)
      // During the first 2 seconds (delay), t = 0 (no movement)
      let t = 0;
      if (elapsed > DELAY_TIME) {
        t = (elapsed - DELAY_TIME) / MOVEMENT_TIME;
      }

      particles.forEach(particle => {
        // Epicycle parameterization: sum of circles at different frequencies
        // x(t) = sum_j r_j * cos(2π * j * t + theta_j) - offset_x
        // y(t) = sum_j r_j * sin(2π * j * t + theta_j) - offset_y
        let dx = 0;
        let dy = 0;

        for (let j = 0; j < particle.radii.length; j++) {
          const freq = j + 1; // Frequency is 1, 2, 3, ...
          const angle = 2 * Math.PI * freq * t * particle.signs[j] + particle.thetas[j];
          dx += particle.radii[j] * Math.cos(angle);
          dy += particle.radii[j] * Math.sin(angle);
        }

        // Subtract offsets to ensure path starts at origin
        dx -= particle.offset_x;
        dy -= particle.offset_y;

        // Apply radial coefficient to make letters drift farther over time
        // radial_coeff = max(1, elapsed_in_seconds + 2 - TOTAL_TIME_in_seconds)
        const elapsed_seconds = elapsed / 1000;
        const total_seconds = TOTAL_TIME / 1000;
        const radial_coeff = Math.max(1, elapsed_seconds + 2 - total_seconds);
        dx *= radial_coeff;
        dy *= radial_coeff;

        // Calculate current position (original position + offset)
        const x = particle.x0 + dx;
        const y = particle.y0 + dy;

        // Apply transform (relative to the element's original left/top)
        particle.el.style.transform = `translate(${x - parseFloat(particle.el.style.left)}px, ${y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  function exitPanicMode(particles, originalScrollY) {
    panicActive = false;

    // Stop and clean up audio
    if (alarmAudio) {
      alarmAudio.pause();
      alarmAudio.currentTime = 0;
      alarmAudio = null;
    }
    if (screamAudio) {
      screamAudio.pause();
      screamAudio.currentTime = 0;
      screamAudio = null;
    }

    // Remove all particles
    particles.forEach(particle => {
      particle.el.remove();
    });

    // Remove flashing label
    const panicLabel = document.getElementById('panic-mode-label');
    if (panicLabel) {
      panicLabel.remove();
    }

    // Restore original characters
    document.querySelectorAll('.char').forEach(char => {
      char.style.visibility = '';
    });

    // Restore original glyphs
    document.querySelectorAll('i, svg').forEach(glyph => {
      glyph.style.visibility = '';
    });

    // Unlock body
    document.body.classList.remove('panic-locked');
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.left = '';
    document.body.style.right = '';
    document.body.style.overflow = '';
    document.body.style.width = '';
    window.scrollTo(0, originalScrollY);
  }
</script>

<script>
  // ============================================================================
  // NAVIGATION AND MYSTERY BUTTON LOGIC
  // ============================================================================

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    // Add mysterious glyphs to navbar
    const navList = document.querySelector('nav ul.navbar-nav');
    if (navList) {
      // Single question mark icon that randomly picks a mode
      const mysteryLi = document.createElement('li');
      mysteryLi.className = 'nav-item active';

      const mysteryLink = document.createElement('a');
      mysteryLink.className = 'nav-link';
      mysteryLink.style.cursor = 'pointer';
      mysteryLink.href = '#';

      const mysteryIcon = document.createElement('i');
      mysteryIcon.className = 'fas fa-question-circle';

      mysteryLink.appendChild(mysteryIcon);
      mysteryLi.appendChild(mysteryLink);

      mysteryLink.addEventListener('click', (e) => {
        e.preventDefault();

        // Check if on mobile device
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const isSmallScreen = window.innerWidth < 1024;
        const isMobile = isTouchDevice && isSmallScreen;

        // Check localStorage for click count
        let clickCount = parseInt(localStorage.getItem('mysteryButtonClicks') || '0');

        // If user hasn't clicked 3 times yet, show warning and increment
        if (clickCount < 3) {
          const messages = ["Hey, stop that!", "Can't you read?", "I'm serious!"];
          alert(messages[clickCount]);
          clickCount++;
          localStorage.setItem('mysteryButtonClicks', clickCount.toString());
          return; // Don't activate mode
        }

        // After 3 clicks, cycle through modes sequentially
        // Define the rotation order (skip gravity, vacuum, pong on mobile)
        const modeSequence = isMobile
          ? ['shatter', 'bird', 'splash', 'panic']
          : ['shatter', 'gravity', 'bird', 'splash', 'vacuum', 'panic', 'pong'];

        // Get current mode index with error handling
        let modeIndex = 0;
        try {
          const storedIndex = localStorage.getItem('mysteryModeIndex');
          if (storedIndex !== null) {
            const parsed = parseInt(storedIndex);
            // Validate the index is within bounds
            if (!isNaN(parsed) && parsed >= 0 && parsed < modeSequence.length) {
              modeIndex = parsed;
            } else {
              // Invalid index, reset to 0
              console.warn('Invalid mysteryModeIndex, resetting to 0');
              modeIndex = 0;
            }
          }
        } catch (e) {
          console.error('Error reading mysteryModeIndex:', e);
          modeIndex = 0;
        }

        // Get the current mode
        const currentMode = modeSequence[modeIndex];

        // Increment and save the next index (with wraparound)
        const nextIndex = (modeIndex + 1) % modeSequence.length;
        try {
          localStorage.setItem('mysteryModeIndex', nextIndex.toString());
        } catch (e) {
          console.error('Error saving mysteryModeIndex:', e);
        }

        // Reset button appearance (remove hover state)
        mysteryLink.blur();
        mysteryLink.style.setProperty('background-color', '', 'important');
        mysteryLink.style.setProperty('color', '', 'important');
        mysteryIcon.style.setProperty('color', 'black', 'important');

        // Activate the selected mode with error handling
        try {
          switch(currentMode) {
            case 'shatter':
              if (typeof enterShatterMode === 'function') {
                enterShatterMode();
              } else {
                console.error('enterShatterMode is not defined');
              }
              break;
            case 'gravity':
              if (typeof enterGravityMode === 'function') {
                enterGravityMode();
              } else {
                console.error('enterGravityMode is not defined');
              }
              break;
            case 'bird':
              if (typeof enterBirdMode === 'function') {
                enterBirdMode();
              } else {
                console.error('enterBirdMode is not defined');
              }
              break;
            case 'splash':
              window.location.href = '/splash/';
              break;
            case 'vacuum':
              if (typeof enterVacuumMode === 'function') {
                enterVacuumMode();
              } else {
                console.error('enterVacuumMode is not defined');
              }
              break;
            case 'panic':
              if (typeof enterPanicMode === 'function') {
                enterPanicMode();
              } else {
                console.error('enterPanicMode is not defined');
              }
              break;
            case 'pong':
              if (typeof enterPongMode === 'function') {
                enterPongMode();
              } else {
                console.error('enterPongMode is not defined');
              }
              break;
            default:
              console.error('Unknown mode:', currentMode);
          }
        } catch (e) {
          console.error('Error activating mode:', currentMode, e);
        }
      });

      navList.appendChild(mysteryLi);

      /* DEBUG VERSION: Uncomment to show all five icons for debugging
      // Shatter mode icon (question mark)
      const shatterLi = document.createElement('li');
      shatterLi.className = 'nav-item active';

      const shatterLink = document.createElement('a');
      shatterLink.className = 'nav-link';
      shatterLink.style.cursor = 'pointer';
      shatterLink.href = '#';

      const shatterIcon = document.createElement('i');
      shatterIcon.className = 'fas fa-question-circle';

      shatterLink.appendChild(shatterIcon);
      shatterLi.appendChild(shatterLink);

      shatterLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterShatterMode();
      });

      navList.appendChild(shatterLi);

      // Gravity mode icon (magnet)
      const gravityLi = document.createElement('li');
      gravityLi.className = 'nav-item active';

      const gravityLink = document.createElement('a');
      gravityLink.className = 'nav-link';
      gravityLink.style.cursor = 'pointer';
      gravityLink.href = '#';

      const gravityIcon = document.createElement('i');
      gravityIcon.className = 'fas fa-magnet';

      gravityLink.appendChild(gravityIcon);
      gravityLi.appendChild(gravityLink);

      gravityLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterGravityMode();
      });

      navList.appendChild(gravityLi);

      // Vacuum mode icon (meteor)
      const vacuumLi = document.createElement('li');
      vacuumLi.className = 'nav-item active';

      const vacuumLink = document.createElement('a');
      vacuumLink.className = 'nav-link';
      vacuumLink.style.cursor = 'pointer';
      vacuumLink.href = '#';

      const vacuumIcon = document.createElement('i');
      vacuumIcon.className = 'fas fa-meteor';

      vacuumLink.appendChild(vacuumIcon);
      vacuumLi.appendChild(vacuumLink);

      vacuumLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterVacuumMode();
      });

      navList.appendChild(vacuumLi);

      // Splash page link icon (home)
      const splashLi = document.createElement('li');
      splashLi.className = 'nav-item active';

      const splashLink = document.createElement('a');
      splashLink.className = 'nav-link';
      splashLink.style.cursor = 'pointer';
      splashLink.href = '/splash/';

      const splashIcon = document.createElement('i');
      splashIcon.className = 'fas fa-home';

      splashLink.appendChild(splashIcon);
      splashLi.appendChild(splashLink);

      navList.appendChild(splashLi);

      // Pong mode icon (gamepad)
      const pongLi = document.createElement('li');
      pongLi.className = 'nav-item active';

      const pongLink = document.createElement('a');
      pongLink.className = 'nav-link';
      pongLink.style.cursor = 'pointer';
      pongLink.href = '#';

      const pongIcon = document.createElement('i');
      pongIcon.className = 'fas fa-gamepad';

      pongLink.appendChild(pongIcon);
      pongLi.appendChild(pongLink);

      pongLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterPongMode();
      });

      navList.appendChild(pongLi);
      */
    }
  });
</script>



    <div class="page-content" style="flex: 1 0 auto;">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="container">
    <br>

    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">Reflections on introductory neuroscience reading</h1>
      <p class="post-meta"><time datetime="2024-03-02T00:00:00-08:00" itemprop="datePublished">Mar 2, 2024</time></p>
    </header>

    <div class="post-content" itemprop="articleBody">
      <p>Have you ever lived in a neighborhood for years and realized, as you prepare to move out, that you never got to know the guy who lives next door? For me, that unknown neighbor is the field of neuroscience. I am nearing the end of a PhD in <a href="https://deweeselab.com">a lab that does largely neuroscience</a> and live under the umbrella of the <a href="https://redwood.berkeley.edu/">Redwood Center for Theoretical Neuroscience</a>, but I confess I’ve never engaged with the field in any serious way.</p>

<p>As with that neighbor you don’t really know, I’ve often <em>seen</em> neuroscience — I regularly pass by it on the sidewalk, so to speak, exchanging cordial pleasantries but never really engaging, always with something just a little more important to do. Look, I’m sure neuroscience is a <em>nice guy</em> and all that, but we just don’t have that much in common! A lot of people seem to like him, but we’ve just never really clicked – and besides, isn’t he the one with all those rats? It’s hard for me to understand what he’s saying or why, so when we pass each other on the street, I usually just smile and nod and continue on my way.</p>

<p><strong>No more. I’ve decided to learn some neuroscience. These past weeks, I’ve been doing basic reading in an effort to absorb some of the big ideas. This post will summarize some of what I’ve learned.</strong> If you come from a similar academic background and have a similar curiosity, perhaps you’ll find some of this interesting.</p>

<h3 id="why-would-i-learn-neuroscience">Why would I learn neuroscience?</h3>

<p>I’m doing this for two main reasons. The first is self-knowledge: I’m in a reflective period in which I aim to better understand myself, and I suspected that some basic neuro- and cognitive science might help me better understand my own experience — and indeed it has! Seeing the important ways in which our brains are hacky really gives me a sense of humility and a feeling that human experience is often different and much stranger than we conceive it to be, so we ought to really look at it. The second is more general: if you’ve never touched a field, there are often big foundational ideas sitting on the surface for you to learn, and so a fairly short period of learning can give outsize returns because you’re on the steep part of the learning curve. That also turned out to be true — I’d underestimated how much we know about the brain and how easily some of my naïve notions could be improved.</p>

<h3 id="plan-of-attack">Plan of attack</h3>

<p>I’m a physicist by training, and I like to think about general principles and big ideas, so over the past few weeks I read Sterling and Laughlin’s <em>Principles of Neural Design.</em> This is an introductory book focused less on the specifics of anatomy and much more on broad principles which govern neural circuitry across brain regions and across species. This was a good match for the level of detail at which I wanted to learn things — I don’t need to know about, say, the superior temporal gyrus or the difference between norepinephrine and epinephrine, but I do want to know that neural circuitry aggressively tries to minimize wire length and energy consumption.  It gives a nice overview of how someone familiar with physical or systems thinking could begin to start thinking about the brain. I also read some of Kandel et al.’s <em>Principles of Neural Science</em>,<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> a classic introductory text.</p>

<h1 id="some-learnings">Some learnings</h1>

<p>Without further ado, here’s a bunch of stuff I learned.</p>

<h3 id="the-brain-is-very-structurally-complicated">The brain is very structurally complicated</h3>

<p>Coming from machine learning, my naive picture of the brain was basically that it’s a big homogeneous mass of neurons initially connected in a mostly random fashion, with inputs to some regions and outputs from others, and that learning from experience leads to gradual strengthening and weakening of neural connections so that this mass of neurons eventually knows and learns.</p>

<p style="text-align:center;">
<img src="/img/neuro/self_conception.png" width="50%" />
</p>

<p>In reality, the brain is highly structured. This is actually pretty apparent from anatomy, even at a coarse level: the inside of the brain is whitish (containing mostly long insulated communication channels, or <em>white matter</em>), while the outer few millimeters is greyish (containing lots of neurons with dense short-range connections, or <em>grey matter</em>). Different regions of the brain have different textures, with peculiarly-shaped masses on the inside and in the hindbrain.</p>

<p>In fact, even the cerebral cortex — the big wrinkly part that covers most of the outside of the brain — is in reality made up of lots of distinct regions which differ in their cellular structure! Over a century ago, Korbinian Brodmann made close examination of the cytostructure of the cortex and identified some <a href="https://en.wikipedia.org/wiki/Brodmann_area">52 distinct regions</a> with different cellular composition and patterning. Some of these regions have since been found to be robustly responsible for distinct brain functions, like <a href="https://en.wikipedia.org/wiki/Auditory_cortex">processing sound</a>, <a href="https://en.wikipedia.org/wiki/Postcentral_gyrus">processing touch</a>, and <a href="https://en.wikipedia.org/wiki/Broca%27s_area">language production</a>. The fact that these different regions of the homogenous-looking cortex are physiologically distinct and consistently perform different roles is a surprise to me!<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup></p>

<p style="text-align:center;">
<img src="/img/neuro/brodmann_areas.png" width="40%" />
</p>
<p style="margin-left:20%; margin-right:20%;">
<small>
<i> The homogeneous-looking cortex is actually comprised of many regions of differing functions and cellular properties. Surprisingly to me, these regions do not follow the folds of the cortex! </i>
</small>
</p>

<p>This complexity extends down to the level of individual neurons. There isn’t just one type of “neuron” — rather, the brain has tens to hundreds of different types of firing and support cells with very different geometries adapted to different roles and parts of the brain. On the small end, cerebellar <a href="https://en.wikipedia.org/wiki/Granule_cell">granule cells</a> are only ~5 µm in size with axons of width on the order of only 200 nm (!). These connect directly with <a href="https://en.wikipedia.org/wiki/Purkinje_cell">Purkinje cells</a>, which have cell bodies about 10x wider and dendritic arbors that spread out in a striking planar shape as far as several millimeters. The retina, which translates incoming light into neural signals, contains multiple layers of many distinct cell types, starting with specialized rod and cone cells and leading up to the optic nerve, which is essentially a cable-like bundle of about $10^6$ axons which extend for several <em>centimeters</em> (!) from the eye to the visual cortex. The largest neurons in the body stretch from the spinal cord to the ends of the limbs and can be over a meter in length. Thinking of these all as “neurons” seems as reductive as referring to all components of a mechanical system or electronic circuit as just “components” — it’s not wrong, but it’s almost always more useful to work at a finer level of abstraction.</p>

<h4 id="why-are-things-so-complicated">Why are things so complicated?</h4>

<p>Here’s another amazing fact which will turn out to be related: in the nematode C. elegans, every individual has exactly 302 neurons, and they’re always in the same place and connected the same way.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup> This might seem shocking — after all, aren’t central nervous systems these flexible, adaptive systems that differ between individuals? It certainly surprises me until I remember that, well, the adult human body has exactly 206 bones and some 600 muscles, and they’re always in the same place and connected the same way. Biology is certainly capable of specifying this level of detail. Since the nematode doesn’t really need to learn, why <em>not</em> just hard-code a rigid rule-based control system for its simple body?</p>

<p>The important fact here is that the main role of a central nervous system is not to <em>learn,</em> it is to dictate global actions and share information between different parts of an organism’s body necessary for doing so. Sterling and Laughlin illustrate this beautifully by pointing to the rudimentary chemical and electrical signaling of the paramecium — which is hard-coded and includes commands like “back up” and “turn” — as the ancestor of our own nervous systems. Learning in its various forms is sort of a remarkable recent development which allows a nervous system to adapt to its environment. In this light, it makes a lot of sense that the brain would be so complicated — it’s evolved from nervous systems like those of C. elegans, except instead of 302 hard-coded neurons, our brains have a few hundred hard-coded parts, and the fact that some learning can occur within each part is somewhat secondary to the overall control flow.</p>

<h3 id="the-brain-generally-obeys-a-handful-of-low-level-design-principles">The brain generally obeys a handful of low-level design principles</h3>

<p>What does it mean to “understand the brain”? Coming from machine learning theory, I’d held this notion to a high bar: surely <em>understanding</em> in neuroscience would mean we know the precise encoding scheme for memories, or can give a mathematical model of human reasoning played out in neural firings, or concretely explain what happens neurologically when you imagine something. I hadn’t appreciated the degree to which these cognitive, experiential things are really just one level of the layer cake of neuroscience. There are in fact many other levels of abstraction which we understand fairly well!</p>

<p><em>Principles of Neural Design</em> sets out to collect some low-level principles, and I found many of these quite compelling! Here are a few:</p>

<ul>
  <li><strong>Compute with chemistry whenever possible.</strong> Neural firing is energetically expensive — it’s much cheaper to transmit signals via releasing chemicals which travel diffusively! However, diffusive signaling spreads only as [distance] ~ [time]${}^{1/2}$, which ends up meaning it’s usually not a good choice when you need to go, say, more than a millimeter in one direction. Chemical computing tends also to require fewer parts and take up less space. The animal nervous system reliably uses chemical signal for either short-distance processing (e.g., across synapses or within cells) or slow global signal transmission (e.g., hormones in the bloodstream), and makes surprising use of proteins which change conformation in the presence of a ligand in order to perform basic computational operations.</li>
  <li><strong>Send only what is needed.</strong> Signal transmission is expensive — the brain uses almost 20% of the body’s energy, over half of which goes to neurons’ ion pumps! It’s therefore important to be economical in what’s sent — sending half as much information roughly cuts the energy cost in half. Across areas, the brain has robustly developed to only transmit necessary information and compress it as much as possible — often in ways that seem surprising given our experience of the world! The classic example of this is the visual system — we only have detailed vision in the central region of our field of view, and it’s shockingly low-res in the periphery — <a href="https://www.scientificamerican.com/article/put-your-peripheral-vision-to-the-test/">people regularly underestimate how bad their peripheral vision is</a>. I honestly find it a bit annoying when I notice it, but it makes a lot of sense evolutionarily — the point of the visual system isn’t to provide our brain with a beautiful detailed image of the outside world, it’s to give us enough information to do survival and social tasks, and we can do these tasks quite well with only a small area of high-res vision that we scan around! This principle also applies to the postprocessing that occurs in the retina, which famously <a href="http://www.scholarpedia.org/article/Sparse_coding">compresses visual information by translating to a sparse basis</a> before transmission through the optic nerve.</li>
  <li><strong>Send at the lowest acceptable rate.</strong> A cool fact I hadn’t known: sending a neural signal faster requires a thicker axon, which for biophysical reasons turns out to require superlinearly more resources and energy! The brain’s thus incentivized to send information as slowly as possible. This is basically true everywhere in the brain — I suppose it’s evolutionarily “easy” to tweak axons to be thinner and slower, so they’ll always tend to settle down to the slowest rate that works well enough. An amazing example of this is the speeds of different sensory modalities: olfaction (smell) has no need to be fast, so it uses a cable of $10^7$ very thin axons to send information quite slowly, while on the other end, the vestibular sense (balance) needs to send little information but needs to send it fast to keep us upright, so it uses far fewer axons which are about 100x cross-sectionally larger.</li>
</ul>

<p style="text-align:center;">
<img src="/img/neuro/axon_sizes.png" width="60%" />
</p>

<p>There are, of course, plenty of exceptions here: the design of the vertebrate retina is famously silly, with processing circuitry partially blocking the photosensitive cells and the optic nerve creating a blind spot in each eye. I’m not sure how to square these cases with the observation that the brain often does a good job finding efficient design. Maybe the satisfaction of these principles is achieved via a kind of local gradient descent – e.g., by making small adjustments to axon thickness, neuron count, connectivity, and so on – and these weird cases reflect evolutionary “local minima” that are hard to escape?</p>

<ul>
  <li><strong>Minimize wire.</strong> Rather intuitively, longer axons take up more space, cost more energy, and slow signal transmission, so the brain tends to shorten wires as much as possible. This is achieved partially at the level of individual neurons, which tend to take shapes and choose branching points that reach all their connections in a local minimum of total distance.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup> It is also achieved via organization of neural regions into maps — for example, the early visual cortex is arranged spatially in a 2D way that mimics the retina, which minimizes diagonal cross-wiring. Some brain areas have peculiar neural organization, like the aforementioned <a href="https://www.snexplores.org/wp-content/uploads/2020/04/1030_LL_trees-1028x579.png">fan-shaped Purkinje cells stacked in the cerebellum</a>, and this organization allows for lots of dense connections in a small volume.</li>
  <li><strong>Complicate and specialize.</strong> The cost of a neural design is <em>not</em> in its complexity, it’s in the amount of resources it uses — that is, space, energy, time, and physical materials. If a neural circuit can be complicated in exchange for using less of one of these, it often will! As a result, there are a huge number of different neurons with different geometries, firing rates, sensitivities, and so on, which economize some resource. Every part of a signaling pathway in the brain is thus adapted to its place in the chain, and will adapt so it fulfills its role — transmitting with a particular fidelity, across a particular distance, and in a particular time — as cheaply as possible. An example I like: opsin molecules in rod cells in the eye are occasionally activated by random thermal noise… but they’re designed to be just robust enough that this noise level is just a few times below the activity rate when looking around in starlight.</li>
</ul>

<h3 id="there-are-many-levels-at-which-we-might-want-to-understand-the-brain">There are many levels at which we might want to “understand” the brain</h3>

<p>As aforementioned, I hail from physics, where the bar for understanding is quite high: one expects a tight, testable, ideally-mathematical theory before one believes one understands a complex system. Applied to the brain, a physicist might want, say, a clean, elegant, mathematical theory for how high-level concepts are represented and manipulated in the brain before saying we understand what it’s doing, perhaps using notions of sparsity, information theory, high-dimensional geometry, and so on. This still seems like a reasonable-albeit-distant dream to me,<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote">5</a></sup> but there are many more levels at which we could understand the brain. Here are two:</p>

<p><strong>Low-level component design.</strong> As discussed in the previous section, we can very much ask questions like: “given that this component performs this signaling task, why is it designed like this?” Questions like this are among the most answerable in neuroscience — appealing to efficiency principles seems to work pretty often! Of course, we often don’t know what task a component performs.</p>

<p><strong>Broad stories about high-level information processing.</strong> I hadn’t appreciated the degree to which you don’t <em>need</em> a mathematical description of learning in order to find pretty compelling stories about what different parts of the brain are doing. For example, we can tell loose stories like “when engaged in conversation, the auditory cortex preprocesses incoming sound, Wernicke’s area processes the sound as speech, and Broca’s area is responsible for speech production.” From the perspective of a physicist, this is an <em>incredibly vague</em> story: what do you <em>mean</em> by “processing the sound as speech”? What is <em>involved</em> in speech production? And how on earth is this all encoded in a bunch of noisy neurons? These are very real questions, but the important realization for me is, well, you don’t need to know that for a lot of stuff. For example, if a patient’s Broca’s area is lesioned, they’ll be unable to produce speech correctly. If a patient’s Wernicke’s area is lesioned, they’ll be unable to understand speech but, remarkably, able to produce it. These areas light up under brain scanning when performing relevant tasks. This incredibly vague story seems to work, actually — well enough to inform medical interventions! We didn’t actually <em>need</em> to know how the neural circuits work: vague, high-level stories are useful enough for some real understanding.</p>

<p>It seems to me like most of our high-level brain knowledge is of this form: we have stories like “Part A is responsible for task X. Task X also requires input from Part B, so Parts A and B are wired together, and that wiring strengthens as one performs more of Task X.” We pretty rarely have a low-level understanding of how neural circuitry is computing, but we have stories like this for lots and lots of parts and tasks. This view is reminscent of <a href="https://notes.andymatuschak.org/zQnTUMfm4YPLyi8GFA1Ym1e">Marr’s three levels of abstraction</a>, which proposes that computing systems can be studied at the level of the task ultimately performed (the highest level), the algorithm used to perform that task (the middle level), or the hardware used to implement that algorithm (the lowest level). Perhaps a good story here is that neuroscience has made major progress on the lowest and highest levels, but it’s still unclear how to connect them: we cannot extract the algorithms <em>performed by</em> neural hardware which <em>implement</em> the high-level functions which we know brain regions to perform.</p>

<p>One interesting takeaway I glean from all this is that it now seems like the thing I purport to want — a simple mathematical description of learning — actually lies not at the highest level of abstraction but at an intermediate level, above the level of small circuits but below the level of brain regions. I’m also less confident that it’s really a good goal!</p>

<h3 id="how-do-we-learn">How do we learn?</h3>

<p>The nature of learning is still pretty unclear to me from my reading. It seems like there are a bunch of different mechanisms — synapses that have fired recently more readily fire again in the following seconds and minutes, synapses that have fired many times tend to increase their sensitivity, dopamine release (which is globally mediated) tends to reinforce neurons to do whatever they were just doing. I’m confused as to how to think about these mechanisms — is there a sharp difference between short-term and lon-term memory? Is there a difference between short-term memory and “what you’re thinking about right now”? Is most learning distributed and reward-signal-free, or is it top-down modulated as in machine learning? What tasks even count as “learning” — I could believe there are many more than the typical testing suite I envision! I feel I’ve gotten a bit of flavor for some of these learning mechanisms, but not enough to have any real picture of learning in the brain.</p>

<p>This set of questions seems particularly interesting where it intersects with our everyday human experience. For example:</p>

<ul>
  <li>
    <p>What’s going on neurologically when we forget things?</p>
  </li>
  <li>
    <p>When you hear or use an usual word, you’re more likely to notice or use it again soon after. Is this explicable through some known neuro learning mechanism?</p>
  </li>
  <li>
    <p>What’s the difference between factual learning and wisdom? Why does some learning feel like it affects our worldview, while other learning feels like just memorizing facts?</p>
  </li>
</ul>

<h3 id="fun-facts">Fun facts</h3>

<p>Some disconnected fun facts from my reading:</p>

<ul>
  <li>
    <p>The brain has a region called the <em>suprachiasmatic nucleus</em> which takes in input from the retina regarding how generally light a scene is and serves as the body’s 24-hour clock.</p>
  </li>
  <li>
    <p>Neurons in the brain are outnumbered by glial cells (i.e. everything else) by a factor between 10 and 50.</p>
  </li>
  <li>
    <p>The skull is physically full of brain, and synapses expand when they get stronger, so it’s often the case that practicing one skill causes part of the brain to physically grow, which causes other parts to shrink! This can have expected-but-still-alarming consequences in which learning one skill directly degrades performance at another — for example, learning to read decreases one’s ability to recognize faces! (I’m confused as to what to take away from this in light of <a href="https://www.scientificamerican.com/article/what-is-the-memory-capacity/">the common claim that the brain’s storage capacity is so large it’s virtually unlimited</a>.)</p>
  </li>
</ul>

<h1 id="closing-thoughts">Closing thoughts</h1>

<p>I set out to see if I could glean a high-level view of the field of neuroscience from some foundational background reading. I actually feel I’ve managed to do that to a modest degree! It was an endeavor well worth the time investment; I’d recommend it to others who are interested, and will probably do it again myself with different fields.</p>

<p>In general, I’d say we actually understand more about neuroscience than I’d thought! While the things I thought were mysteries generally do seem to be unknown, I was blind to the many levels at which modern neuroscience examines the brain and thus to the very real progress we’ve made towards characterizing the brain’s functioning and relating it to both evolutionary pressures and our own human experience. I’m left quite impressed by the sheer amount of work required to get to this point — as an acquaintance recently told me, it takes a PhD’s worth of work to get one line in a textbook.<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" class="footnote">6</a></sup></p>

<p>The most profound conceptual discoveries in the sciences — perhaps simply in general — often build bridges between two things that previously seemed to live in different worlds. My interest in neuroscience basically stems from a hope of this nature. Our lives as human beings take place largely in the world of our own internal processing: our cognition, sensation, and action; our feelings, reactions, and dreams. However, we have far more concrete, reliable understanding of the physical world of atoms and molecules, proteins and neurons, circuits and brains. I’m excited (both selfishly and altruistically) by the prospects for building bridges between these realms, starting to understand our own human experience in terms of basic science.</p>

<p><em>Thanks to <a href="https://csinva.io/">Chandan Singh</a> and Mike DeWeese for feedback on this post!</em></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Yes, these two books have confusingly similar names. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>It took a protracted debate to arrive at the modern view of the cortex as composed of distinct regions which perform different elementary processing operations. Interestingly, this idea originated with <a href="https://en.wikipedia.org/wiki/Phrenology">phrenology</a>, which in the early 1800s posited that the brain is comprised of some 30+ regions responsible for personality traits like “wit,” “religiosity,” “benevolence,” and so on. This framework is now understood to be totally wrong and based in little to no evidence, but the idea of a few dozen distinct brain regions was right - by accident as far as I can tell! After that came an era dominated by the “aggregate field view” that essentially held that the whole brain does everything, after which the modern “cellular connectionist” view took hold. Most of the early evidence for the modern view came from studying patients with certain cognitive or motor impairments and consistently finding damage in the same part of their brains. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Fun fact: C. elegans neurons also use analog signaling, not pulsatile signaling (aka “firing”). <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Tree branches and root systems do something like this too! <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>In all honesty, I personally find this question so appealing and seductive that it’s distracting from more concrete problems. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:6" role="doc-endnote">
      <p>That said, it’s likely I’m too optimistic about understanding here given that I’ve just read a compendium of lots of things we understand. It seems likely that there are lots of things we don’t understand, even at the lowest and highest levels of abstraction: plenty of microscopic neural processes remain difficult or impossible to characterize with current tools, and there are surely lots of macroscopic brain areas about which we don’t have really compelling stories as to their function. <a href="#fnref:6" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>

    
<div class="comments-section">
  <hr>
  <script src="https://giscus.app/client.js"
        data-repo="james-simon/james-simon.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkyNjI1MjAxNzM="
        data-category="Comments"
        data-category-id="DIC_kwDOD6W9bc4C1HyR"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        crossorigin="anonymous"
        async>
  </script>
</div>



  </div>

</article>

      </div>
    </div>

    <div class="text-center p-3" style="background-color: #e8e8e8;">
  <div class="container ">
    <div class="row justify-content-md-center">

      <div class="col-2">
        <p class="text-center">
          <i class="far fa-envelope"></i>
          <a href="mailto:jsi@berkeley.edu">jsi@berkeley.edu</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-github"></i>
          <a href="https://github.com/james-simon">james-simon</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fas fa-graduation-cap"></i>
          <a href=https://scholar.google.com/citations?user=zjGfh3sAAAAJ&hl=en>gScholar</a>
        </p>
      </div>

    </div>
  </div>
</div>
</footer>

  </body>

</html>
