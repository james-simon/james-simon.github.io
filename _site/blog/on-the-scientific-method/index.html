<!DOCTYPE html>
<html>

  <head>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        equationNumbers: { autoNumber: "AMS" },
        tagSide: "right"
      },
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      }
    });
    MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function () {
      MathJax.InputJax.TeX.Stack.Item.AMSarray.Augment({
        clearTag() {
          if (!this.global.notags) {
            this.super(arguments).clearTag.call(this);
          }
        }
      });
    });
  </script>
  <script type="text/javascript" charset="utf-8"
    src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS_CHTML">
  </script>


  <!-- <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>On the scientific method and its application to the science of deep learning</title>
  <meta name="description" content="I have recently found myself involved in many discussions centered on the question of how we might develop a satisfactory science of modern machine learning....">

  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">

  <!-- <link href="/bootstrap/css/bootstrap.css" rel="stylesheet">
  <script src="/boostrap/js/bootstrap.js"></script> -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css" rel="stylesheet">

  <link rel="canonical" href="http://james-simon.github.io/blog/on-the-scientific-method/">
  <link rel="alternate" type="application/rss+xml" title="Jamie Simon" href="http://james-simon.github.io/feed.xml">

  <style>
    body {
      font-family: "et-book", "ETBookOT", "ET Book", Georgia, "Times New Roman", serif !important;
    }

    a:link {
      color: #1a4d8f;
      text-decoration: none;
    }

    a:visited {
      color: #6b2d8f;
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }
  </style>

  

</head>


  <body style="display: flex; flex-direction: column; min-height: 100vh; margin: 0;">

    <!-- <header class="site-header"> -->
    <!-- <a class="site-title" href="/">Jamie Simon</a> -->
<!-- </header> -->

    <style>
      .nav-link {
        transition: all 0.2s ease;
        border-radius: 4px;
        padding: 8px 16px !important;
      }

      .nav-link:hover {
        background-color: #333 !important;
        color: white !important;
      }

      .nav-link:hover i {
        color: white !important;
      }

      /* Hide text on narrow screens, show only icons */
      @media (max-width: 767px) {
        .nav-link .nav-text {
          display: none;
        }
        .nav-link {
          padding: 8px 12px !important;
        }
      }
    </style>

    <nav class="navbar navbar-expand navbar-light" style="background-color: #edf3f5;">
      <div class = "container">
        <a class="navbar-brand" href="/">Jamie Simon</a></span> </a>
        <div class="navbar-collapse">
          <ul class="nav navbar-nav ml-auto" style="flex-wrap: nowrap;">
            <li class = "nav-item active"><a class="nav-link" href="/research/"><i class="fas fa-cogs"></i><span class="nav-text"> Research</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/blog/"><i class="fas fa-seedling"></i><span class="nav-text"> Blog</span></a></li>
            <li class = "nav-item active"><a class="nav-link" href="/puzzles/"><i class="fab fa-laravel"></i><span class="nav-text"> Puzzles</span></a></li>
          </ul>
        </div>
      </div>
    </nav>

    <style>
  .char {
    display: inline;
    margin: 0;
    padding: 0;
    border: 0;
    vertical-align: baseline;
    line-height: inherit;
    font: inherit;
    font-size: inherit;
    font-weight: inherit;
    font-style: inherit;
    font-family: inherit;
    color: inherit;
    white-space: inherit;
    letter-spacing: inherit;
    word-spacing: inherit;
    text-decoration: inherit;
    text-transform: inherit;
    background: transparent;
  }

  .char-particle {
    position: fixed;
    margin: 0;
    will-change: transform;
    pointer-events: none;
  }

  body.shatter-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  body.bird-locked {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    overflow: hidden;
    width: 100%;
  }

  #shatter-overlay-blocker {
    position: fixed;
    inset: 0;
    pointer-events: auto;
    z-index: 9999;
    display: none;
  }

  body.shatter-locked #shatter-overlay-blocker {
    display: block;
  }
</style>

<div id="shatter-overlay-blocker"></div>
<audio id="shatter-audio" preload="auto" src="/audio/glass_bottle_breaking.mp3"></audio>
<audio id="pop-1" preload="auto" src="/audio/pop_1.mp3"></audio>
<audio id="pop-2" preload="auto" src="/audio/pop_2.mp3"></audio>
<audio id="pop-3" preload="auto" src="/audio/pop_3.mp3"></audio>
<audio id="pop-4" preload="auto" src="/audio/pop_4.mp3"></audio>
<!-- Bird mode audio -->
<audio id="goose-honk" src="/audio/bird_sounds/goose_honk.mp3" preload="auto"></audio>
<audio id="goose-yell" src="/audio/bird_sounds/goose_yell.mp3" preload="auto"></audio>
<audio id="hawk-call" src="/audio/bird_sounds/hawk_call.mp3" preload="auto"></audio>

<script>
  // ============================================================================
  // INTERACTIVE MODES FOR /shatter PAGE
  // ============================================================================
  // This script implements three interactive modes:
  // 1. SHATTER MODE: All elements explode and bounce with gravity
  // 2. GRAVITY MODE: Text and glyphs are attracted to the mouse cursor
  // 3. VACUUM MODE: Text and glyphs are sucked into the mouse and disappear
  // ============================================================================

  // Global state
  let shatterActive = false;
  let gravityActive = false;
  let vacuumActive = false;
  let pongActive = false;
  let birdModeActive = false;
  let mouseX = 0;
  let mouseY = 0;
  let prevMouseX = 0;
  let prevMouseY = 0;

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  function playRandomPop() {
    const popIndex = Math.floor(Math.random() * 4) + 1;
    const audio = document.getElementById(`pop-${popIndex}`);
    if (audio) {
      audio.volume = 0.3; // Quieter pops
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Pop sound failed:', err));
    }
  }

  // Check if a point is close to a line segment
  function distanceToLineSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const lengthSquared = dx * dx + dy * dy;

    if (lengthSquared === 0) {
      // Line segment is a point
      const distX = px - x1;
      const distY = py - y1;
      return Math.sqrt(distX * distX + distY * distY);
    }

    // Project point onto line segment
    let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
    t = Math.max(0, Math.min(1, t)); // Clamp to [0, 1]

    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;

    const distX = px - closestX;
    const distY = py - closestY;
    return Math.sqrt(distX * distX + distY * distY);
  }

  function wrapTextNodes(node) {
    // Skip script, style, and interactive mode elements
    if (node.nodeType === Node.ELEMENT_NODE) {
      const tagName = node.tagName;
      const elemId = node.id;

      // Skip these elements entirely
      if (tagName === 'SCRIPT' || tagName === 'STYLE' ||
          tagName === 'CODE' || tagName === 'PRE' ||
          tagName === 'KBD' || tagName === 'SAMP' ||
          tagName === 'TEXTAREA' || tagName === 'INPUT' ||
          tagName === 'SELECT' || tagName === 'BUTTON' ||
          elemId === 'shatter-overlay-blocker' ||
          elemId === 'shatter-audio' ||
          elemId?.startsWith('pop-')) {
        return;
      }

      // Skip fixed/absolute positioned elements (like nav, modals, etc.)
      const style = window.getComputedStyle(node);
      if (style.position === 'fixed' || style.position === 'absolute') {
        return;
      }

      // Skip elements that are hidden
      if (style.display === 'none' || style.visibility === 'hidden') {
        return;
      }
    }

    // If it's a text node, wrap each character
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent;
      if (text.trim().length === 0) return; // Skip whitespace-only nodes

      const fragment = document.createDocumentFragment();
      // Use Array.from to properly handle multi-byte characters like emojis
      const chars = Array.from(text);
      for (let i = 0; i < chars.length; i++) {
        const char = chars[i];
        if (char === ' ') {
          // Preserve spaces as regular text nodes
          fragment.appendChild(document.createTextNode(' '));
        } else {
          const span = document.createElement('span');
          span.className = 'char';
          span.textContent = char;
          fragment.appendChild(span);
        }
      }
      node.parentNode.replaceChild(fragment, node);
    }
    // Recursively process child nodes
    else if (node.nodeType === Node.ELEMENT_NODE) {
      const children = Array.from(node.childNodes);
      children.forEach(child => wrapTextNodes(child));
    }
  }

  // ============================================================================
  // SHATTER MODE
  // ============================================================================

  // Gaussian random number generator (Box-Muller transform)
  function gaussianRandom(mean = 0, stdDev = 1) {
    const u1 = Math.random();
    const u2 = Math.random();
    const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
    return z0 * stdDev + mean;
  }

  function enterShatterMode() {
    if (shatterActive) return;
    shatterActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    const particles = [];

    // Helper function to create particle from element
    function createParticle(element, rect, isText = false) {
      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the element
      const clone = element.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(element);

      // For icon elements (i, svg), copy minimal styles to avoid interfering with pseudo-elements
      if (element.tagName === 'I' || element.tagName === 'SVG') {
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.color = computedStyle.color;
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      } else {
        // For other elements, copy full styles
        // Ensure emoji fonts are preserved by adding them to the font stack
        const fontFamily = computedStyle.fontFamily;
        clone.style.fontFamily = fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
        clone.style.fontSize = computedStyle.fontSize;
        clone.style.fontWeight = computedStyle.fontWeight;
        clone.style.color = computedStyle.color;
        clone.style.backgroundColor = computedStyle.backgroundColor;
        clone.style.border = computedStyle.border;
        clone.style.borderRadius = computedStyle.borderRadius;
        clone.style.padding = computedStyle.padding;

        // Preserve dimensions for all elements to prevent shrinking
        clone.style.width = rect.width + 'px';
        clone.style.height = rect.height + 'px';
        clone.style.boxSizing = 'border-box';
      }

      // Set z-index: text always on top, then smaller elements in front
      if (isText) {
        clone.style.zIndex = '10000';
      } else {
        // Calculate area and set z-index inversely (smaller = higher z)
        const area = rect.width * rect.height;
        // Map area to z-index range 1000-9999 (larger area = lower z)
        const zIndex = Math.max(1000, Math.min(9999, 9999 - Math.floor(area / 10)));
        clone.style.zIndex = zIndex.toString();
      }

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      element.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: rect.width,
        height: rect.height
      });
    }

    // Helper function to shatter images into pieces
    // COMMENTED OUT - uncomment to enable image shattering
    /*
    function shatterImage(imgElement, rect) {
      if (rect.width === 0 || rect.height === 0) return;
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) return;

      // Get the image source
      let imageSrc = imgElement.src;

      // If it's an element with background-image, get that instead
      const computedStyle = window.getComputedStyle(imgElement);
      const bgImage = computedStyle.backgroundImage;
      if (bgImage && bgImage !== 'none') {
        const match = bgImage.match(/url\(["']?([^"']*)["']?\)/);
        if (match) imageSrc = match[1];
      }

      // Generate random cut positions with average spacing of ~50px
      const avgSize = 50;
      const variance = 25; // ±25px variation

      // Generate vertical cut positions (x coordinates)
      const xCuts = [0];
      let x = 0;
      while (x < rect.width) {
        x += avgSize + (Math.random() - 0.5) * variance * 2;
        if (x < rect.width) xCuts.push(Math.round(x));
      }
      xCuts.push(rect.width);

      // Generate horizontal cut positions (y coordinates)
      const yCuts = [0];
      let y = 0;
      while (y < rect.height) {
        y += avgSize + (Math.random() - 0.5) * variance * 2;
        if (y < rect.height) yCuts.push(Math.round(y));
      }
      yCuts.push(rect.height);

      // Create pieces based on irregular grid
      for (let row = 0; row < yCuts.length - 1; row++) {
        for (let col = 0; col < xCuts.length - 1; col++) {
          const pieceX = xCuts[col];
          const pieceY = yCuts[row];
          const pieceWidth = xCuts[col + 1] - xCuts[col];
          const pieceHeight = yCuts[row + 1] - yCuts[row];

          const piece = document.createElement('div');
          piece.style.position = 'fixed';
          piece.style.width = pieceWidth + 'px';
          piece.style.height = pieceHeight + 'px';
          piece.style.left = (rect.left + pieceX) + 'px';
          piece.style.top = (rect.top + pieceY) + 'px';
          piece.style.backgroundImage = `url(${imageSrc})`;
          piece.style.backgroundPosition = `-${pieceX}px -${pieceY}px`;
          piece.style.backgroundSize = `${rect.width}px ${rect.height}px`;
          piece.style.backgroundRepeat = 'no-repeat';
          piece.style.transform = 'translate(0, 0)';
          piece.style.zIndex = '9000';

          document.body.appendChild(piece);

          // Add to particles array with Gaussian random velocity
          particles.push({
            el: piece,
            x: rect.left + pieceX,
            y: rect.top + pieceY,
            vx: gaussianRandom(0, 230),
            vy: gaussianRandom(-200, 230),
            width: pieceWidth,
            height: pieceHeight
          });
        }
      }

      // Hide original image
      imgElement.style.visibility = 'hidden';
    }
    */

    // Collect all .char elements (text)
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();
      createParticle(char, rect, true); // isText = true
    });

    // Shatter all images - COMMENTED OUT
    /*
    const images = document.querySelectorAll('img');
    images.forEach(img => {
      const rect = img.getBoundingClientRect();
      shatterImage(img, rect);
    });
    */

    // Collect all other shatterable elements
    const elements = document.querySelectorAll('img, button, .styled-box, h1, h2, h3, h4, h5, h6, blockquote, svg, i, nav span, nav div');
    elements.forEach(el => {
      // Skip if it's the overlay blocker
      if (el.id === 'shatter-overlay-blocker') return;

      // Skip empty elements or elements with no visible content
      const rect = el.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return;

      createParticle(el, rect);
    });

    // Collect line breaks and render them as small horizontal lines
    const lineBreaks = document.querySelectorAll('br');
    lineBreaks.forEach(br => {
      const rect = br.getBoundingClientRect();

      // Create a visible line element for the br
      const line = document.createElement('div');
      line.style.width = '20px';
      line.style.height = '2px';
      line.style.backgroundColor = '#999';
      line.style.position = 'fixed';
      line.style.left = rect.left + 'px';
      line.style.top = rect.top + 'px';
      line.classList.add('char-particle');

      // Add to body
      document.body.appendChild(line);

      // Hide original
      br.style.visibility = 'hidden';

      // Add to particles array with Gaussian random velocity
      particles.push({
        el: line,
        x: rect.left,
        y: rect.top,
        vx: gaussianRandom(0, 230),
        vy: gaussianRandom(-200, 230),
        width: 20,
        height: 2
      });
    });

    // Play shatter sound after text wrapping and particle collection
    const audio = document.getElementById('shatter-audio');
    if (audio) {
      audio.currentTime = 0;
      audio.play().catch(err => console.log('Audio play failed:', err));
    }

    // Start animation
    startShatterAnimation(particles);
  }

  function startShatterAnimation(particles) {
    let lastTime = performance.now();
    const gravity = 1000; // Doubled gravity for faster fall
    const damping = 0.6; // More energy loss on bounce

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Apply gravity
        particle.vy += gravity * dt;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // GRAVITY MODE
  // ============================================================================

  function enterGravityMode() {
    if (gravityActive) return;
    gravityActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "GRAVITY ON" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'GRAVITY ON';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00bfff';
    flashMessage.style.textShadow = '0 0 10px #00bfff, 0 0 20px #00bfff, 0 0 30px #00bfff, 0 0 40px #00bfff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00bfff';
    flashMessage.style.boxShadow = '0 0 20px #00bfff, inset 0 0 20px rgba(0, 191, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startGravityAnimation(particles);
  }

  function startGravityAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 150; // Falloff distance for exponential potential

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 5000;
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // VACUUM MODE
  // ============================================================================

  function enterVacuumMode() {
    if (vacuumActive) return;
    vacuumActive = true;

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "VACUUM MODE INITIATED" message
    const flashMessage = document.createElement('div');
    flashMessage.textContent = 'VACUUM MODE INITIATED';
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontSize = '64px';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#00ff00';
    flashMessage.style.textShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #00ff00';
    flashMessage.style.boxShadow = '0 0 20px #00ff00, inset 0 0 20px rgba(0, 255, 0, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';
    document.body.appendChild(flashMessage);

    // Show for 1 second, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000); // Remove after fade completes
    }, 1000);

    // Initialize mouse position to null - don't apply forces until we know where mouse is
    mouseX = null;
    mouseY = null;
    prevMouseX = null;
    prevMouseY = null;

    // Track mouse position
    document.addEventListener('mousemove', (e) => {
      prevMouseX = mouseX;
      prevMouseY = mouseY;
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    const particles = [];

    // Only collect text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Also collect glyphs and icons
    const glyphs = document.querySelectorAll('i, svg');
    glyphs.forEach(glyph => {
      const rect = glyph.getBoundingClientRect();

      // Skip if outside viewport or has no size
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth ||
          rect.width === 0 || rect.height === 0) {
        return;
      }

      // Clone the glyph
      const clone = glyph.cloneNode(true);
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(glyph);
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Preserve dimensions
      clone.style.width = rect.width + 'px';
      clone.style.height = rect.height + 'px';
      clone.style.boxSizing = 'border-box';

      // Position at exact location
      clone.style.position = 'fixed';
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      glyph.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height
      });
    });

    // Start animation
    startVacuumAnimation(particles);
  }

  function startVacuumAnimation(particles) {
    let lastTime = performance.now();
    const damping = 0.6; // Energy loss on bounce
    const lambda = 300; // Falloff distance for exponential potential
    const velocityDamping = 0.99; // Per-frame velocity damping

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000; // Convert to seconds
      lastTime = currentTime;

      // Cap dt to prevent huge jumps when tab becomes inactive
      dt = Math.min(dt, 0.033); // Max ~30fps worth of time

      // Only check for particle removal if we have a valid mouse position
      if (mouseX !== null && mouseY !== null && prevMouseX !== null && prevMouseY !== null) {
        // Filter out particles that should be removed
        for (let i = particles.length - 1; i >= 0; i--) {
          const particle = particles[i];

          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          // Also check distance to line segment traced by mouse movement
          const distToPath = distanceToLineSegment(centerX, centerY, prevMouseX, prevMouseY, mouseX, mouseY);

          // Effective capture radius is proportional to particle size
          const effectiveRadius = Math.min(particle.width, particle.height) / 2;

          // Remove particle if within effective radius of current mouse position or path
          if (dist < effectiveRadius || distToPath < effectiveRadius) {
            particle.el.remove();
            particles.splice(i, 1);
            playRandomPop(); // Play pop sound
            continue;
          }
        }
      }

      particles.forEach(particle => {
        // Only apply forces if we have a valid mouse position
        if (mouseX !== null && mouseY !== null) {
          // Calculate distance from particle center to mouse
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = mouseX - centerX;
          const dy = mouseY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ), 30x stronger than base
            // F = -∇V = -(1/λ)exp(-r/λ) * (direction towards mouse)
            const forceMagnitude = (1 / lambda) * Math.exp(-dist / lambda) * 150000; // 30x force
            const fx = (dx / dist) * forceMagnitude;
            const fy = (dy / dist) * forceMagnitude;

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Apply velocity damping
        particle.vx *= velocityDamping;
        particle.vy *= velocityDamping;

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Bounce off edges - check full bounding box
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left and right edges
        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Top and bottom edges
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        } else if (particle.y + particle.height > height + 7) {
          // Keep character visible - allow a bit past the bottom (7px lower)
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy * damping;
          particle.vx *= 0.97; // Apply friction
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Update previous mouse position for next frame
      prevMouseX = mouseX;
      prevMouseY = mouseY;

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // PONG MODE
  // ============================================================================

  function enterPongMode() {
    if (pongActive) return;
    pongActive = true;

    // Play ready set go sound immediately
    const readyAudio = new Audio('/audio/chiptune_ready_set_go.mp3');
    readyAudio.volume = 1.0;
    readyAudio.play().catch(err => console.log('Ready audio play failed:', err));

    // Wrap text on first activation
    ensureTextWrapped();

    // Record scroll position
    const scrollY = window.scrollY;

    // Lock body in place
    document.body.classList.add('shatter-locked');
    document.body.style.top = `-${scrollY}px`;

    // Create flashy "METEOR SHOWER INCOMING" message
    const flashMessage = document.createElement('div');
    flashMessage.style.position = 'fixed';
    flashMessage.style.top = '50%';
    flashMessage.style.left = '50%';
    flashMessage.style.transform = 'translate(-50%, -50%)';
    flashMessage.style.fontFamily = 'Courier New, monospace';
    flashMessage.style.fontWeight = 'bold';
    flashMessage.style.letterSpacing = '4px';
    flashMessage.style.color = '#ff00ff';
    flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
    flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMessage.style.padding = '30px 50px';
    flashMessage.style.border = '4px solid #ff00ff';
    flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
    flashMessage.style.zIndex = '100000';
    flashMessage.style.pointerEvents = 'none';
    flashMessage.style.textAlign = 'center';
    flashMessage.style.opacity = '1';
    flashMessage.style.transition = 'opacity 2s';

    const mainText = document.createElement('div');
    mainText.textContent = 'METEOR SHOWER INCOMING';
    mainText.style.fontSize = '64px';

    const subText = document.createElement('div');
    subText.textContent = '(GAME TO 10)';
    subText.style.fontSize = '32px';
    subText.style.marginTop = '10px';

    flashMessage.appendChild(mainText);
    flashMessage.appendChild(subText);
    document.body.appendChild(flashMessage);

    // Show for 2 seconds, then fade out over 2 seconds
    setTimeout(() => {
      flashMessage.style.opacity = '0';
      setTimeout(() => {
        flashMessage.remove();
      }, 2000);
    }, 2000);

    // Create score displays
    const leftScoreContainer = document.createElement('div');
    leftScoreContainer.style.position = 'fixed';
    leftScoreContainer.style.top = '50px';
    leftScoreContainer.style.left = '50px';
    leftScoreContainer.style.zIndex = '99999';
    leftScoreContainer.style.pointerEvents = 'none';
    leftScoreContainer.style.textAlign = 'center';

    const leftLabel = document.createElement('div');
    leftLabel.textContent = 'THEM';
    leftLabel.style.fontFamily = 'Courier New, monospace';
    leftLabel.style.fontSize = '24px';
    leftLabel.style.fontWeight = 'bold';
    leftLabel.style.color = '#ff0000';
    leftLabel.style.textShadow = '0 0 10px #ff0000';
    leftLabel.style.marginBottom = '10px';

    const leftScore = document.createElement('div');
    leftScore.textContent = '0';
    leftScore.style.fontFamily = 'Courier New, monospace';
    leftScore.style.fontSize = '72px';
    leftScore.style.fontWeight = 'bold';
    leftScore.style.color = '#ff0000';
    leftScore.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';

    leftScoreContainer.appendChild(leftLabel);
    leftScoreContainer.appendChild(leftScore);
    document.body.appendChild(leftScoreContainer);

    const rightScoreContainer = document.createElement('div');
    rightScoreContainer.style.position = 'fixed';
    rightScoreContainer.style.top = '50px';
    rightScoreContainer.style.right = '50px';
    rightScoreContainer.style.zIndex = '99999';
    rightScoreContainer.style.pointerEvents = 'none';
    rightScoreContainer.style.textAlign = 'center';

    const rightLabel = document.createElement('div');
    rightLabel.textContent = 'YOU';
    rightLabel.style.fontFamily = 'Courier New, monospace';
    rightLabel.style.fontSize = '24px';
    rightLabel.style.fontWeight = 'bold';
    rightLabel.style.color = '#00ff00';
    rightLabel.style.textShadow = '0 0 10px #00ff00';
    rightLabel.style.marginBottom = '10px';

    const rightScore = document.createElement('div');
    rightScore.textContent = '0';
    rightScore.style.fontFamily = 'Courier New, monospace';
    rightScore.style.fontSize = '72px';
    rightScore.style.fontWeight = 'bold';
    rightScore.style.color = '#00ff00';
    rightScore.style.textShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';

    rightScoreContainer.appendChild(rightLabel);
    rightScoreContainer.appendChild(rightScore);
    document.body.appendChild(rightScoreContainer);

    // Create player paddle (right side, green)
    const playerPaddle = document.createElement('div');
    playerPaddle.style.position = 'fixed';
    playerPaddle.style.right = '20px';
    playerPaddle.style.width = '15px';
    playerPaddle.style.height = '200px';
    playerPaddle.style.backgroundColor = '#00ff00';
    playerPaddle.style.boxShadow = '0 0 20px #00ff00, 0 0 40px #00ff00';
    playerPaddle.style.zIndex = '99999';
    playerPaddle.style.pointerEvents = 'none';
    document.body.appendChild(playerPaddle);

    // Create enemy paddle (left side, red, static)
    const enemyPaddle = document.createElement('div');
    enemyPaddle.style.position = 'fixed';
    enemyPaddle.style.left = '20px';
    enemyPaddle.style.width = '15px';
    enemyPaddle.style.height = '200px';
    enemyPaddle.style.backgroundColor = '#ff0000';
    enemyPaddle.style.boxShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';
    enemyPaddle.style.zIndex = '99999';
    enemyPaddle.style.pointerEvents = 'none';
    document.body.appendChild(enemyPaddle);

    // Paddle control state
    let playerPaddleY = window.innerHeight / 2 - 100; // Center paddle
    let enemyPaddleY = window.innerHeight / 2 - 100; // Center enemy paddle (static)
    let lastMouseMoveTime = 0;
    let mouseControlActive = false;
    const paddleSpeed = 800; // px/s for keyboard control

    // Update paddle positions
    playerPaddle.style.top = playerPaddleY + 'px';
    enemyPaddle.style.top = enemyPaddleY + 'px';

    // Mouse control
    document.addEventListener('mousemove', (e) => {
      mouseControlActive = true;
      lastMouseMoveTime = Date.now();
      playerPaddleY = Math.max(0, Math.min(window.innerHeight - 200, e.clientY - 100));
    });

    // Keyboard control
    const keys = {};
    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });
    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    let themScore = 0;
    let youScore = 0;

    const particles = [];

    // Collect all text characters
    const chars = document.querySelectorAll('.char');
    chars.forEach(char => {
      const rect = char.getBoundingClientRect();

      // Skip if outside viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight ||
          rect.right < 0 || rect.left > window.innerWidth) {
        return;
      }

      // Clone the character
      const clone = char.cloneNode(true);
      clone.classList.remove('char');
      clone.classList.add('char-particle');

      // Copy computed styles
      const computedStyle = window.getComputedStyle(char);
      clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
      clone.style.fontSize = computedStyle.fontSize;
      clone.style.fontWeight = computedStyle.fontWeight;
      clone.style.color = computedStyle.color;
      clone.style.zIndex = '10000';

      // Position at exact location
      clone.style.left = rect.left + 'px';
      clone.style.top = rect.top + 'px';
      clone.style.transform = 'translate(0, 0)';

      // Append to body
      document.body.appendChild(clone);

      // Hide original
      char.style.visibility = 'hidden';

      // Add to particles array with zero initial velocity
      particles.push({
        el: clone,
        x: rect.left,
        y: rect.top,
        vx: 0,
        vy: 0,
        width: rect.width,
        height: rect.height,
        active: false,
        trail: [] // Store last 15 positions for comet tail
      });
    });

    // Activate one random letter every 2 seconds, starting after 3.5 second delay
    let activationInterval;
    setTimeout(() => {
      activationInterval = setInterval(() => {
        // Find all inactive particles
        const inactiveParticles = particles.filter(p => !p.active);

        if (inactiveParticles.length === 0) {
          clearInterval(activationInterval);
          return;
        }

        // Pick a random inactive particle
        const randomParticle = inactiveParticles[Math.floor(Math.random() * inactiveParticles.length)];

        // Give it velocity with guaranteed horizontal movement
        const minVx = 200; // Minimum horizontal speed
        const vxSign = Math.random() < 0.5 ? -1 : 1;
        randomParticle.vx = vxSign * (minVx + Math.random() * 400); // 200-600 px/s
        randomParticle.vy = (Math.random() - 0.5) * 600;
        randomParticle.active = true;

        // Create whitish-orange burst at launch position
        const launchX = randomParticle.x + randomParticle.width / 2;
        const launchY = randomParticle.y + randomParticle.height / 2;
        createLaunchBurst(launchX, launchY);

        // Play letter release buzz - create new Audio instance each time
        const letterBuzz = new Audio('/audio/chiptune_buzz.wav');
        letterBuzz.volume = 0.35;
        letterBuzz.play().catch(err => console.log('Letter buzz play failed:', err));
      }, 2000);
    }, 3500);

    // Game state
    let blackHoleActive = false;
    let blackHoleEl = null;
    let gameOver = false;

    // Start animation
    startPongAnimation(particles, leftScore, rightScore, playerPaddle, enemyPaddle, () => playerPaddleY, (newY) => { playerPaddleY = newY; }, (newY) => { enemyPaddleY = newY; }, keys, () => mouseControlActive, () => blackHoleActive, (active) => { blackHoleActive = active; }, () => gameOver, (over) => { gameOver = over; });
  }

  function createBurst(x, y, color) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '80px';
    burst.style.height = '80px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = color;
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.8';
    burst.style.boxShadow = `0 0 40px ${color}, 0 0 80px ${color}`;
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.3s, transform 0.3s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.5)';
      setTimeout(() => {
        burst.remove();
      }, 300);
    }, 50);
  }

  function flashPaddle(paddleEl) {
    let flashCount = 0;
    const maxFlashes = 6; // 3 full on/off cycles
    const flashInterval = setInterval(() => {
      paddleEl.style.opacity = paddleEl.style.opacity === '0' ? '1' : '0';
      flashCount++;
      if (flashCount >= maxFlashes) {
        clearInterval(flashInterval);
        paddleEl.style.opacity = '1'; // Ensure it ends visible
      }
    }, 80); // Flash every 80ms
  }

  function createLaunchBurst(x, y) {
    const burst = document.createElement('div');
    burst.style.position = 'fixed';
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.width = '50px';
    burst.style.height = '50px';
    burst.style.borderRadius = '50%';
    burst.style.backgroundColor = '#ffcc88'; // Whitish-orange
    burst.style.transform = 'translate(-50%, -50%)';
    burst.style.opacity = '0.7';
    burst.style.boxShadow = '0 0 20px #ffcc88, 0 0 40px #ffcc88';
    burst.style.zIndex = '99998';
    burst.style.pointerEvents = 'none';
    burst.style.transition = 'opacity 0.25s, transform 0.25s';
    document.body.appendChild(burst);

    // Animate burst
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%, -50%) scale(1.3)';
      setTimeout(() => {
        burst.remove();
      }, 250);
    }, 50);
  }

  function startPongAnimation(particles, leftScoreEl, rightScoreEl, playerPaddleEl, enemyPaddleEl, getPlayerPaddleY, setPlayerPaddleY, setEnemyPaddleY, keys, getMouseActive, getBlackHoleActive, setBlackHoleActive, getGameOver, setGameOver) {
    let lastTime = performance.now();
    let themScore = 0;
    let youScore = 0;
    const paddleSpeed = 1152; // 20% faster than 960
    let enemyPaddleSpeed = 540; // Slower than player
    let enemyPaddleY = window.innerHeight / 2 - 100;
    let blackHoleEl = null;
    const paddleWidth = 15;
    const paddleHeight = 200;
    const leftPaddleX = 20;
    const rightPaddleX = window.innerWidth - 20 - paddleWidth;

    // Audio elements for paddle hits and game events
    const blip1Audio = new Audio('/audio/pong_blip_1.mp3'); // YOU paddle
    const blip2Audio = new Audio('/audio/pong_blip_2.mp3'); // THEM paddle
    const damage1Audio = new Audio('/audio/chiptune_damage_1.mp3'); // YOU damaged
    const damage2Audio = new Audio('/audio/chiptune_damage_2.mp3'); // THEM damaged
    const victoryAudio = new Audio('/audio/chiptune_victory.mp3'); // Victory
    const defeatAudio = new Audio('/audio/chiptune_defeat.mp3'); // Defeat

    // AI state
    const aiReactionDelay = 280; // ms
    const aiRandomOffset = 35; // px
    let lastAIUpdate = 0;
    let aiTargetY = enemyPaddleY;

    function animate(currentTime) {
      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      const width = window.innerWidth;
      const height = window.innerHeight;

      // Update player paddle position with keyboard if mouse hasn't moved recently
      if (Date.now() - performance.now() > 100 || !getMouseActive()) {
        let paddleY = getPlayerPaddleY();
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
          paddleY -= paddleSpeed * dt;
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
          paddleY += paddleSpeed * dt;
        }
        paddleY = Math.max(0, Math.min(height - paddleHeight, paddleY));
        setPlayerPaddleY(paddleY);
      }

      // Update enemy AI paddle
      if (currentTime - lastAIUpdate > aiReactionDelay) {
        lastAIUpdate = currentTime;

        // Find the nearest threatening letter (moving left towards enemy paddle)
        let closestThreat = null;
        let minTime = Infinity;

        particles.forEach(particle => {
          if (particle.vx < 0 && particle.active) { // Moving left
            const timeToReach = (particle.x - (leftPaddleX + paddleWidth)) / -particle.vx;
            if (timeToReach > 0 && timeToReach < minTime) {
              minTime = timeToReach;
              // Predict where it will be
              let predictedY = particle.y + particle.vy * timeToReach;

              // Account for bounces off top/bottom
              while (predictedY < 0 || predictedY + particle.height > height) {
                if (predictedY < 0) {
                  predictedY = -predictedY;
                } else if (predictedY + particle.height > height) {
                  predictedY = 2 * (height - particle.height) - predictedY;
                }
              }

              closestThreat = predictedY + particle.height / 2; // Center of letter
            }
          }
        });

        if (closestThreat !== null) {
          // Add random offset for imperfection
          aiTargetY = closestThreat - paddleHeight / 2 + (Math.random() - 0.5) * aiRandomOffset;
        } else {
          // No threats, drift toward center
          aiTargetY = height / 2 - paddleHeight / 2;
        }
      }

      // Move enemy paddle smoothly towards target
      if (enemyPaddleY < aiTargetY) {
        enemyPaddleY = Math.min(aiTargetY, enemyPaddleY + enemyPaddleSpeed * dt);
      } else if (enemyPaddleY > aiTargetY) {
        enemyPaddleY = Math.max(aiTargetY, enemyPaddleY - enemyPaddleSpeed * dt);
      }
      enemyPaddleY = Math.max(0, Math.min(height - paddleHeight, enemyPaddleY));
      setEnemyPaddleY(enemyPaddleY);

      // Update paddle element positions
      playerPaddleEl.style.top = getPlayerPaddleY() + 'px';
      enemyPaddleEl.style.top = enemyPaddleY + 'px';

      // Update particles and check for scoring
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];

        // Apply black hole gravity if particle is active and black hole is active
        if (particle.active && getBlackHoleActive()) {
          const blackHoleX = width / 2;
          const blackHoleY = height / 2;
          const blackHoleLambda = 250;
          const blackHoleForce = 750000; // 5x stronger than before

          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;
          const dx = blackHoleX - centerX;
          const dy = blackHoleY - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0) {
            // Force from potential V(r) = -exp(-r/λ)
            const forceMagnitude = (1 / blackHoleLambda) * Math.exp(-dist / blackHoleLambda) * blackHoleForce;
            let fx = (dx / dist) * forceMagnitude;
            let fy = (dy / dist) * forceMagnitude;

            // Non-conservative in x-coordinate: if moving away from black hole in x, reduce force to 75%
            if (particle.vx * dx < 0) { // Moving away in x (opposite signs)
              fx *= 0.75;
            }
            // Y-component remains conservative (no adjustment)

            // Apply force as acceleration
            particle.vx += fx * dt;
            particle.vy += fy * dt;
          }
        }

        // Update position
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;

        // Check for player paddle collision (right side)
        const playerPaddleY = getPlayerPaddleY();
        if (particle.vx > 0 && // Moving right
            particle.x + particle.width > rightPaddleX &&
            particle.x < rightPaddleX + paddleWidth &&
            particle.y + particle.height > playerPaddleY &&
            particle.y < playerPaddleY + paddleHeight) {

          // Play YOU paddle blip sound
          blip1Audio.currentTime = 0;
          blip1Audio.play().catch(err => console.log('Blip1 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - playerPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = rightPaddleX - particle.width;
        }

        // Check for enemy paddle collision (left side)
        if (particle.vx < 0 && // Moving left
            particle.x < leftPaddleX + paddleWidth &&
            particle.x + particle.width > leftPaddleX &&
            particle.y + particle.height > enemyPaddleY &&
            particle.y < enemyPaddleY + paddleHeight) {

          // Play THEM paddle blip sound
          blip2Audio.currentTime = 0;
          blip2Audio.play().catch(err => console.log('Blip2 play failed:', err));

          // Reflect and increase speed
          particle.vx = -particle.vx * 1.1;

          // Change y-velocity based on where it hit the paddle
          const hitPosition = (particle.y + particle.height / 2 - enemyPaddleY) / paddleHeight; // 0 to 1
          const angle = (hitPosition - 0.5) * 2; // -1 to 1
          particle.vy = angle * 400; // Max vy change of ±400

          // Move particle out of paddle to prevent multiple collisions
          particle.x = leftPaddleX + paddleWidth;
        }

        // Check for left edge (YOU score - enemy missed)
        if (particle.x + particle.width < 0) {
          // Create red burst at contact point (you scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(0, contactY, '#ff0000');

          // Play THEM damage sound
          damage2Audio.currentTime = 0;
          damage2Audio.play().catch(err => console.log('Damage2 play failed:', err));

          // Flash enemy paddle
          flashPaddle(enemyPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            youScore++;
            rightScoreEl.textContent = youScore.toString();

            // Check for YOU reaching 10
            if (youScore === 10 && !getBlackHoleActive()) {
              activateBlackHole();
            } else if (youScore === 20) {
              endGame(true); // YOU win
            }
          }
          continue;
        }

        // Check for right edge (THEM score - player missed)
        if (particle.x > width) {
          // Create green burst at contact point (they scored)
          const contactY = particle.y + particle.height / 2;
          createBurst(width, contactY, '#00ff00');

          // Play YOU damage sound
          damage1Audio.currentTime = 0;
          damage1Audio.play().catch(err => console.log('Damage1 play failed:', err));

          // Flash player paddle
          flashPaddle(playerPaddleEl);

          particle.el.remove();
          // Remove trail elements
          particle.trail.forEach(t => t.el.remove());
          particles.splice(i, 1);

          if (!getGameOver()) {
            themScore++;
            leftScoreEl.textContent = themScore.toString();

            // Check for THEM reaching 10
            if (themScore === 10 && !getBlackHoleActive()) {
              endGame(false); // YOU lose
            } else if (themScore === 20) {
              endGame(false); // YOU lose
            }
          }
          continue;
        }

        // Bounce off top and bottom
        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height) {
          particle.y = height - particle.height;
          particle.vy = -particle.vy;
        }

        // Update trail (store last 15 positions)
        if (particle.active) {
          particle.trail.push({ x: particle.x, y: particle.y });
          if (particle.trail.length > 15) {
            // Remove oldest trail element if it exists
            const oldest = particle.trail.shift();
            if (oldest.el) {
              oldest.el.remove();
            }
          }

          // Create/update trail elements
          particle.trail.forEach((trailPos, idx) => {
            if (!trailPos.el) {
              // Create new trail element
              const trailEl = particle.el.cloneNode(true);
              trailEl.style.pointerEvents = 'none';
              document.body.appendChild(trailEl);
              trailPos.el = trailEl;
            }

            // Update trail element position and style
            const age = particle.trail.length - idx - 1; // 0 = newest, 14 = oldest
            const opacity = 1 - (age + 1) / 16; // Fade from 0.94 to 0.06
            const scale = 1 - (age + 1) * 0.05; // Scale from 0.95 to 0.25

            trailPos.el.style.opacity = opacity.toString();
            trailPos.el.style.transform = `translate(${trailPos.x - parseFloat(particle.el.style.left)}px, ${trailPos.y - parseFloat(particle.el.style.top)}px) scale(${scale})`;
            trailPos.el.style.zIndex = (10000 - age - 1).toString(); // Behind main letter
          });
        }

        // Apply transform to main particle
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      }

      requestAnimationFrame(animate);
    }

    // Helper function to activate black hole
    function activateBlackHole() {
      setBlackHoleActive(true);

      // Increase AI speed
      enemyPaddleSpeed = 700;

      // Create black hole element
      const width = window.innerWidth;
      const height = window.innerHeight;
      blackHoleEl = document.createElement('div');
      blackHoleEl.style.position = 'fixed';
      blackHoleEl.style.left = (width / 2) + 'px';
      blackHoleEl.style.top = (height / 2) + 'px';
      blackHoleEl.style.width = '50px';
      blackHoleEl.style.height = '50px';
      blackHoleEl.style.marginLeft = '-25px';
      blackHoleEl.style.marginTop = '-25px';
      blackHoleEl.style.borderRadius = '50%';
      blackHoleEl.style.backgroundColor = '#000000';
      blackHoleEl.style.boxShadow = '0 0 30px 10px rgba(0, 0, 0, 0.8)';
      blackHoleEl.style.zIndex = '9999';
      blackHoleEl.style.pointerEvents = 'none';
      document.body.appendChild(blackHoleEl);

      // Animate the pulsing
      let pulseTime = 0;
      function pulseBlackHole() {
        if (!getBlackHoleActive() || !blackHoleEl) return;
        pulseTime += 0.05;
        const size = 40 + 10 * Math.sin(pulseTime);
        blackHoleEl.style.width = size + 'px';
        blackHoleEl.style.height = size + 'px';
        blackHoleEl.style.marginLeft = (-size / 2) + 'px';
        blackHoleEl.style.marginTop = (-size / 2) + 'px';
        requestAnimationFrame(pulseBlackHole);
      }
      pulseBlackHole();

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '20%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s ease-out';

      const mainText = document.createElement('div');
      mainText.textContent = 'BLACK HOLE ACTIVATED';
      mainText.style.fontSize = '64px';

      const subText = document.createElement('div');
      subText.textContent = '(GAME TO 20)';
      subText.style.fontSize = '32px';
      subText.style.marginTop = '10px';

      flashMessage.appendChild(mainText);
      flashMessage.appendChild(subText);
      document.body.appendChild(flashMessage);

      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => flashMessage.remove(), 2000);
      }, 4000);
    }

    // Helper function to end the game
    function endGame(playerWon) {
      setGameOver(true);

      // Play victory or defeat sound
      if (playerWon) {
        victoryAudio.currentTime = 0;
        victoryAudio.play().catch(err => console.log('Victory play failed:', err));
      } else {
        defeatAudio.currentTime = 0;
        defeatAudio.play().catch(err => console.log('Defeat play failed:', err));
      }

      // Display message
      const flashMessage = document.createElement('div');
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontSize = '96px';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff00ff';
      flashMessage.style.textShadow = '0 0 10px #ff00ff, 0 0 20px #ff00ff, 0 0 30px #ff00ff, 0 0 40px #ff00ff';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff00ff';
      flashMessage.style.boxShadow = '0 0 20px #ff00ff, inset 0 0 20px rgba(255, 0, 255, 0.2)';
      flashMessage.style.zIndex = '10001';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.whiteSpace = 'nowrap';
      flashMessage.textContent = playerWon ? 'VICTORY' : 'DEFEATED';
      document.body.appendChild(flashMessage);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // BIRD MODE
  // ============================================================================

  function enterBirdMode() {
    if (birdModeActive) return;
    birdModeActive = true;

    try {
      console.log('Starting bird mode...');

      // Create flashy "BIRD MODE ACTIVATED" message FIRST (before laggy operations)
      const flashMessage = document.createElement('div');
      flashMessage.textContent = 'BIRD MODE ACTIVATED';
      flashMessage.style.position = 'fixed';
      flashMessage.style.top = '50%';
      flashMessage.style.left = '50%';
      flashMessage.style.transform = 'translate(-50%, -50%)';
      flashMessage.style.fontSize = '64px';
      flashMessage.style.fontFamily = 'Courier New, monospace';
      flashMessage.style.fontWeight = 'bold';
      flashMessage.style.letterSpacing = '4px';
      flashMessage.style.color = '#ff6b9d';
      flashMessage.style.textShadow = '0 0 10px #ff6b9d, 0 0 20px #ff6b9d, 0 0 30px #ff6b9d, 0 0 40px #ff6b9d';
      flashMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      flashMessage.style.padding = '30px 50px';
      flashMessage.style.border = '4px solid #ff6b9d';
      flashMessage.style.boxShadow = '0 0 20px #ff6b9d, inset 0 0 20px rgba(255, 107, 157, 0.2)';
      flashMessage.style.zIndex = '100000';
      flashMessage.style.pointerEvents = 'none';
      flashMessage.style.textAlign = 'center';
      flashMessage.style.opacity = '1';
      flashMessage.style.transition = 'opacity 2s';
      document.body.appendChild(flashMessage);

      // Show for 1 second, then fade out over 2 seconds
      setTimeout(() => {
        flashMessage.style.opacity = '0';
        setTimeout(() => {
          flashMessage.remove();
        }, 2000);
      }, 1000);

      // Wait 50ms to ensure banner renders before starting laggy operations
      setTimeout(() => {
        // Wrap text
        ensureTextWrapped();

        // Lock body
        const scrollY = window.scrollY;
        document.body.classList.add('bird-locked');
        document.body.style.top = `-${scrollY}px`;

        // Track mouse position
        document.addEventListener('mousemove', (e) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
        });

        const particles = [];
        const MAX_BIRD_COUNT = 1000;

        // Find header characters to make them hawks (h1, or h2, or h3 if no h1)
        let headerElement = document.querySelector('h1');
        if (!headerElement) {
          headerElement = document.querySelector('h2');
        }
        if (!headerElement) {
          headerElement = document.querySelector('h3');
        }
        let h1Chars = [];
        if (headerElement) {
          h1Chars = Array.from(headerElement.querySelectorAll('.char'));
        }

        // Collect all character and glyph elements with their data
        // Separate hawks (always keep) from non-hawks (randomly select)
        const hawkElements = [];
        const nonHawkElements = [];

        // Collect all characters
        const chars = document.querySelectorAll('.char');
        chars.forEach(char => {
          const rect = char.getBoundingClientRect();

          // Skip if outside viewport
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth) {
            return;
          }

          const hawkIndex = h1Chars.indexOf(char);
          const isHawk = hawkIndex !== -1;

          const elem = {
            original: char,
            rect: rect,
            isChar: true,
            isHawk: isHawk,
            hawkIndex: hawkIndex,
            randomOrder: Math.random()  // For shuffling
          };

          if (isHawk) {
            hawkElements.push(elem);
          } else {
            nonHawkElements.push(elem);
          }
        });

        // Also collect glyphs and icons (all non-hawks)
        const glyphs = document.querySelectorAll('i, svg');
        glyphs.forEach(glyph => {
          const rect = glyph.getBoundingClientRect();

          // Skip if outside viewport or has no size
          if (rect.bottom < 0 || rect.top > window.innerHeight ||
              rect.right < 0 || rect.left > window.innerWidth ||
              rect.width === 0 || rect.height === 0) {
            return;
          }

          nonHawkElements.push({
            original: glyph,
            rect: rect,
            isChar: false,
            isHawk: false,
            hawkIndex: -1,
            randomOrder: Math.random()  // For shuffling
          });
        });

        // Randomly shuffle non-hawks
        nonHawkElements.sort((a, b) => a.randomOrder - b.randomOrder);

        // Select non-hawks up to MAX_BIRD_COUNT - number of hawks
        const maxNonHawks = MAX_BIRD_COUNT - hawkElements.length;
        const selectedNonHawks = nonHawkElements.slice(0, maxNonHawks);
        const fadedNonHawks = nonHawkElements.slice(maxNonHawks);

        // Combine: all hawks + selected non-hawks become birds
        const birdElements = [...hawkElements, ...selectedNonHawks];

        // Process bird elements (become birds)
        birdElements.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Add to particles array (all bird elements become birds)
          particles.push({
            el: clone,
            x: rect.left,
            y: rect.top,
            vx: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,  // Hawks get tiny random velocity
            vy: elem.isHawk ? (Math.random() - 0.5) * 2 : 0,
            width: rect.width,
            height: rect.height,
            isHawk: elem.isHawk,
            hawkIndex: elem.hawkIndex,  // -1 for non-hawks, 0+ for hawks
            isActive: !elem.isHawk,  // Hawks start dormant, boids start active
            originalX: rect.left,  // Store original position for dormant hawks
            originalY: rect.top
          });
        });

        // Process faded elements (fade out smoothly)
        fadedNonHawks.forEach((elem) => {
          const rect = elem.rect;
          const original = elem.original;

          // Clone the element
          const clone = original.cloneNode(true);
          if (elem.isChar) {
            clone.classList.remove('char');
          }
          clone.classList.add('char-particle');

          // Copy computed styles
          const computedStyle = window.getComputedStyle(original);
          if (elem.isChar) {
            clone.style.fontFamily = computedStyle.fontFamily + ', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji"';
          }
          clone.style.fontSize = computedStyle.fontSize;
          clone.style.fontWeight = computedStyle.fontWeight;
          clone.style.color = computedStyle.color;
          clone.style.zIndex = '10000';

          if (!elem.isChar) {
            // Preserve dimensions for glyphs
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.boxSizing = 'border-box';
            clone.style.position = 'fixed';
          }

          // Position at exact location
          clone.style.left = rect.left + 'px';
          clone.style.top = rect.top + 'px';
          clone.style.transform = 'translate(0, 0)';

          // Append to body
          document.body.appendChild(clone);

          // Hide original
          original.style.visibility = 'hidden';

          // Fade out this element smoothly
          clone.style.transition = 'opacity 3s ease-out';
          setTimeout(() => {
            clone.style.opacity = '0';
            setTimeout(() => {
              clone.remove();
            }, 3000);
          }, 10);
        });

        // Start animation
        // Create trajectory ray for hawk
        const trajectoryRay = document.createElement('div');
        trajectoryRay.id = 'hawk-trajectory-ray';
        trajectoryRay.style.position = 'fixed';
        trajectoryRay.style.height = '2px';
        trajectoryRay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
        trajectoryRay.style.transformOrigin = '0 0';
        trajectoryRay.style.pointerEvents = 'none';
        trajectoryRay.style.zIndex = '9998';
        trajectoryRay.style.display = 'none';
        document.body.appendChild(trajectoryRay);

        // Create perpendicular lines container (SVG for efficient line drawing)
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'fear-lines-svg';
        svg.style.position = 'fixed';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '9997';
        document.body.appendChild(svg);

        console.log('Starting animation with', particles.length, 'particles');
        startBirdAnimation(particles, trajectoryRay, svg);
      }, 50);  // End of 50ms setTimeout
    } catch (error) {
      console.error('Error in enterBirdMode:', error);
      birdModeActive = false;
      alert('Error starting bird mode: ' + error.message);
    }
  }

  function startBirdAnimation(particles, trajectoryRay, fearLinesSvg) {
    let lastTime = performance.now();
    let hawkInfos = [];  // Store all active hawks' positions and velocities for fear calculations

    const FORCE_MULTIPLIER = 25;  // Global force multiplication factor
    const MAX_SPEED = 400;   // Maximum speed
    const F_MAX = 10;  // Maximum force magnitude before clamping

    // Repulsion parameters
    const LENGTH_SCALE = 20;  // px
    const R_REPULSION = 1 * LENGTH_SCALE;  // 20px
    const F_REPULSION = 5;  // Repulsion strength

    // Speed stabilization parameters
    const TARGET_SPEED = 15;  // px/s
    const TARGET_SPEED_HAWK = 50;  // px/s
    const F_SPEEDSTABILITY = 5;
    const F_SPEEDSTABILITY_HAWK = 2;

    // Alignment parameters
    const F_ALIGN = 2;

    // Wall repulsion parameters
    const WALL_REPULSION_DIST = 5 * LENGTH_SCALE;  // 100px
    const F_WALL_REPULSION = 4;

    // Hawk-specific wall repulsion (2x distance and magnitude)
    const WALL_REPULSION_DIST_HAWK = 1 * WALL_REPULSION_DIST;  // 200px
    const F_WALL_REPULSION_HAWK = .5 * F_WALL_REPULSION;  // 8

    // Hawk attraction parameters
    const F_ATTR_HAWK = 0.3;

    // Fear parameters
    const F_FEAR = 3;
    const FEAR_DIST = 15 * LENGTH_SCALE;  // 300px

    // Spatial grid parameters
    const CELL_SIZE = 2 * LENGTH_SCALE;  // 60px

    // Hawk release tracking
    let nextHawkIndex = 0;
    let nextHawkReleaseTime = 20.0;  // First hawk at 20 seconds (wall time)
    let elapsedTime = 0;  // Wall time in seconds

    function releaseHawk(hawk) {
      hawk.isActive = true;
      hawk.releaseTime = elapsedTime;  // Track when hawk was released

      // Play hawk call at 30% volume
      const hawkAudio = document.getElementById('hawk-call');
      if (hawkAudio) {
        hawkAudio.volume = 0.3;
        hawkAudio.currentTime = 0;
        hawkAudio.play().catch(e => console.log('Audio play failed:', e));
      }

      // Create big brown burst
      const burstX = hawk.x + hawk.width / 2;
      const burstY = hawk.y + hawk.height / 2;
      const burst = document.createElement('div');

      burst.style.position = 'fixed';
      burst.style.left = burstX + 'px';
      burst.style.top = burstY + 'px';
      burst.style.width = '0px';
      burst.style.height = '0px';
      burst.style.borderRadius = '50%';
      burst.style.backgroundColor = 'rgba(139, 69, 19, 0.6)';  // Brown color
      burst.style.transform = 'translate(-50%, -50%)';
      burst.style.pointerEvents = 'none';
      burst.style.zIndex = '9999';
      document.body.appendChild(burst);

      // Animate burst (much bigger)
      setTimeout(() => {
        burst.style.transition = 'all 0.6s ease-out';
        burst.style.width = '200px';
        burst.style.height = '200px';
        burst.style.backgroundColor = 'rgba(139, 69, 19, 0)';
      }, 10);

      setTimeout(() => burst.remove(), 650);
    }

    function animate(currentTime) {
      if (!birdModeActive) return;

      let dt = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      dt = Math.min(dt, 0.033);

      // Update elapsed time (wall time in real seconds)
      elapsedTime += dt;

      // Simulation runs at 4x speed
      const simulationDt = dt * 4;

      // Clear hawk infos from previous frame
      hawkInfos = [];

      // Check if it's time to release the next hawk
      if (elapsedTime >= nextHawkReleaseTime) {
        // Find the hawk with hawkIndex === nextHawkIndex
        const hawkToRelease = particles.find(p => p.hawkIndex === nextHawkIndex);
        if (hawkToRelease && !hawkToRelease.isActive) {
          releaseHawk(hawkToRelease);
          nextHawkIndex++;
          // First hawk at 20s, then every 60s thereafter
          nextHawkReleaseTime += 60.0;
        }
      }

      // Build spatial grid (only for active, non-hawk particles)
      const grid = new Map();
      particles.forEach((particle, i) => {
        if (!particle.isActive || particle.isHawk) return;

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);
        const key = `${cellX},${cellY}`;

        if (!grid.has(key)) {
          grid.set(key, []);
        }
        grid.get(key).push(i);
      });

      // Check for hawk overlaps and hide captured particles
      particles.forEach((hawk, i) => {
        if (!hawk.isHawk || !hawk.isActive) return;

        // Hawks can't capture during their 2-second frozen period
        const timeSinceRelease = elapsedTime - (hawk.releaseTime || 0);
        if (timeSinceRelease < 2.0) return;

        particles.forEach((boid, j) => {
          if (i === j || !boid.isActive || boid.isHawk) return;

          // Check bounding box overlap
          if (hawk.x < boid.x + boid.width &&
              hawk.x + hawk.width > boid.x &&
              hawk.y < boid.y + boid.height &&
              hawk.y + hawk.height > boid.y) {
            // Overlap! Hide boid and create burst
            boid.isActive = false;
            boid.el.remove();

            // Play goose sound (75% honk, 25% yell)
            const soundId = Math.random() < 0.75 ? 'goose-honk' : 'goose-yell';
            const audio = document.getElementById(soundId);
            if (audio) {
              audio.currentTime = 0;
              audio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Create colorful burst
            const burstX = boid.x + boid.width / 2;
            const burstY = boid.y + boid.height / 2;
            const burst = document.createElement('div');

            // Random hue, high saturation, high lightness
            const hue = Math.floor(Math.random() * 360);
            const saturation = 70 + Math.floor(Math.random() * 20); // 70-90%
            const lightness = 60; // Medium-bright

            burst.style.position = 'fixed';
            burst.style.left = burstX + 'px';
            burst.style.top = burstY + 'px';
            burst.style.width = '0px';
            burst.style.height = '0px';
            burst.style.borderRadius = '50%';
            burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.6)`;
            burst.style.transform = 'translate(-50%, -50%)';
            burst.style.pointerEvents = 'none';
            burst.style.zIndex = '9999';
            document.body.appendChild(burst);

            // Animate burst
            setTimeout(() => {
              burst.style.transition = 'all 0.4s ease-out';
              burst.style.width = '60px';
              burst.style.height = '60px';
              burst.style.backgroundColor = `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`;
            }, 10);

            setTimeout(() => burst.remove(), 450);
          }
        });
      });

      // Apply forces to each particle
      particles.forEach((particle, i) => {
        if (!particle.isActive) return;  // Skip inactive particles

        // Hawks have their own forces
        if (particle.isHawk) {
          const centerX = particle.x + particle.width / 2;
          const centerY = particle.y + particle.height / 2;

          // Keep hawk stationary for 2 seconds after release (for suspense)
          const timeSinceRelease = elapsedTime - (particle.releaseTime || 0);
          if (timeSinceRelease < 2.0) {
            // Hawk is frozen - keep it in place
            particle.vx = 0;
            particle.vy = 0;
            particle.x = particle.originalX;
            particle.y = particle.originalY;
            particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

            // Still store hawk info for fear calculations
            hawkInfos.push({
              x: centerX,
              y: centerY,
              vx: 0,
              vy: 0,
              speed: 0
            });
            return;  // Skip rest of hawk physics
          }

          let hawkForceX = 0;
          let hawkForceY = 0;

          // Speed stabilization force (weaker than boids, higher target speed)
          const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
          if (currentSpeed > 0) {
            const speedRatio = 1 - currentSpeed / TARGET_SPEED_HAWK;
            const speedForceMag = F_SPEEDSTABILITY_HAWK * Math.pow(speedRatio, 3);
            hawkForceX += (particle.vx / currentSpeed) * speedForceMag;
            hawkForceY += (particle.vy / currentSpeed) * speedForceMag;
          }

          // Attraction to nearest boid
          let nearestBoid = null;
          let nearestDist = Infinity;
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist) {
              nearestDist = dist;
              nearestBoid = { x: otherCenterX, y: otherCenterY, dist: dist };
            }
          });

          if (nearestBoid && nearestBoid.dist > 0) {
            const dx = nearestBoid.x - centerX;
            const dy = nearestBoid.y - centerY;
            hawkForceX += (dx / nearestBoid.dist) * F_ATTR_HAWK;
            hawkForceY += (dy / nearestBoid.dist) * F_ATTR_HAWK;
          }

          // Repulsion from nearest k hawks
          const K_HAWKS = 3;
          const HAWK_REPULSION_DIST = 50;  // px
          const F_HAWK_REPULSION = 0.5;  // Mild repulsion strength

          // Find all other active hawks
          const otherHawks = [];
          particles.forEach((other, j) => {
            if (i === j || !other.isActive || !other.isHawk) return;
            const otherCenterX = other.x + other.width / 2;
            const otherCenterY = other.y + other.height / 2;
            const dx = otherCenterX - centerX;
            const dy = otherCenterY - centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < HAWK_REPULSION_DIST) {
              otherHawks.push({ x: otherCenterX, y: otherCenterY, dist: dist });
            }
          });

          if (otherHawks.length > 0) {
            // Sort by distance and take k nearest
            otherHawks.sort((a, b) => a.dist - b.dist);
            const nearestKHawks = otherHawks.slice(0, K_HAWKS);

            // Calculate average position
            let avgHawkX = 0, avgHawkY = 0;
            nearestKHawks.forEach(h => {
              avgHawkX += h.x;
              avgHawkY += h.y;
            });
            avgHawkX /= nearestKHawks.length;
            avgHawkY /= nearestKHawks.length;

            // Calculate average distance
            let avgDist = 0;
            nearestKHawks.forEach(h => avgDist += h.dist);
            avgDist /= nearestKHawks.length;

            // Apply repulsive force (drops off linearly)
            if (avgDist > 0) {
              const repulsionStrength = F_HAWK_REPULSION * (1 - avgDist / HAWK_REPULSION_DIST);
              const dx = centerX - avgHawkX;
              const dy = centerY - avgHawkY;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                hawkForceX += (dx / dist) * repulsionStrength;
                hawkForceY += (dy / dist) * repulsionStrength;
              }
            }
          }

          // Wall repulsion forces (stronger and longer range for hawks)
          const width = window.innerWidth;
          const height = window.innerHeight;

          // Left wall
          const distLeft = centerX;
          if (distLeft < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distLeft / WALL_REPULSION_DIST_HAWK);
            hawkForceX += wallForceMag;  // Push right
          }

          // Right wall
          const distRight = width - centerX;
          if (distRight < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distRight / WALL_REPULSION_DIST_HAWK);
            hawkForceX -= wallForceMag;  // Push left
          }

          // Top wall
          const distTop = centerY;
          if (distTop < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distTop / WALL_REPULSION_DIST_HAWK);
            hawkForceY += wallForceMag;  // Push down
          }

          // Bottom wall
          const distBottom = height - centerY;
          if (distBottom < WALL_REPULSION_DIST_HAWK) {
            const wallForceMag = F_WALL_REPULSION_HAWK * (1 - distBottom / WALL_REPULSION_DIST_HAWK);
            hawkForceY -= wallForceMag;  // Push up
          }

          // Clamp force to F_MAX
          const hawkForceMag = Math.sqrt(hawkForceX * hawkForceX + hawkForceY * hawkForceY);
          if (hawkForceMag > F_MAX) {
            hawkForceX = (hawkForceX / hawkForceMag) * F_MAX;
            hawkForceY = (hawkForceY / hawkForceMag) * F_MAX;
          }

          // Apply forces
          particle.vx += hawkForceX * FORCE_MULTIPLIER * simulationDt;
          particle.vy += hawkForceY * FORCE_MULTIPLIER * simulationDt;

          // Update position
          particle.x += particle.vx * simulationDt;
          particle.y += particle.vy * simulationDt;

          // Bounce off walls (width and height already declared above)
          if (particle.x < 0) {
            particle.x = 0;
            particle.vx = -particle.vx;
          } else if (particle.x + particle.width > width) {
            particle.x = width - particle.width;
            particle.vx = -particle.vx;
          }

          if (particle.y < 0) {
            particle.y = 0;
            particle.vy = -particle.vy;
          } else if (particle.y + particle.height > height) {
            particle.y = height - particle.height;
            particle.vy = -particle.vy;
          }

          // Update visual position
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;

          // Store hawk info for fear calculations
          hawkInfos.push({
            x: centerX,
            y: centerY,
            vx: particle.vx,
            vy: particle.vy,
            speed: currentSpeed
          });

          return;  // Skip boid forces
        }

        const centerX = particle.x + particle.width / 2;
        const centerY = particle.y + particle.height / 2;

        // Accumulate total force
        let totalForceX = 0;
        let totalForceY = 0;

        // Fear force from all hawks
        let isFearful = false;
        hawkInfos.forEach(hawkInfo => {
          if (hawkInfo.speed > 0) {
            const toHawkX = hawkInfo.x - centerX;
            const toHawkY = hawkInfo.y - centerY;
            const distToHawk = Math.sqrt(toHawkX * toHawkX + toHawkY * toHawkY);

            // Check if boid is in front of hawk (dot product > 0)
            const toBoidX = centerX - hawkInfo.x;
            const toBoidY = centerY - hawkInfo.y;
            const dotProduct = toBoidX * hawkInfo.vx + toBoidY * hawkInfo.vy;

            if (distToHawk < FEAR_DIST && dotProduct > 0) {
              // Boid feels fear!
              isFearful = true;

              // Calculate perpendicular direction away from ray
              const dirX = hawkInfo.vx / hawkInfo.speed;
              const dirY = hawkInfo.vy / hawkInfo.speed;

              // Project boid position onto ray
              const projection = toBoidX * dirX + toBoidY * dirY;
              const rayPointX = hawkInfo.x + projection * dirX;
              const rayPointY = hawkInfo.y + projection * dirY;

              // Direction from ray to boid (perpendicular escape direction)
              const perpX = centerX - rayPointX;
              const perpY = centerY - rayPointY;
              const perpDist = Math.sqrt(perpX * perpX + perpY * perpY);

              if (perpDist > 0) {
                const fearMagnitude = F_FEAR * (1 - distToHawk / FEAR_DIST);

                // Blend perpendicular direction with "away from hawk" for 70 degree angle
                const perpNormX = perpX / perpDist;
                const perpNormY = perpY / perpDist;
                const awayNormX = -dirX;  // Opposite of hawk direction
                const awayNormY = -dirY;

                // sin(70°) ≈ 0.94, cos(70°) ≈ 0.34
                const fearDirX = 0.94 * perpNormX + 0.34 * awayNormX;
                const fearDirY = 0.94 * perpNormY + 0.34 * awayNormY;

                // Normalize the blended direction
                const fearDirMag = Math.sqrt(fearDirX * fearDirX + fearDirY * fearDirY);
                if (fearDirMag > 0) {
                  totalForceX += (fearDirX / fearDirMag) * fearMagnitude;
                  totalForceY += (fearDirY / fearDirMag) * fearMagnitude;
                }
              }
            }
          }
        });

        // Get particle's grid cell
        const cellX = Math.floor(centerX / CELL_SIZE);
        const cellY = Math.floor(centerY / CELL_SIZE);

        // Find distances to particles in nearby cells (3x3 neighborhood)
        const distances = [];
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            const key = `${cellX + dx},${cellY + dy}`;
            const cellParticles = grid.get(key);
            if (!cellParticles) continue;

            cellParticles.forEach(j => {
              if (i === j) return;

              const other = particles[j];
              const otherCenterX = other.x + other.width / 2;
              const otherCenterY = other.y + other.height / 2;
              const deltaX = otherCenterX - centerX;
              const deltaY = otherCenterY - centerY;
              const dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

              distances.push({
                index: j,
                dist: dist,
                dx: deltaX,
                dy: deltaY,
                x: otherCenterX,
                y: otherCenterY
              });

              // Repulsion force (only for close neighbors) - 1/r form with offset
              if (dist <= R_REPULSION && dist > 0) {
                const normalizedDist = dist / LENGTH_SCALE;
                const repulsionMag = F_REPULSION * (1 - normalizedDist);
                totalForceX -= (deltaX / dist) * repulsionMag;  // Negative = repulsion
                totalForceY -= (deltaY / dist) * repulsionMag;
              }
            });
          }
        }

        // Sort by distance and take 5 nearest
        distances.sort((a, b) => a.dist - b.dist);
        const nearest5 = distances.slice(0, 5);

        // Calculate average position of 5 nearest neighbors
        let avgX = 0, avgY = 0;
        nearest5.forEach(n => {
          avgX += n.x;
          avgY += n.y;
        });
        avgX /= nearest5.length;
        avgY /= nearest5.length;

        // Cohesion force: magnitude 1 towards average position
        const dx = avgX - centerX;
        const dy = avgY - centerY;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          totalForceX += (dx / dist) * 1.0;
          totalForceY += (dy / dist) * 1.0;
        }

        // Alignment force: magnitude F_ALIGN in direction of average velocity
        let avgVx = 0, avgVy = 0;
        nearest5.forEach(n => {
          const neighbor = particles[n.index];
          avgVx += neighbor.vx;
          avgVy += neighbor.vy;
        });
        avgVx /= nearest5.length;
        avgVy /= nearest5.length;

        const avgVelMag = Math.sqrt(avgVx * avgVx + avgVy * avgVy);
        if (avgVelMag > 0) {
          totalForceX += (avgVx / avgVelMag) * F_ALIGN;
          totalForceY += (avgVy / avgVelMag) * F_ALIGN;
        }

        // Speed stabilization force
        const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (currentSpeed > 0) {
          const speedRatio = 1 - currentSpeed / TARGET_SPEED;
          const speedForceMag = F_SPEEDSTABILITY * Math.pow(speedRatio, 3);
          totalForceX += (particle.vx / currentSpeed) * speedForceMag;
          totalForceY += (particle.vy / currentSpeed) * speedForceMag;
        }

        // Wall repulsion forces
        const width = window.innerWidth;
        const height = window.innerHeight;

        // Left wall
        const distLeft = centerX;
        if (distLeft < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distLeft / WALL_REPULSION_DIST);
          totalForceX += wallForceMag;  // Push right
        }

        // Right wall
        const distRight = width - centerX;
        if (distRight < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distRight / WALL_REPULSION_DIST);
          totalForceX -= wallForceMag;  // Push left
        }

        // Top wall
        const distTop = centerY;
        if (distTop < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distTop / WALL_REPULSION_DIST);
          totalForceY += wallForceMag;  // Push down
        }

        // Bottom wall
        const distBottom = height - centerY;
        if (distBottom < WALL_REPULSION_DIST) {
          const wallForceMag = F_WALL_REPULSION * (1 - distBottom / WALL_REPULSION_DIST);
          totalForceY -= wallForceMag;  // Push up
        }

        // Clamp force to F_MAX
        const totalForceMag = Math.sqrt(totalForceX * totalForceX + totalForceY * totalForceY);
        if (totalForceMag > F_MAX) {
          totalForceX = (totalForceX / totalForceMag) * F_MAX;
          totalForceY = (totalForceY / totalForceMag) * F_MAX;
        }

        // Apply total force with global multiplier
        particle.vx += totalForceX * FORCE_MULTIPLIER * simulationDt;
        particle.vy += totalForceY * FORCE_MULTIPLIER * simulationDt;

        // Limit speed
        const speed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
        if (speed > MAX_SPEED) {
          particle.vx = (particle.vx / speed) * MAX_SPEED;
          particle.vy = (particle.vy / speed) * MAX_SPEED;
        }

        // Update position
        particle.x += particle.vx * simulationDt;
        particle.y += particle.vy * simulationDt;

        // Bounce off edges with perfect reflection (no energy loss)
        // (width and height already declared above for wall repulsion)

        if (particle.x < 0) {
          particle.x = 0;
          particle.vx = -particle.vx;
        } else if (particle.x + particle.width > width) {
          particle.x = width - particle.width;
          particle.vx = -particle.vx;
        }

        if (particle.y < 0) {
          particle.y = 0;
          particle.vy = -particle.vy;
        } else if (particle.y + particle.height > height + 7) {
          particle.y = height - particle.height + 7;
          particle.vy = -particle.vy;
        }

        // Apply transform
        particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
      });

      // Keep dormant hawks at their original position
      particles.forEach(particle => {
        if (particle.isHawk && !particle.isActive) {
          particle.x = particle.originalX;
          particle.y = particle.originalY;
          particle.el.style.transform = `translate(${particle.x - parseFloat(particle.el.style.left)}px, ${particle.y - parseFloat(particle.el.style.top)}px)`;
        }
      });

      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  }

  // ============================================================================
  // INITIALIZATION
  // ============================================================================

  // Track if text has been wrapped
  let textWrapped = false;

  // Wrap text lazily when first mode is activated
  function ensureTextWrapped() {
    if (textWrapped) return;
    textWrapped = true;
    wrapTextNodes(document.body);
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    // Add mysterious glyphs to navbar
    const navList = document.querySelector('nav ul.navbar-nav');
    if (navList) {
      // Single question mark icon that randomly picks a mode
      const mysteryLi = document.createElement('li');
      mysteryLi.className = 'nav-item active';

      const mysteryLink = document.createElement('a');
      mysteryLink.className = 'nav-link';
      mysteryLink.style.cursor = 'pointer';
      mysteryLink.href = '#';

      const mysteryIcon = document.createElement('i');
      mysteryIcon.className = 'fas fa-question-circle';

      mysteryLink.appendChild(mysteryIcon);
      mysteryLi.appendChild(mysteryLink);

      mysteryLink.addEventListener('click', (e) => {
        e.preventDefault();

        // Check localStorage for click count
        let clickCount = parseInt(localStorage.getItem('mysteryButtonClicks') || '0');

        // If user hasn't clicked 3 times yet, show warning and increment
        if (clickCount < 3) {
          const messages = ["Hey, stop that!", "Can't you read?", "I'm serious!"];
          alert(messages[clickCount]);
          clickCount++;
          localStorage.setItem('mysteryButtonClicks', clickCount.toString());
          return; // Don't activate mode
        }

        // After 3 clicks, relent and randomly choose a mode
        // Shatter, Gravity, and Splash are half as likely as the other modes
        const randomChoice = Math.floor(Math.random() * 9);

        switch(randomChoice) {
          case 0:
            enterShatterMode();
            break;
          case 1:
            enterGravityMode();
            break;
          case 2:
          case 3:
            enterVacuumMode();
            break;
          case 4:
          case 5:
            enterPongMode();
            break;
          case 6:
          case 7:
            // BIRD MODE
            enterBirdMode();
            break;
          case 8:
            window.location.href = '/splash/';
            break;
        }
      });

      navList.appendChild(mysteryLi);

      /* DEBUG VERSION: Uncomment to show all five icons for debugging
      // Shatter mode icon (question mark)
      const shatterLi = document.createElement('li');
      shatterLi.className = 'nav-item active';

      const shatterLink = document.createElement('a');
      shatterLink.className = 'nav-link';
      shatterLink.style.cursor = 'pointer';
      shatterLink.href = '#';

      const shatterIcon = document.createElement('i');
      shatterIcon.className = 'fas fa-question-circle';

      shatterLink.appendChild(shatterIcon);
      shatterLi.appendChild(shatterLink);

      shatterLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterShatterMode();
      });

      navList.appendChild(shatterLi);

      // Gravity mode icon (magnet)
      const gravityLi = document.createElement('li');
      gravityLi.className = 'nav-item active';

      const gravityLink = document.createElement('a');
      gravityLink.className = 'nav-link';
      gravityLink.style.cursor = 'pointer';
      gravityLink.href = '#';

      const gravityIcon = document.createElement('i');
      gravityIcon.className = 'fas fa-magnet';

      gravityLink.appendChild(gravityIcon);
      gravityLi.appendChild(gravityLink);

      gravityLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterGravityMode();
      });

      navList.appendChild(gravityLi);

      // Vacuum mode icon (meteor)
      const vacuumLi = document.createElement('li');
      vacuumLi.className = 'nav-item active';

      const vacuumLink = document.createElement('a');
      vacuumLink.className = 'nav-link';
      vacuumLink.style.cursor = 'pointer';
      vacuumLink.href = '#';

      const vacuumIcon = document.createElement('i');
      vacuumIcon.className = 'fas fa-meteor';

      vacuumLink.appendChild(vacuumIcon);
      vacuumLi.appendChild(vacuumLink);

      vacuumLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterVacuumMode();
      });

      navList.appendChild(vacuumLi);

      // Splash page link icon (home)
      const splashLi = document.createElement('li');
      splashLi.className = 'nav-item active';

      const splashLink = document.createElement('a');
      splashLink.className = 'nav-link';
      splashLink.style.cursor = 'pointer';
      splashLink.href = '/splash/';

      const splashIcon = document.createElement('i');
      splashIcon.className = 'fas fa-home';

      splashLink.appendChild(splashIcon);
      splashLi.appendChild(splashLink);

      navList.appendChild(splashLi);

      // Pong mode icon (gamepad)
      const pongLi = document.createElement('li');
      pongLi.className = 'nav-item active';

      const pongLink = document.createElement('a');
      pongLink.className = 'nav-link';
      pongLink.style.cursor = 'pointer';
      pongLink.href = '#';

      const pongIcon = document.createElement('i');
      pongIcon.className = 'fas fa-gamepad';

      pongLink.appendChild(pongIcon);
      pongLi.appendChild(pongLink);

      pongLink.addEventListener('click', (e) => {
        e.preventDefault();
        enterPongMode();
      });

      navList.appendChild(pongLi);
      */
    }
  });
</script>


    <div class="page-content" style="flex: 1 0 auto;">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <div class="container">
    <br>

    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">On the scientific method and its application to the science of deep learning</h1>
      <p class="post-meta"><time datetime="2025-07-20T02:00:00-07:00" itemprop="datePublished">Jul 20, 2025</time></p>
    </header>

    <div class="post-content" itemprop="articleBody">
      <p>I have recently found myself involved in many discussions centered on the question of how we might develop a satisfactory science of modern machine learning. It certainly seems likely that such a science should be possible, as every important human feat of engineering has eventually admitted an explanatory science. Given such a science, engineering artifacts are revealed as points in a space of viable constructions: with an understanding of mechanics and materials science, we see the Taj Mahal and the Colosseum are two points in the space of stable freestanding structures made of stone, and we can describe the boundaries of this set. It is of course one of the great scientific questions of our time whether current foundation models and their inevitable successors may be located within such a scientific framework.</p>

<p>While there is widespread support for work developing the “science of deep learning,” there is little consensus as to what this science will look like or what constitutes meaningful progress. Much of this disarray is of course inevitable and healthy: deep learning is complex, complementary approaches will be necessary, and we do not know what, exactly, we are looking for. Much of the confusion, however, is evitable and unhelpful: even when searching for an unknown object, it helps to search methodically. This essay is a discussion of the method of search.</p>

<p>It appears to me that the present disorder lies mostly downstream from confusion about some basic questions: what is science, and how do you do it? Actually, we don’t care about science merely because it is Science, but rather because it is a technique we may use, so what we are really asking is: how do you make useful sense of something mysterious in the world, and when the mystery is great, how do you go about making progress anyways? While these questions are basic, they are by no means easy. I would like to share some thoughts on these questions informed by my experience and my own process of trial and error.</p>

<p>Many great thinkers of the last century have offered insightful discussions of the scientific mindset and process, and I strongly recommend sitting down with <a href="https://en.wikipedia.org/wiki/Falsifiability">Popper’s notion of falsifiability</a>, <a href="https://www.lri.fr/~mbl/Stanford/CS477/papers/Kuhn-SSR-2ndEd.pdf">Kuhn’s depiction of the scientific process</a>, <a href="https://feynman.com/science/what-is-science/">Feynman’s joyful empiricism</a>, and <a href="https://www.lesswrong.com/w/original-sequences">Yudkowsky’s techniques for clear thinking</a>. All have greatly shaped my own views, and I have little to say about the general process of science that one of them has not already said better. I would like to contribute just one idea concerning the so-called scientific method.</p>

<p>We learn in grade school that the process of science follows a defined sequence of steps: observation, hypothesis, experiment (with at least three trials), analysis of data, and acceptance or rejection of the hypothesis. However, any practicing scientist knows that this is not really how science works. The anatomy of a scientific project usually bears little resemblance to this tidy storybook picture.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> Useful projects take such a great diversity of forms that it can seem like anything at all goes. One might then fairly wonder: are there, after all, any truly essential steps, or is one approach as good as another? This is an important question for any field that hopes to make material progress towards understanding a great mystery.</p>

<p>It seems to me that, yes, there are two essential steps to the scientific method. Step A is to figure something out. Step B is to check and make sure you’re not wrong. You can do these steps in any order, but you have to do them both.</p>

<p><br /></p>
<div style="text-align: center;">
  <img src="/img/scientific_method/scientific_method.png" width="60%" />
  <div>
    <small>
      <i><b>Figure 1:</b> The scientific method.</i>
    </small>
  </div>
</div>
<p><br />
<br /></p>

<p>All the good science I know does both of these steps. If you only do the first step — figuring something out but not adequately checking that you’re right — you’re doing philosophy, or theology, or another speculative practice. Such speculation can be beautiful and useful, but at the end of the day, it can rarely be built upon. If you only do the second thing — performing an empirical check but not figuring anything out — you’re usually doing engineering.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup></p>

<p>There are no rules whatsoever as to how you do the first step. You are allowed to figure things out via educated guess, long experience, mathematical derivation, meditation, or divine inspiration. This is often where the ingenuity of the theorist enters into play. There is only one rule with the second step: you have to do a <em>good job</em> checking you’re not wrong, ideally good enough to convince other people. This, too, can be done in many different ways — direct experiment, elimination of alternatives, checking new predictions — but it is absolutely essential that it is done adequately. It can be very difficult to do this well, or even to figure out how to do it! This is the nerve-wracking step where one makes sure that one isn’t fooling oneself. This is usually where the ingenuity of the experimentalist comes into play.<sup id="fnref:a" role="doc-noteref"><a href="#fn:a" class="footnote">3</a></sup></p>

<p>Most of the poor science of which I am aware fails in one of these two steps. It is, of course, very common for a study to fail to adequately demonstrate its central claims: this is understandable, as true, interesting facts are quite difficult to find! On the other side, uninteresting, hypertechnical experiments (which have unfortunately become the norm in certain crowded areas of physics) perform their empirical checks just fine, but when the lab equipment is back in its boxes, it is unclear what general fact has been figured out. (Yep, our Rube Goldberg machine of diffraction gratings, modulators, cavities, and heavy atoms works as predicted! Anyone remember what it was all for?) I also see studies that claim to figure something out about a system of interest (e.g., deep learning), but which fail to state a specific enough conjecture to go and test it, which is a partial failure in both steps. (More on that later.)</p>

<p>It is worth clarifying that a scientist does not have to do both steps of the scientific method in every scientific paper. An individual contribution may be entirely the proposal of a new idea, as in Darwin’s book or most of the <a href="https://www.chemteam.info/Chem-History/Planck-1901/Planck-1901.html">seminal</a> <a href="https://uni-tuebingen.de/fileadmin/Uni_Tuebingen/Fakultaeten/MathePhysik/Institute/IAP/Forschung/MOettel/Geburt_QM/bohr_PhilMag_26_1_1913.pdf">theoretical</a> <a href="https://link.springer.com/article/10.1007/BF01397280">physics</a> <a href="https://uni-tuebingen.de/fileadmin/Uni_Tuebingen/Fakultaeten/MathePhysik/Institute/IAP/Forschung/MOettel/Geburt_QM/schrodinger_AnnPhys_386_109_1926.pdf">papers</a> <a href="https://onlinelibrary.wiley.com/doi/10.1002/andp.19053220806">of the early 1900s</a>, or it may consist entirely of measurements, as in Tycho Brahe’s meticulous observations of the planets or <a href="https://www.nature.com/articles/s41586-020-2964-7">careful modern measurements of fundamental physical constants</a>. It is quite legitimate for a contribution to <em>dis</em>prove an existing belief without offering a replacement. The important thing is that a scientist doing one or the other recognizes that they are part of a conversation with the other part: the person proposing the ideas expects other people to go and test them and so tries to make it easy for them to do so, and the people checking the ideas know what the implications are if the experiment comes out one way or the other. Every scientific contribution should understand itself as part of a project that <em>does</em> do both steps of the scientific method.</p>

<p>Why are both of these steps necessary for the progress of science? If a line of research does not purport to have figured out any general fact, it is unclear what has been learned or how to build on it. On the other hand, if it does not adequately check its claims, then until it does, it will carry a shadow of fundamental doubt that prevents others from productively building on it. Furthermore, and often more significantly in practice, the act of checking usually contains within it the act of application, as the most convincing way to check a claim is often to operationalize it to do something of interest. Science is an edifice that builds on itself. It usually consists of so many layers that each piece of brickwork must be quite solid to support future building, and each brick must be crafted with future bricks in mind.</p>

<p>If you really believe me that the essential scientific method has only two steps, you might ask: what’s all this other mumbo jumbo about preregistered hypotheses, repeated trials, cognitive biases and what not? There are a few things going on. First off, while these two steps are simple, actually doing them is hard, so we have some established techniques that sometimes make them easier. Some of these help with the figuring out, but that’s mostly a dark art.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">4</a></sup> Most of these are techniques for the <em>checking</em> of our knowledge: preregistered hypotheses, multiple trials, the inclusion of error bars, blind review, and most of the other rituals of science are <em>ways to do step B.</em> None is essential, but they are useful techniques for checking our answer and avoiding fooling ourselves.</p>

<p>Secondly, some of these techniques are field-specific. For example, in psychology, social science, and nutrition, it’s notoriously tempting to choose one’s hypothesis after seeing the data. In these fields, the space of hypotheses is usually large and the resolving power of evidence is usually weak, so choosing the most-supported claim post-hoc often amounts to <a href="https://en.wikipedia.org/wiki/Data_dredging">p-hacking</a>, and preregistering hypotheses makes it more likely to not be totally wrong. In (non-string-theory) physics, the situation is usually the opposite — hypotheses are few and evidence is abundant — so preregistration isn’t necessary.</p>

<p>These steps apply even in a nascent field that knows very little. While no method is sufficient to guarantee useful progress in the search, failure to do both steps all but guarantees no progress will be made. By way of analogy, when searching a large unfamiliar house for a desired object, one’s chances of success are greatly improved by a methodical search that progressively expands an explored volume. It is possible to learn that <em>it’s not in this cabinet,</em> say, but only if one first identifies the cabinet as a useful unit of exploration, then does a sufficiently thorough search that the cabinet does not need to be revisited in the future. Failures <em>are</em> progress, but <em>only</em> when they are sufficiently clear and careful so as to reassure other searchers that the space of possible truths is meaningfully reduced.</p>

<p>In summary, the scientific method consists of two steps: you must figure something out, and you must adequately check that you are not mistaken. It seems to me that these are the two things we must demand of any useful scientific project.</p>

<h3 id="how-to-recognize-the-scientific-method-in-the-science-of-deep-learning">How to recognize the scientific method in the science of deep learning</h3>

<p>Deep learning presents a large number of important mysteries. What exactly we believe these mysteries <em>are</em> has evolved over time and will continue to do so, but all present agree that the mysteries are there. Certainly it seems that the practice of deep learning involves far more arbitrary choices and yields far more surprising results than it ought to if we knew better. There is thus probably much ground to gain. Because the success of deep learning is an empirical phenomenon and we wish to explain it, this is very much a scientific question, and we will be wise to consciously use the methods of science to structure our search.</p>

<p>We are gradually learning to do genuine science in the study of deep learning, and the rewards have been proportionate. However, a great deal of research effort ostensibly in service of our understanding of deep learning is expended in directions which are quite far from science and which consequently make little real progress. This is not a personal vendetta of mine: I have found this to be the consensus of virtually every researcher in the field with whom I have discussed the subject. In fact, this number includes many interviewees who have described their <em>own</em> work to me as of this ineffectual type, usually with a palpable air of despondence! (By contrast, the deep learning researchers I know who have caught the “science bug” tend to be energized and optimistic.) We as a field are due for a serious discussion of our methods and search strategy, and we can be optimistic that effectual methods are quite achievable.</p>

<p>How can we recognize the scientific method in the study of deep learning? We should look for work which (a) purports to figure out something particular and clear about deep learning, and (b) reports simple, convincing experiments that compellingly support it. The things figured out can really take any form so long as they are clearly stated and seem useful. They may be empirical (”A causes B”; “C phenomenon reliably happens”), mathematical (equations, limits, new mathematical objects), or even metascientific (e.g., “D is a useful proxy model for deep learning”). Qualitative claims are fine, but quantitative claims are best, because they may be verified with great confidence and may usually be applied in a large number of cases. Qualitative claims are rarely verified reliably (and often fold under later scrutiny) because of the sheer number of possible causes in a system as complex as deep learning. In assessing the progress of deep learning, we should count the number of interesting, easily verifiable quantitative claims one can make about deep learning systems, and individual researchers should seek to add to this count. This is how we will mark our progress in our search.</p>

<p>So, how does most “science of deep learning” work do on this minimal rubric of scientific method? By way of illustration, let me run through some of the major research trends in the last five years of deep learning theory. I will start with some failings before ending with some victories.</p>

<p><strong>On formality and rigor to the detriment of insight.</strong> It is an item of little controversy (at least when discussing off the record) that a great number of deep learning theory papers are impressively rigorous and mathematically complex, but ultimately shed little to no light on the mystery originally motivating the endeavor. Papers of this sort tend to share certain features: asymptotic notation obscures large hidden constants; theorem statements require significant parsing in order to extract the essence of the result; the problem setup introduces complexity for the sake of a more impressive result rather than simplifying the setup for clarity and insight; few or no experiments are reported, and certainly none with nonlinear networks. Any seasoned deep learning theorist has read numerous such papers.</p>

<p>It seems to me that this pattern is the result of mistaking the scientific study of deep learning for a discipline of mathematics, which then requires formality and rigor. It emphatically is not: we are faced here with great and glaring empirical mysteries, and experiments are cheap and easy.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">5</a></sup> It seems virtually guaranteed that we will first understand deep learning through quick-and-dirty nonrigorous arguments which may later be formalized, as a path through the woods is first blazed and then only later paved over in asphalt. Formality and rigor are a hindrance if they make it harder to understand the real nature of what you have figured out. As the saying goes, all theorems are true, but only some are interesting, and taking stock of the present state of our knowledge, it is greatly preferable to have an interesting nonrigorous result than an uninteresting theorem.</p>

<p>Papers of this mathematical sort rarely include experiments: sometimes there are experiments tacked on at the end, but they are usually an afterthought. If the study of deep learning were mathematics, this would be understandable, as a proven theorem requires no empirical demonstration. Because the study of deep learning is a science, however, neglecting experiments is utter folly. Unless the proven theorem totally resolves an important question in a completely realistic setting, experiments can extend a result’s scope of applicability, show its limits, check assumptions, or simply make it easier to understand the stated claim. If our goal is to understand deep learning, it sure seems wise to check empirically whether whatever you suppose you have figured out <em>applies to deep learning!</em> If it doesn’t, or the fit is worse than you expected, this merits explanation. If it does, then the contribution is all the greater.</p>

<p>The overly mathematical nature of much deep learning theory research is natural and understandable given the field’s history: most workers come from TCS, statistics, or mathematics. Nonetheless, the game has changed, and we should require less rigor, more insight, and more empirics from contributions.</p>

<p><strong>Progress in the study of the dynamics of neural network training.</strong> It seems to me that much of the lasting progress of the last five years — the stuff that’s really stuck around and been built on — is essentially all of a particular type which marries theory and empirics. This strain of research is characterized by several trends:</p>

<ul>
  <li>It demands satisfying equations and quantitative predictions, and it is willing to study very simple cases and study dumb-seeming quantities in order to make this happen.</li>
  <li>While the equations do not usually come <em>from</em> experiments, they are easily verified <em>by</em> experiments.</li>
  <li>Assumptions are checked empirically. Assumptions that are both good and useful are celebrated and kept around.</li>
  <li>It is humble: it studies only what it can describe well, and does not make premature claims about downstream topics.</li>
</ul>

<p>Almost all of the work in this vein describes the <em>dynamics</em> of neural network learning rather than the <em>performance,</em> which is what I mean by humility. Some touchstone topics in this vein include the theories of <a href="https://arxiv.org/abs/1312.6120">deep linear networks</a>, the <a href="https://arxiv.org/abs/1711.00165">NNGP</a> and <a href="https://arxiv.org/abs/1806.07572">neural tangent kernel</a>, <a href="https://proceedings.mlr.press/v139/yang21c.html">the maximal update parameterization</a>, the <a href="https://arxiv.org/abs/2103.00065">edge of stability</a>, the <a href="https://arxiv.org/abs/2110.03922">generalization of kernel ridge regression</a>, and the study of hyperparameter scaling relationships (see, e.g., <a href="https://arxiv.org/abs/2309.16620">here</a>). All these ideas presented new mathematical quantities derived from model training which closely follow simple equations. All have proven solid enough to build further understanding on top of.</p>

<p>This variety of deep learning theory does not yet have an accepted name. We should give it one. Because of its similarities to the physical sciences, the “physics of deep learning” is a candidate term, though this carries historical baggage, has already used to describe many things including <a href="https://arxiv.org/abs/2305.13673">other research directions</a>, and risks alientating the mathematicians and statisticians who have contributed to this productive type of work and will do so in the future. “Analytical interpretability” may be a good term for this, conveying both the high bar of analytical results with the promise of interpreting the training process of deep learning. Plus, it abbreviates to “AI.”<sup id="fnref:b" role="doc-noteref"><a href="#fn:b" class="footnote">6</a></sup> Since this line of work includes virtually all extant examples of quantitatively predictive theories for deep learning, I like to think of it as “experiment-dots-on-theory-curves” or “dots-on-curves” theory.</p>

<p><strong>What about empirical science?</strong>
The above discussion is centered largely on deep learning theory. The science of deep learning is a rather greater endeavor, and has had some successes. Mechanistic interpretability cannot do what the physics of deep learning could (and vice versa; both are necessary), but it has been quite admirable as a scientific endeavor: it has made good use of the scientific method to coordinate a large-scale search over a difficult space. Deep learning theory should learn from it.</p>

<p>On the even more empirical side, phenomena like adversarial examples and the lottery-ticket hypothesis were excellent empirical observations, though much of the followup work on these topics makes less use of the scientific method and has accreted into less lasting knowledge. The observation of scaling laws in neural network performance is perhaps the one extant example of a robust and important equation extracted purely from neural network empirics. This was an excellent observation, and it remains unexplained.</p>

<p>Most “observations” in deep learning are of the type that “X method works for Y task.” Much fruitful dialog could be had between deep learning scientists and practitioners if the practitioners were more proactive in aggregating interesting phenomena and handing them to the scientists, and likewise if the scientists were more proactive in asking for them. Of course, most practitioners are too laser-focused on building AGI to care about theory, so I am dubious this will happen.</p>

<p><strong>“Hail Maries.”</strong>
Lastly, there have been a few ideas proffered of a type that I’ll call “hail Maries” after the long-bomb football pass.
These ideas try to take a big step forwards all in one step with a very good guess: they tend to be summarizable by statements of the form “hey, what if deep learning is actually just X?”
A good example of this is the much-embattled <a href="https://arxiv.org/abs/1503.02406">“information bottleneck” theory</a>.
Even though the IB was conclusively disproven soon after its proposal, I strongly applaud the bold, testable hypothesis and honest attempt to figure something out.
Attempts to jump ahead in the story like this are likely to be wrong, but they are very much permitted in science.
Much of the development of quantum mechanics consisted of bold, unprecendent guesses!
Remember that there are no rules as to how one must figure something out: intuition-guided guesswork is quite allowed.
In our field, there are few ideas and much energy available to test them, so I would like to see more bold guesses of this type.
We should expect to see more such leaps as time goes on, and some of them will turn out to be right.</p>

<h3 id="conclusions">Conclusions</h3>

<p>What now? We are making steady progress towards a theory of deep learning, a theory that we presumably hope to bend to the benefit of humankind. It has been over a decade since AlexNet, and we have tried much. Most of this has failed, but some of it has succeeded. It is a good time now to step back, notice the patterns in our successes, reassess our strategies, and seriously refocus our effort. Let’s get moving.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>To list some deviations I have seen firsthand: sometimes the hypothesis changes dramatically, or only becomes clear at the end, or is absent altogether. Sometimes a single trial suffices, and sometimes one needs millions. Sometimes the hypothesis and conclusions are obvious and the data gathering is the whole project. Sometimes the conclusion has little to do with the initial aims of the project. I have seen very few scientific projects follow the script of the “science fair scientific method,” and these few usually turned out poorly! For example, I’ve rarely seen an interesting hypothesis confirmed by experiment when the scientists weren’t already damn near sure it was going to be true. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>Of course, the creator of any engineered artifact can rightly claim to have “figured out” that such an artifact is possible. Sometimes this is quite an interesting discovery! The boundaries between engineering and science are not clear, and we do not need them to be. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:a" role="doc-endnote">
      <p>If I were to add a third step, it would be convincing other people. The community is the ultimate judge of whether you have figured something out and whether your experiments show that it is not wrong. A colleague points out that this is similar to Dorothy Sayer’s <a href="https://en.wikipedia.org/wiki/The_Mind_of_the_Maker">third step of the creative process</a>: sharing your work with the world and thereby having an effect on other people. To me, peer review feels like an important part of the scientific process, but feels secondary to the scientific <em>method</em> – even alone on a desert island, you could do science as I describe it here – and in any case, it’s not like anyone is making important scientific progress and <em>not</em> sharing it, so I feel comfortable omitting it. <a href="#fnref:a" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Yudkowsky attempts to make this mysterious process more mechanical in some of the Sequences, but it’s still quite difficult to come up with hypotheses. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>It is a very interesting question, perhaps worthy of discussion elsewhere, what the merits of rigor and formality are in an exploratory endeavor. Most obviously, a proven theorem is always correct and will not fail unexpectedly, so all else equal, a theorem is preferable to an equivalent nonrigorous claim. When, though, does the extra solidity justify the price in labor? It seems to me that rigor and formality are most useful when the class of objects one wishes to describe is very large and of unknown character, and bizarre or pathological cases are prevalent and important. For example, the space of groups is very large and diverse, and so without axioms to work from, we are lost. Similarly, real analysis requires formality because it turns out the set of all univariate functions on the reals is far stranger than expected, and we cannot rely on our intuitions. On the other hand, when one already has an intuitive feel for the set of objects one wishes to characterize, the guardrails of formality are not so necessary. It is for this reason that you need very little formal math to do physics. This is very much the case in which we find ourselves with deep learning. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:b" role="doc-endnote">
      <p>Hat tip to Alex Atanasov for coining the term. <a href="#fnref:b" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

    </div>

  </div>

</article>

      </div>
    </div>

    <div class="text-center p-3" style="background-color: #edf3f5;">
  <div class="container ">
    <div class="row justify-content-md-center">

      <div class="col-2">
        <p class="text-center">
          <i class="far fa-envelope"></i>
          <a href="mailto:jsi@berkeley.edu">jsi@berkeley.edu</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-github"></i>
          <a href="https://github.com/james-simon">james-simon</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fas fa-graduation-cap"></i>
          <a href=https://scholar.google.com/citations?user=zjGfh3sAAAAJ&hl=en>gScholar</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          <i class="fab fa-instagram"></i>
          <a href="https://instagram.com/sam.simon17">sam.simon17</a>
        </p>
      </div>

      <div class="col-2">
        <p class="text-center">
          SSN: 314-15-9265
        </p>
      </div>

    </div>
  </div>
</div>
</footer>

  </body>

</html>
